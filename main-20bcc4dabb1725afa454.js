webpackJsonp([1],{

/***/ 100:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FromFactor_1 = __webpack_require__(18);\r\nvar Expressions_1 = __webpack_require__(13);\r\nvar Helpers_1 = __webpack_require__(15);\r\nvar Table = (function (_super) {\r\n    __extends(Table, _super);\r\n    function Table($name, requiredColumns, optionalColumns) {\r\n        var _this = _super.call(this, Helpers_1.combine(requiredColumns, optionalColumns), false) || this;\r\n        _this.$name = $name;\r\n        _this.$requiredColumns = requiredColumns;\r\n        _this.$optionalColumns = optionalColumns;\r\n        return _this;\r\n    }\r\n    Table.prototype.toString = function () {\r\n        var str = \"\";\r\n        if (this.$name.schema)\r\n            str = this.$name.schema + \".\";\r\n        str += this.$name.name;\r\n        return str;\r\n    };\r\n    return Table;\r\n}(FromFactor_1.FromItem));\r\nexports.Table = Table;\r\n;\r\nfunction table(tableName, requiredColumns, optionalColumns) {\r\n    if (optionalColumns === void 0) { optionalColumns = {}; }\r\n    var setters = [];\r\n    var toTableColumn = function (name, columnType) {\r\n        if (!columnType)\r\n            throw new Error(\"Column '\" + name + \"' has no type.\");\r\n        return new Expressions_1.TableColumn(name, columnType, function (setter) { return setters.push(setter); });\r\n    };\r\n    var reqColumns = Helpers_1.toObject(Helpers_1.objectEntries(requiredColumns)\r\n        .map(function (_a) {\r\n        var name = _a[0], columnType = _a[1];\r\n        return toTableColumn(name, columnType);\r\n    }), function (i) { return i.name; });\r\n    var optColumns = Helpers_1.toObject(Helpers_1.objectEntries(optionalColumns)\r\n        .map(function (_a) {\r\n        var name = _a[0], columnType = _a[1];\r\n        return toTableColumn(name, columnType);\r\n    }), function (i) { return i.name; });\r\n    var tblName = (typeof tableName === \"string\") ? { name: tableName, schema: undefined } : tableName;\r\n    var table = new Table(tblName, reqColumns, optColumns);\r\n    for (var _i = 0, setters_1 = setters; _i < setters_1.length; _i++) {\r\n        var setter = setters_1[_i];\r\n        setter(table);\r\n    }\r\n    return table;\r\n}\r\nexports.table = table;\r\n//# sourceMappingURL=Table.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Table.js\n// module id = 100\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Table.js?");

/***/ }),

/***/ 101:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar SqlGenerator_1 = __webpack_require__(102);\r\nvar PostgreSqlGenerator = (function (_super) {\r\n    __extends(PostgreSqlGenerator, _super);\r\n    function PostgreSqlGenerator() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    PostgreSqlGenerator.prototype.quoteSchemaOrTableOrColumnName = function (name) {\r\n        if (this.options.skipQuotingIfNotRequired && /^[a-z_][a-z_0-9]*$/.test(name))\r\n            return name;\r\n        return this.escapeIdentifier(name);\r\n    };\r\n    PostgreSqlGenerator.prototype.escapeValue = function (expr, context) {\r\n        var val = expr.type.serialize(expr.value);\r\n        if (expr.preferEscaping) {\r\n            if (val === null)\r\n                return \"null\";\r\n            if (typeof val === \"string\")\r\n                return this.escapeLiteral(val);\r\n            if (typeof val === \"number\")\r\n                return val.toString();\r\n            if (typeof val === \"boolean\")\r\n                return val.toString();\r\n            throw new Error(\"Unsupported value: '\" + val + \"'.\");\r\n        }\r\n        else {\r\n            context.context.parameters.push(val);\r\n            var id = context.context.parameters.length;\r\n            return \"$\" + id;\r\n        }\r\n    };\r\n    // https://github.com/brianc/node-postgres/blob/f42924bf057943d5a79ff02c4d35b18777dc5754/lib/client.js#L261\r\n    PostgreSqlGenerator.prototype.escapeIdentifier = function (str) {\r\n        var escaped = '\"';\r\n        for (var i = 0; i < str.length; i++) {\r\n            var c = str[i];\r\n            if (c === '\"') {\r\n                escaped += c + c;\r\n            }\r\n            else {\r\n                escaped += c;\r\n            }\r\n        }\r\n        escaped += '\"';\r\n        return escaped;\r\n    };\r\n    // https://github.com/brianc/node-postgres/blob/f42924bf057943d5a79ff02c4d35b18777dc5754/lib/client.js#L280\r\n    PostgreSqlGenerator.prototype.escapeLiteral = function (str) {\r\n        var hasBackslash = false;\r\n        var escaped = '\\'';\r\n        for (var i = 0; i < str.length; i++) {\r\n            var c = str[i];\r\n            if (c === '\\'') {\r\n                escaped += c + c;\r\n            }\r\n            else if (c === '\\\\') {\r\n                escaped += c + c;\r\n                hasBackslash = true;\r\n            }\r\n            else {\r\n                escaped += c;\r\n            }\r\n        }\r\n        escaped += '\\'';\r\n        if (hasBackslash === true) {\r\n            escaped = ' E' + escaped;\r\n        }\r\n        return escaped;\r\n    };\r\n    return PostgreSqlGenerator;\r\n}(SqlGenerator_1.SqlGenerator));\r\nexports.PostgreSqlGenerator = PostgreSqlGenerator;\r\n//# sourceMappingURL=PostgreSqlGenerator.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/Adapters/PostgreSqlGenerator.js\n// module id = 101\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/Adapters/PostgreSqlGenerator.js?");

/***/ }),

/***/ 102:
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar RetrievalQuery_1 = __webpack_require__(35);\r\nvar ValuesQuery_1 = __webpack_require__(98);\r\nvar InsertQuery_1 = __webpack_require__(95);\r\nvar UpdateQuery_1 = __webpack_require__(97);\r\nvar DeleteQuery_1 = __webpack_require__(94);\r\nvar SqlStatement_1 = __webpack_require__(99);\r\nvar FromFactor_1 = __webpack_require__(18);\r\nvar SelectQuery_1 = __webpack_require__(96);\r\nvar Exprs = __webpack_require__(13);\r\nvar Table_1 = __webpack_require__(100);\r\nvar Ordering_1 = __webpack_require__(60);\r\nvar Helpers_1 = __webpack_require__(15);\r\n// IMPORTANT IMPLEMENTATION NOTICE: expressions must be generated in the order they appear in the final sql string!\r\n// Otherwise prepared statements with parameters get messed up.\r\nvar SqlGenerator = (function () {\r\n    function SqlGenerator(options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.options = options;\r\n        this.fromFactorDispatcherInitialized = false;\r\n        this.fromFactorDispatcher = new Helpers_1.DynamicDispatcher();\r\n        this.expressionDispatcherInitialized = false;\r\n        this.expressionDispatcher = new Helpers_1.DynamicDispatcher();\r\n    }\r\n    SqlGenerator.prototype.toSql = function (statement) {\r\n        var context = { parameters: [] };\r\n        var sql = this.transformToSql(statement, context);\r\n        return { sql: sql, parameters: context.parameters };\r\n    };\r\n    SqlGenerator.prototype.transformToSql = function (statement, context) {\r\n        if (statement instanceof SelectQuery_1.SelectQuery)\r\n            return this.transformSelectQueryToSql(statement, context);\r\n        if (statement instanceof UpdateQuery_1.UpdateQuery)\r\n            return this.transformUpdateQueryToSql(statement, context);\r\n        if (statement instanceof InsertQuery_1.InsertQuery)\r\n            return this.transformInsertQueryToSql(statement, context);\r\n        if (statement instanceof DeleteQuery_1.DeleteQuery)\r\n            return this.transformDeleteQueryToSql(statement, context);\r\n        if (statement instanceof ValuesQuery_1.ValuesQuery)\r\n            return this.transformValuesQueryToSql(statement, context);\r\n        if (statement instanceof RetrievalQuery_1.UnionQuery)\r\n            return this.transformUnionQueyToSql(statement, context);\r\n        if (statement instanceof SqlStatement_1.StartTransactionStatement)\r\n            return \"BEGIN\";\r\n        if (statement instanceof SqlStatement_1.CommitTransactionStatement)\r\n            return \"COMMIT\";\r\n        if (statement instanceof SqlStatement_1.RollbackTransactionStatement)\r\n            return \"ROLLBACK\";\r\n        throw new Error(\"Unsupported query: \" + statement);\r\n    };\r\n    SqlGenerator.prototype.createExpressionContext = function (froms, context) {\r\n        if (!this.options.shortenColumnNameIfUnambigous)\r\n            return { isColumnNameUnambigous: function (name) { return false; }, resolveNamedExpression: false, context: context };\r\n        var allColumns = [];\r\n        for (var _i = 0, froms_1 = froms; _i < froms_1.length; _i++) {\r\n            var from = froms_1[_i];\r\n            if (!from)\r\n                continue;\r\n            var allFromFactors = FromFactor_1.FromFactor.getAllFromFactors(from);\r\n            allColumns = allColumns.concat.apply(allColumns, allFromFactors.map(function (f) { return Helpers_1.objectValues(f.$columns); }));\r\n        }\r\n        var set = new Set();\r\n        var duplicates = new Set();\r\n        for (var _a = 0, allColumns_1 = allColumns; _a < allColumns_1.length; _a++) {\r\n            var col = allColumns_1[_a];\r\n            if (set.has(col.name))\r\n                duplicates.add(col.name);\r\n            else\r\n                set.add(col.name);\r\n        }\r\n        return { isColumnNameUnambigous: function (name) { return !duplicates.has(name); }, resolveNamedExpression: false, context: context };\r\n    };\r\n    SqlGenerator.prototype.transformUnionQueyToSql = function (query, context) {\r\n        var query1Sql = this.transformToSql(query.query1, context);\r\n        var query2Sql = this.transformToSql(query.query2, context);\r\n        return \"(\" + query1Sql + \") UNION (\" + query2Sql + \")\";\r\n    };\r\n    SqlGenerator.prototype.transformValuesQueryToSql = function (query, context) {\r\n        var _this = this;\r\n        var columns = query.columns;\r\n        if (query.values.length === 0) {\r\n            return \"SELECT \" + Object.keys(columns).map(function (k) { return \"null\"; }).join(\", \") + \" WHERE false\";\r\n        }\r\n        var sql = \"VALUES \";\r\n        var expressionContext = { isColumnNameUnambigous: function (c) { return true; }, resolveNamedExpression: true, context: context };\r\n        sql += query.values.map(function (v) {\r\n            return \"(\" + Helpers_1.objectEntries(columns).map(function (_a) {\r\n                var name = _a[0], type = _a[1];\r\n                return _this.escapeValue(new Exprs.ValueExpression(type, v[name]), expressionContext);\r\n            }).join(\", \") + \")\";\r\n        }).join(\", \");\r\n        return sql;\r\n    };\r\n    SqlGenerator.prototype.transformInsertQueryToSql = function (query, context) {\r\n        var _this = this;\r\n        var data = query.getState();\r\n        var sql = \"INSERT INTO \" + this.referToFromItem(data.table);\r\n        var expressionContext = { isColumnNameUnambigous: function (c) { return true; }, resolveNamedExpression: true, context: context };\r\n        if (Array.isArray(data.values)) {\r\n            if (data.values.length === 0) {\r\n                sql += \" (SELECT null WHERE false)\";\r\n            }\r\n            else {\r\n                var firstRow = data.values[0];\r\n                var columnNames_1 = Object.keys(firstRow);\r\n                for (var _i = 0, columnNames_2 = columnNames_1; _i < columnNames_2.length; _i++) {\r\n                    var selectedCol = columnNames_2[_i];\r\n                    if (!(selectedCol in data.table.$columns))\r\n                        throw new Error(\"Column '\" + selectedCol + \"' does not exist on table '\" + data.table + \"'.\");\r\n                }\r\n                sql += \"(\" + columnNames_1.map(function (c) { return _this.quoteColumnName(c); }).join(\", \") + \") VALUES \";\r\n                sql += data.values.map(function (v) { return \"(\" + columnNames_1.map(function (colName) {\r\n                    return _this.escapeValue(Exprs.val(v[colName], data.table.$columns[colName].type), expressionContext);\r\n                }).join(\", \") + \")\"; }).join(\", \");\r\n            }\r\n        }\r\n        else {\r\n            var s = data.values.getState();\r\n            var columnNames = s.selected.map(function (selectedCol) {\r\n                if (selectedCol instanceof Exprs.AllExpression)\r\n                    throw new Error(\"AllExpressions in insert into query are not supported.\");\r\n                if (!(selectedCol.name in data.table.$columns))\r\n                    throw new Error(\"Column '\" + selectedCol.name + \"' does not exist on table '\" + data.table + \"'.\");\r\n                return selectedCol.name;\r\n            });\r\n            sql += \"(\" + columnNames.map(function (c) { return _this.quoteColumnName(c); }).join(\", \") + \") \" + this.transformToSql(data.values, context);\r\n        }\r\n        if (data.selected.length > 0) {\r\n            sql += \" RETURNING \" + this.toSelectStatementStr(data.selected, expressionContext);\r\n        }\r\n        return sql;\r\n    };\r\n    SqlGenerator.prototype.transformDeleteQueryToSql = function (query, context) {\r\n        var data = query.getState();\r\n        var sql = \"DELETE FROM \" + this.referToFromItem(data.table);\r\n        var expressionContext = this.createExpressionContext([data.using, data.table], context);\r\n        if (data.using) {\r\n            sql += \" USING \" + this.fromToSql(data.using, expressionContext);\r\n        }\r\n        if (!data.whereCondition)\r\n            throw new Error(\"Delete Queries must have a where condition.\");\r\n        sql += \" WHERE \" + this.expressionToSql(data.whereCondition, expressionContext);\r\n        if (data.selected.length > 0) {\r\n            sql += \" RETURNING \" + this.toSelectStatementStr(data.selected, expressionContext);\r\n        }\r\n        return sql;\r\n    };\r\n    SqlGenerator.prototype.transformUpdateQueryToSql = function (query, context) {\r\n        var _this = this;\r\n        var data = query.getState();\r\n        var sql = \"UPDATE \" + this.referToFromItem(data.table);\r\n        var expressionContext = this.createExpressionContext([data.from, data.table], context);\r\n        sql += \" SET \" + Helpers_1.objectEntries(data.updatedColumns).map(function (_a) {\r\n            var name = _a[0], value = _a[1];\r\n            return _this.quoteColumnName(name) + \" = \" + _this.expressionToSql(value, expressionContext);\r\n        }).join(\", \");\r\n        if (data.from) {\r\n            sql += \" FROM \" + this.fromToSql(data.from, expressionContext);\r\n        }\r\n        if (!data.whereCondition)\r\n            throw new Error(\"Update Queries must have a where condition.\");\r\n        sql += \" WHERE \" + this.expressionToSql(data.whereCondition, expressionContext);\r\n        if (data.selected.length > 0) {\r\n            sql += \" RETURNING \" + this.toSelectStatementStr(data.selected, expressionContext);\r\n        }\r\n        return sql;\r\n    };\r\n    SqlGenerator.prototype.transformSelectQueryToSql = function (query, context) {\r\n        var _this = this;\r\n        var data = query.getState();\r\n        var sql = \"SELECT\";\r\n        var expressionContext = this.createExpressionContext([data.from], context);\r\n        if (data.selected.length > 0) {\r\n            sql += \" \" + this.toSelectStatementStr(data.selected, expressionContext);\r\n        }\r\n        if (data.from) {\r\n            sql += \" FROM \" + this.fromToSql(data.from, expressionContext);\r\n        }\r\n        if (data.whereCondition) {\r\n            sql += \" WHERE \" + this.expressionToSql(data.whereCondition, expressionContext);\r\n        }\r\n        if (data.groupBys.length > 0) {\r\n            var exprCt_1 = { isColumnNameUnambigous: expressionContext.isColumnNameUnambigous, resolveNamedExpression: false, context: context };\r\n            var statements = data.groupBys.map(function (e) { return _this.expressionToSql(e, exprCt_1); }).join(\", \");\r\n            sql += \" GROUP BY \" + statements;\r\n        }\r\n        if (data.havingCondition) {\r\n            var havingCondition = this.expressionToSql(data.havingCondition, { isColumnNameUnambigous: expressionContext.isColumnNameUnambigous, resolveNamedExpression: true, context: context });\r\n            sql += \" HAVING \" + havingCondition;\r\n        }\r\n        if (data.orderBys.length > 0) {\r\n            sql += \" ORDER BY \" + data.orderBys.map(function (d) { return Ordering_1.isOrderingAsc(d) ? _this.expressionToSql(d.asc, expressionContext) : (_this.expressionToSql(d.desc, expressionContext) + \" DESC\"); });\r\n        }\r\n        if (data.limit) {\r\n            sql += \" LIMIT \" + this.expressionToSql(data.limit, expressionContext);\r\n        }\r\n        if (data.offset) {\r\n            sql += \" OFFSET \" + this.expressionToSql(data.offset, expressionContext);\r\n        }\r\n        return sql;\r\n    };\r\n    SqlGenerator.prototype.toSelectStatementStr = function (selected, context) {\r\n        var _this = this;\r\n        return selected.map(function (expr) {\r\n            if (expr instanceof Exprs.NamedExpressionWrapper) {\r\n                return _this.expressionToSql(expr.expression, context) + \" AS \" + _this.quoteColumnName(expr.name);\r\n            }\r\n            return _this.expressionToSql(expr, context);\r\n        }).join(\", \");\r\n    };\r\n    SqlGenerator.prototype.quoteSchemaName = function (name) {\r\n        return this.quoteSchemaOrTableOrColumnName(name);\r\n    };\r\n    SqlGenerator.prototype.quoteTableName = function (name) {\r\n        return this.quoteSchemaOrTableOrColumnName(name);\r\n    };\r\n    SqlGenerator.prototype.quoteColumnName = function (name) {\r\n        return this.quoteSchemaOrTableOrColumnName(name);\r\n    };\r\n    SqlGenerator.prototype.referToFromItem = function (fromItem, includeSchema) {\r\n        if (includeSchema === void 0) { includeSchema = true; }\r\n        if (fromItem instanceof Table_1.Table) {\r\n            var result = \"\";\r\n            if (fromItem.$name.schema && includeSchema)\r\n                result += this.quoteSchemaName(fromItem.$name.schema) + \".\";\r\n            result += this.quoteTableName(fromItem.$name.name);\r\n            return result;\r\n        }\r\n        else if (fromItem instanceof FromFactor_1.NamedFromItem || fromItem instanceof FromFactor_1.QueryFromItem) {\r\n            return this.quoteTableName(fromItem.$name);\r\n        }\r\n        throw \"Unsupported\";\r\n    };\r\n    SqlGenerator.prototype.fromToSql = function (f, context) {\r\n        var _this = this;\r\n        if (!this.fromFactorDispatcherInitialized) {\r\n            this.fromFactorDispatcherInitialized = true;\r\n            this.fromFactorDispatcher\r\n                .register(Table_1.Table, function (f, context) {\r\n                return _this.referToFromItem(f);\r\n            })\r\n                .register(FromFactor_1.NamedFromItem, function (f, context) {\r\n                var oldName = _this.referToFromItem(f.fromItem);\r\n                var newName = _this.referToFromItem(f);\r\n                var sql = oldName + \" AS \" + newName;\r\n                if (FromFactor_1.isCastToColumns(f))\r\n                    sql += \"(\" + Object.keys(f.$columns).join(\", \") + \")\";\r\n                return sql;\r\n            })\r\n                .register(FromFactor_1.QueryFromItem, function (f, context) {\r\n                var newName = _this.referToFromItem(f);\r\n                var sql = \"(\" + _this.transformToSql(f.query, context.context) + \") AS \" + newName;\r\n                if (FromFactor_1.isCastToColumns(f))\r\n                    sql += \"(\" + Object.keys(f.$columns).join(\", \") + \")\";\r\n                return sql;\r\n            })\r\n                .register(FromFactor_1.FromFactorAbstractJoin, function (f, context) {\r\n                var left = _this.fromToSql(f.leftArg, context);\r\n                var right = _this.fromToSql(f.rightArg, context);\r\n                var sql;\r\n                if (f instanceof FromFactor_1.FromFactorAbstractConditionalJoin) {\r\n                    var condition = _this.expressionToSql(f.joinCondition, context);\r\n                    var join = void 0;\r\n                    if (f instanceof FromFactor_1.FromFactorCrossJoin)\r\n                        join = \"CROSS JOIN\";\r\n                    else if (f instanceof FromFactor_1.FromFactorFullJoin)\r\n                        join = \"FULL JOIN\";\r\n                    else if (f instanceof FromFactor_1.FromFactorInnerJoin)\r\n                        join = \"JOIN\";\r\n                    else if (f instanceof FromFactor_1.FromFactorLeftJoin)\r\n                        join = \"LEFT JOIN\";\r\n                    else\r\n                        throw new Error(\"Unsupported join\");\r\n                    return left + \" \" + join + \" \" + right + \" ON \" + condition;\r\n                }\r\n                else if (f instanceof FromFactor_1.FromFactorCrossJoin) {\r\n                    return left + \" CROSS JOIN \" + right;\r\n                }\r\n                else\r\n                    throw new Error(\"Unknown join.\");\r\n            });\r\n        }\r\n        return this.fromFactorDispatcher.dispatch(f, context);\r\n    };\r\n    SqlGenerator.prototype.escapeValue = function (expr, context) {\r\n        var val = expr.value;\r\n        var serialized = expr.type.serialize(val);\r\n        context.context.parameters.push(serialized);\r\n        return \"?\";\r\n    };\r\n    SqlGenerator.prototype.expressionToSql = function (e, context, parentPrecedenceLevel) {\r\n        if (parentPrecedenceLevel === void 0) { parentPrecedenceLevel = 1000; }\r\n        var result = this.expressionToSqlAutoParenthesis(e, context);\r\n        if (e.precedenceLevel > parentPrecedenceLevel)\r\n            return \"(\" + result + \")\";\r\n        return result;\r\n    };\r\n    SqlGenerator.prototype.expressionToSqlAutoParenthesis = function (e, context) {\r\n        var _this = this;\r\n        if (!this.expressionDispatcherInitialized) {\r\n            this.expressionDispatcherInitialized = true;\r\n            this.expressionDispatcher\r\n                .register(Exprs.NamedExpressionWrapper, function (e, context) {\r\n                if (context.resolveNamedExpression)\r\n                    return _this.expressionToSql(e.expression, context);\r\n                else\r\n                    return _this.quoteColumnName(e.name);\r\n            })\r\n                .register(Exprs.ValueExpression, function (e, context) { return _this.escapeValue(e, context); })\r\n                .register(Exprs.Column, function (e, context) {\r\n                var columnName = _this.quoteColumnName(e.name);\r\n                if (context.isColumnNameUnambigous(e.name))\r\n                    return columnName;\r\n                var tableName = _this.referToFromItem(e.fromItem);\r\n                return tableName + \".\" + columnName;\r\n            })\r\n                .register(Exprs.FromItemExpression, function (e, context) {\r\n                var tableName = _this.referToFromItem(e.fromItem, false);\r\n                return tableName;\r\n            })\r\n                .register(Exprs.AllExpression, function (e, context) {\r\n                var tableName = _this.referToFromItem(e.fromItem);\r\n                return tableName + \".*\";\r\n            })\r\n                .register(Exprs.BinaryOperatorExpression, function (e, context) {\r\n                var operator = e.operator;\r\n                var left = _this.expressionToSql(e.left, context, e.precedenceLevel);\r\n                var right = _this.expressionToSql(e.right, context, e.precedenceLevel);\r\n                return left + \" \" + operator + \" \" + right;\r\n            })\r\n                .register(Exprs.KnownFunctionInvocation, function (e, context) {\r\n                var functionName = e.functionName.toUpperCase();\r\n                var args = e.args.map(function (arg) { return _this.expressionToSql(arg, context); }).join(\", \");\r\n                return functionName + \"(\" + args + \")\";\r\n            })\r\n                .register(Exprs.RetrievalQueryAsExpression, function (e, context) { return \"(\" + _this.transformToSql(e.query, context.context) + \")\"; })\r\n                .register(Exprs.IsInValuesExpression, function (e, context) {\r\n                if (e.values.length === 0)\r\n                    return _this.expressionToSql(Exprs.val(false, true), context, e.precedenceLevel);\r\n                var arg = _this.expressionToSql(e.argument, context, e.precedenceLevel);\r\n                return arg + \" IN (\" + e.values.map(function (v) { return _this.expressionToSql(v, context); }).join(\", \") + \")\";\r\n            })\r\n                .register(Exprs.IsInQueryExpression, function (e, context) {\r\n                var arg = _this.expressionToSql(e.argument, context, e.precedenceLevel);\r\n                return arg + \" IN (\" + _this.transformToSql(e.query, context.context) + \")\";\r\n            })\r\n                .register(Exprs.LikeExpression, function (e, context) {\r\n                var arg = _this.expressionToSql(e.argument, context, e.precedenceLevel);\r\n                return arg + \" LIKE \" + _this.expressionToSql(e.like, context, e.precedenceLevel);\r\n            })\r\n                .register(Exprs.NotExpression, function (e, context) {\r\n                var arg = _this.expressionToSql(e.argument, context, e.precedenceLevel);\r\n                return \"NOT \" + arg;\r\n            })\r\n                .register(Exprs.IsNullExpression, function (e, context) {\r\n                var arg = _this.expressionToSql(e.argument, context, e.precedenceLevel);\r\n                return arg + \" IS NULL\";\r\n            })\r\n                .register(Exprs.IsNotNullExpression, function (e, context) {\r\n                var arg = _this.expressionToSql(e.argument, context, e.precedenceLevel);\r\n                return arg + \" IS NOT NULL\";\r\n            })\r\n                .register(Exprs.JsonPropertyAccess, function (e, context) {\r\n                var arg = _this.expressionToSql(e.expression, context, e.precedenceLevel);\r\n                return arg + \"->\" + _this.escapeValue(Exprs.val(e.key, true), context);\r\n            })\r\n                .register(Exprs.CastExpression, function (e, context) {\r\n                return _this.expressionToSql(e.expression, context, e.precedenceLevel);\r\n            });\r\n        }\r\n        return this.expressionDispatcher.dispatch(e, context);\r\n    };\r\n    return SqlGenerator;\r\n}());\r\nexports.SqlGenerator = SqlGenerator;\r\n//# sourceMappingURL=SqlGenerator.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/SqlGenerator.js\n// module id = 102\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/SqlGenerator.js?");

/***/ }),

/***/ 13:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FromFactor_1 = __webpack_require__(18);\r\nvar Types_1 = __webpack_require__(63);\r\nvar Expression = (function () {\r\n    function Expression(type) {\r\n        if (!type || !type.serialize)\r\n            throw new Error(\"No type given: \" + type + \".\");\r\n        this.type = type;\r\n    }\r\n    Object.defineProperty(Expression.prototype, \"precedenceLevel\", {\r\n        get: function () { return 0; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Expression.prototype.cast = function (type) { return new CastExpression(this, type); };\r\n    Expression.prototype.narrow = function () { return this; };\r\n    Expression.prototype.as = function (name) {\r\n        return new NamedExpressionWrapper(name, this);\r\n    };\r\n    Expression.prototype.isEqualTo = function (other) {\r\n        return new EqualsExpression(this, normalize(this.type, other));\r\n    };\r\n    Expression.prototype.isNotEqualTo = function (other) {\r\n        return new UnequalsExpression(this, normalize(this.type, other));\r\n    };\r\n    Expression.prototype.isLessThan = function (other) {\r\n        return new LessExpression(this, normalize(this.type, other));\r\n    };\r\n    Expression.prototype.isAtMost = function (other) {\r\n        return new LessOrEqualExpression(this, normalize(this.type, other));\r\n    };\r\n    Expression.prototype.isGreaterThan = function (other) {\r\n        return new GreaterExpression(this, normalize(this.type, other));\r\n    };\r\n    Expression.prototype.isAtLeast = function (other) {\r\n        return new GreaterOrEqualExpression(this, normalize(this.type, other));\r\n    };\r\n    Expression.prototype.isNull = function () { return new IsNullExpression(this); };\r\n    Expression.prototype.isNotNull = function () { return new IsNotNullExpression(this); };\r\n    Expression.prototype.and = function (other) {\r\n        return new AndExpression(this, other);\r\n    };\r\n    Expression.prototype.or = function (other) {\r\n        return new OrExpression(this, other);\r\n    };\r\n    Expression.prototype.not = function () { return new NotExpression(this); };\r\n    Expression.prototype.isIn = function (values) {\r\n        var _this = this;\r\n        return new IsInValuesExpression(this, values.map(function (v) { return normalize(_this.type, v); }));\r\n    };\r\n    Expression.prototype.isInQuery = function (values) { return new IsInQueryExpression(this, values); };\r\n    Expression.prototype.minus = function (other) {\r\n        return new SubtractionExpression(this, normalize(Types_1.tInteger, other));\r\n    };\r\n    Expression.prototype.plus = function (other) {\r\n        return new AdditionExpression(this, normalize(Types_1.tInteger, other));\r\n    };\r\n    Expression.prototype.mult = function (other) {\r\n        return new MultiplicationExpression(this, normalize(Types_1.tInteger, other));\r\n    };\r\n    Expression.prototype.div = function (other) {\r\n        return new DivisionExpression(this, normalize(Types_1.tInteger, other));\r\n    };\r\n    Expression.prototype.toUpper = function () { return new KnownFunctionInvocation(\"upper\", [this], Types_1.tText); };\r\n    Expression.prototype.toLower = function () { return new KnownFunctionInvocation(\"lower\", [this], Types_1.tText); };\r\n    Expression.prototype.sum = function () { return new KnownFunctionInvocation(\"sum\", [this], Types_1.tInteger); };\r\n    Expression.prototype.count = function () { return new KnownFunctionInvocation(\"count\", [this], Types_1.tInteger); };\r\n    Expression.prototype.isLike = function (other) { return new LikeExpression(this, normalize(this.type, other)); };\r\n    Expression.prototype.asc = function () { return { asc: this }; };\r\n    ;\r\n    Expression.prototype.desc = function () { return { desc: this }; };\r\n    ;\r\n    Expression.prototype.toJson = function () {\r\n        return new KnownFunctionInvocation(\"row_to_json\", [this], Types_1.tJson());\r\n    };\r\n    Expression.prototype.prop = function (key) {\r\n        return new JsonPropertyAccess(this, key);\r\n    };\r\n    return Expression;\r\n}());\r\nexports.Expression = Expression;\r\nvar CastExpression = (function (_super) {\r\n    __extends(CastExpression, _super);\r\n    function CastExpression(expression, newType) {\r\n        var _this = _super.call(this, newType) || this;\r\n        _this.expression = expression;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(CastExpression.prototype, \"precedenceLevel\", {\r\n        get: function () { return this.expression.precedenceLevel; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return CastExpression;\r\n}(Expression));\r\nexports.CastExpression = CastExpression;\r\nvar JsonPropertyAccess = (function (_super) {\r\n    __extends(JsonPropertyAccess, _super);\r\n    function JsonPropertyAccess(expression, key) {\r\n        var _this = _super.call(this, Types_1.tJson()) || this;\r\n        _this.expression = expression;\r\n        _this.key = key;\r\n        return _this;\r\n    }\r\n    return JsonPropertyAccess;\r\n}(Expression));\r\nexports.JsonPropertyAccess = JsonPropertyAccess;\r\nvar FromItemExpression = (function (_super) {\r\n    __extends(FromItemExpression, _super);\r\n    function FromItemExpression(fromItem) {\r\n        var _this = _super.call(this, Types_1.tRecord()) || this;\r\n        _this.fromItem = fromItem;\r\n        return _this;\r\n    }\r\n    return FromItemExpression;\r\n}(Expression));\r\nexports.FromItemExpression = FromItemExpression;\r\nfunction normalize(type, expr) {\r\n    if (expr instanceof Expression)\r\n        return expr;\r\n    return new ValueExpression(type, expr);\r\n}\r\nexports.normalize = normalize;\r\nfunction not(expression) {\r\n    return new NotExpression(expression);\r\n}\r\nexports.not = not;\r\nfunction and() {\r\n    var expressions = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        expressions[_i] = arguments[_i];\r\n    }\r\n    return expressions\r\n        .filter(function (expr) { return !!expr; })\r\n        .reduce(function (prev, cur) { return prev ? prev.and(cur) : cur; }, undefined);\r\n}\r\nexports.and = and;\r\nfunction concat() {\r\n    var expressions = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        expressions[_i] = arguments[_i];\r\n    }\r\n    return new KnownFunctionInvocation(\"concat\", expressions.map(function (e) { return normalize(Types_1.tText, e); }), Types_1.tText);\r\n}\r\nexports.concat = concat;\r\nfunction coalesce() {\r\n    var expressions = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        expressions[_i] = arguments[_i];\r\n    }\r\n    return new KnownFunctionInvocation(\"coalesce\", expressions, expressions[expressions.length - 1].type);\r\n}\r\nexports.coalesce = coalesce;\r\nfunction val(value) {\r\n    var other = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        other[_i - 1] = arguments[_i];\r\n    }\r\n    var preferEscaping;\r\n    if (other[0] instanceof Types_1.Type) {\r\n        preferEscaping = !!other[1];\r\n        return new ValueExpression(other[0], value, preferEscaping);\r\n    }\r\n    preferEscaping = !!other[0];\r\n    var t;\r\n    if (typeof value === \"string\")\r\n        t = Types_1.tText;\r\n    else if (typeof value === \"boolean\")\r\n        t = Types_1.tBoolean;\r\n    else if (typeof value === \"number\")\r\n        t = Types_1.tInteger;\r\n    else\r\n        throw new Error(\"Unsupported value: '\" + value + \"'.\");\r\n    return new ValueExpression(t, value, preferEscaping);\r\n}\r\nexports.val = val;\r\nfunction jsonVal(value) {\r\n    return val(value, Types_1.tJson());\r\n}\r\nexports.jsonVal = jsonVal;\r\nfunction defaultValue() { return new DefaultExpression(); }\r\nexports.defaultValue = defaultValue;\r\nfunction toCondition(fromItem, args) {\r\n    var firstArg = args[0];\r\n    if (firstArg && !(firstArg instanceof Expression)) {\r\n        if (typeof firstArg !== \"object\" || Array.isArray(firstArg))\r\n            throw new Error(\"Where argument must be an object, but was '\" + firstArg + \"'.\");\r\n        return and.apply(void 0, Object.keys(firstArg).map(function (columnName) {\r\n            var expression = firstArg[columnName];\r\n            if (!fromItem)\r\n                throw new Error(\"No table to select from specified.\");\r\n            var column = FromFactor_1.getColumn(fromItem, columnName);\r\n            return column.isEqualTo(expression);\r\n        }));\r\n    }\r\n    else {\r\n        return and.apply(void 0, args.map(function (arg, argIdx) {\r\n            if (!(arg instanceof Expression))\r\n                throw new Error(\"Argument at position '\" + argIdx + \"' is not of type expression.\");\r\n            return arg;\r\n        }));\r\n    }\r\n}\r\nexports.toCondition = toCondition;\r\nvar NamedExpression = (function (_super) {\r\n    __extends(NamedExpression, _super);\r\n    function NamedExpression(name, type) {\r\n        var _this = _super.call(this, type) || this;\r\n        _this.name = name;\r\n        return _this;\r\n    }\r\n    return NamedExpression;\r\n}(Expression));\r\nexports.NamedExpression = NamedExpression;\r\nvar Column = (function (_super) {\r\n    __extends(Column, _super);\r\n    function Column(name, type, fromItemSetterProvider) {\r\n        var _this = _super.call(this, name, type) || this;\r\n        fromItemSetterProvider(function (fromItem) { return _this._fromItem = fromItem; });\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Column.prototype, \"fromItem\", {\r\n        get: function () { return this._fromItem; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Column;\r\n}(NamedExpression));\r\nexports.Column = Column;\r\nvar TableColumn = (function (_super) {\r\n    __extends(TableColumn, _super);\r\n    function TableColumn(name, type, fromItemSetterProvider) {\r\n        return _super.call(this, name, type, fromItemSetterProvider) || this;\r\n    }\r\n    return TableColumn;\r\n}(Column));\r\nexports.TableColumn = TableColumn;\r\nvar AsColumn = (function (_super) {\r\n    __extends(AsColumn, _super);\r\n    function AsColumn(name, type, fromItemSetterProvider) {\r\n        return _super.call(this, name, type, fromItemSetterProvider) || this;\r\n    }\r\n    return AsColumn;\r\n}(Column));\r\nexports.AsColumn = AsColumn;\r\nvar ColumnBoundToExpression = (function (_super) {\r\n    __extends(ColumnBoundToExpression, _super);\r\n    function ColumnBoundToExpression(expression, fromItemSetterProvider) {\r\n        var _this = _super.call(this, expression.name, expression.type, fromItemSetterProvider) || this;\r\n        _this.expression = expression;\r\n        return _this;\r\n    }\r\n    return ColumnBoundToExpression;\r\n}(Column));\r\nexports.ColumnBoundToExpression = ColumnBoundToExpression;\r\nvar AllExpression = (function (_super) {\r\n    __extends(AllExpression, _super);\r\n    function AllExpression(fromItem) {\r\n        var _this = _super.call(this, Types_1.tVoid) || this;\r\n        _this.fromItem = fromItem;\r\n        return _this;\r\n    }\r\n    return AllExpression;\r\n}(Expression));\r\nexports.AllExpression = AllExpression;\r\nvar NamedExpressionWrapper = (function (_super) {\r\n    __extends(NamedExpressionWrapper, _super);\r\n    function NamedExpressionWrapper(name, expression) {\r\n        var _this = _super.call(this, name, expression.type) || this;\r\n        _this.expression = expression;\r\n        return _this;\r\n    }\r\n    return NamedExpressionWrapper;\r\n}(NamedExpression));\r\nexports.NamedExpressionWrapper = NamedExpressionWrapper;\r\nvar RetrievalQueryAsExpression = (function (_super) {\r\n    __extends(RetrievalQueryAsExpression, _super);\r\n    function RetrievalQueryAsExpression(query, type) {\r\n        var _this = _super.call(this, type) || this;\r\n        _this.query = query;\r\n        return _this;\r\n    }\r\n    return RetrievalQueryAsExpression;\r\n}(Expression));\r\nexports.RetrievalQueryAsExpression = RetrievalQueryAsExpression;\r\nvar ValueExpression = (function (_super) {\r\n    __extends(ValueExpression, _super);\r\n    function ValueExpression(type, value, preferEscaping) {\r\n        if (preferEscaping === void 0) { preferEscaping = false; }\r\n        var _this = _super.call(this, type) || this;\r\n        _this.value = value;\r\n        _this.preferEscaping = preferEscaping;\r\n        return _this;\r\n    }\r\n    return ValueExpression;\r\n}(Expression));\r\nexports.ValueExpression = ValueExpression;\r\nvar Variable = (function (_super) {\r\n    __extends(Variable, _super);\r\n    function Variable(name, type) {\r\n        var _this = _super.call(this, type) || this;\r\n        _this.name = name;\r\n        return _this;\r\n    }\r\n    return Variable;\r\n}(Expression));\r\nexports.Variable = Variable;\r\nvar BinaryOperatorExpression = (function (_super) {\r\n    __extends(BinaryOperatorExpression, _super);\r\n    function BinaryOperatorExpression(left, right, type) {\r\n        var _this = _super.call(this, type) || this;\r\n        _this.left = left;\r\n        _this.right = right;\r\n        return _this;\r\n    }\r\n    return BinaryOperatorExpression;\r\n}(Expression));\r\nexports.BinaryOperatorExpression = BinaryOperatorExpression;\r\nfunction ConcreteBinaryExpression(symbol, resultType, precedenceLevel) {\r\n    return (function (_super) {\r\n        __extends(class_1, _super);\r\n        function class_1(left, right) {\r\n            return _super.call(this, left, right, resultType) || this;\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"operator\", {\r\n            get: function () { return symbol; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(class_1.prototype, \"precedenceLevel\", {\r\n            get: function () { return precedenceLevel; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        return class_1;\r\n    }(BinaryOperatorExpression));\r\n}\r\nexports.ConcreteBinaryExpression = ConcreteBinaryExpression;\r\nvar AdditionExpression = (function (_super) {\r\n    __extends(AdditionExpression, _super);\r\n    function AdditionExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return AdditionExpression;\r\n}(ConcreteBinaryExpression(\"+\", Types_1.tInteger, 3)));\r\nexports.AdditionExpression = AdditionExpression;\r\nvar SubtractionExpression = (function (_super) {\r\n    __extends(SubtractionExpression, _super);\r\n    function SubtractionExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return SubtractionExpression;\r\n}(ConcreteBinaryExpression(\"-\", Types_1.tInteger, 3)));\r\nexports.SubtractionExpression = SubtractionExpression;\r\nvar MultiplicationExpression = (function (_super) {\r\n    __extends(MultiplicationExpression, _super);\r\n    function MultiplicationExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return MultiplicationExpression;\r\n}(ConcreteBinaryExpression(\"*\", Types_1.tInteger, 2)));\r\nexports.MultiplicationExpression = MultiplicationExpression;\r\nvar DivisionExpression = (function (_super) {\r\n    __extends(DivisionExpression, _super);\r\n    function DivisionExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return DivisionExpression;\r\n}(ConcreteBinaryExpression(\"/\", Types_1.tInteger, 2)));\r\nexports.DivisionExpression = DivisionExpression;\r\nvar ModulusExpression = (function (_super) {\r\n    __extends(ModulusExpression, _super);\r\n    function ModulusExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return ModulusExpression;\r\n}(ConcreteBinaryExpression(\"%\", Types_1.tInteger, 2)));\r\nexports.ModulusExpression = ModulusExpression;\r\nvar EqualsExpression = (function (_super) {\r\n    __extends(EqualsExpression, _super);\r\n    function EqualsExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return EqualsExpression;\r\n}(ConcreteBinaryExpression(\"=\", Types_1.tBoolean, 4)));\r\nexports.EqualsExpression = EqualsExpression;\r\nvar UnequalsExpression = (function (_super) {\r\n    __extends(UnequalsExpression, _super);\r\n    function UnequalsExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return UnequalsExpression;\r\n}(ConcreteBinaryExpression(\"!=\", Types_1.tBoolean, 4)));\r\nexports.UnequalsExpression = UnequalsExpression;\r\nvar GreaterExpression = (function (_super) {\r\n    __extends(GreaterExpression, _super);\r\n    function GreaterExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return GreaterExpression;\r\n}(ConcreteBinaryExpression(\">\", Types_1.tBoolean, 4)));\r\nexports.GreaterExpression = GreaterExpression;\r\nvar LessExpression = (function (_super) {\r\n    __extends(LessExpression, _super);\r\n    function LessExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return LessExpression;\r\n}(ConcreteBinaryExpression(\"<\", Types_1.tBoolean, 4)));\r\nexports.LessExpression = LessExpression;\r\nvar GreaterOrEqualExpression = (function (_super) {\r\n    __extends(GreaterOrEqualExpression, _super);\r\n    function GreaterOrEqualExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return GreaterOrEqualExpression;\r\n}(ConcreteBinaryExpression(\">=\", Types_1.tBoolean, 4)));\r\nexports.GreaterOrEqualExpression = GreaterOrEqualExpression;\r\nvar LessOrEqualExpression = (function (_super) {\r\n    __extends(LessOrEqualExpression, _super);\r\n    function LessOrEqualExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return LessOrEqualExpression;\r\n}(ConcreteBinaryExpression(\"<=\", Types_1.tBoolean, 4)));\r\nexports.LessOrEqualExpression = LessOrEqualExpression;\r\nvar NotLessExpression = (function (_super) {\r\n    __extends(NotLessExpression, _super);\r\n    function NotLessExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return NotLessExpression;\r\n}(ConcreteBinaryExpression(\"!<\", Types_1.tBoolean, 4)));\r\nexports.NotLessExpression = NotLessExpression;\r\nvar NotGreaterExpression = (function (_super) {\r\n    __extends(NotGreaterExpression, _super);\r\n    function NotGreaterExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return NotGreaterExpression;\r\n}(ConcreteBinaryExpression(\"!>\", Types_1.tBoolean, 4)));\r\nexports.NotGreaterExpression = NotGreaterExpression;\r\nvar OrExpression = (function (_super) {\r\n    __extends(OrExpression, _super);\r\n    function OrExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return OrExpression;\r\n}(ConcreteBinaryExpression(\"OR\", Types_1.tBoolean, 7)));\r\nexports.OrExpression = OrExpression;\r\nvar AndExpression = (function (_super) {\r\n    __extends(AndExpression, _super);\r\n    function AndExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return AndExpression;\r\n}(ConcreteBinaryExpression(\"AND\", Types_1.tBoolean, 6)));\r\nexports.AndExpression = AndExpression;\r\nvar LikeExpression = (function (_super) {\r\n    __extends(LikeExpression, _super);\r\n    function LikeExpression(argument, like) {\r\n        var _this = _super.call(this, Types_1.tBoolean) || this;\r\n        _this.argument = argument;\r\n        _this.like = like;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(LikeExpression.prototype, \"precedenceLevel\", {\r\n        get: function () { return 7; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return LikeExpression;\r\n}(Expression));\r\nexports.LikeExpression = LikeExpression;\r\nvar IsInValuesExpression = (function (_super) {\r\n    __extends(IsInValuesExpression, _super);\r\n    function IsInValuesExpression(argument, values) {\r\n        var _this = _super.call(this, Types_1.tBoolean) || this;\r\n        _this.argument = argument;\r\n        _this.values = values;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(IsInValuesExpression.prototype, \"precedenceLevel\", {\r\n        get: function () { return 7; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return IsInValuesExpression;\r\n}(Expression));\r\nexports.IsInValuesExpression = IsInValuesExpression;\r\nvar IsInQueryExpression = (function (_super) {\r\n    __extends(IsInQueryExpression, _super);\r\n    function IsInQueryExpression(argument, query) {\r\n        var _this = _super.call(this, Types_1.tBoolean) || this;\r\n        _this.argument = argument;\r\n        _this.query = query;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(IsInQueryExpression.prototype, \"precedenceLevel\", {\r\n        get: function () { return 7; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return IsInQueryExpression;\r\n}(Expression));\r\nexports.IsInQueryExpression = IsInQueryExpression;\r\nvar IsNullExpression = (function (_super) {\r\n    __extends(IsNullExpression, _super);\r\n    function IsNullExpression(argument) {\r\n        var _this = _super.call(this, Types_1.tBoolean) || this;\r\n        _this.argument = argument;\r\n        return _this;\r\n    }\r\n    return IsNullExpression;\r\n}(Expression));\r\nexports.IsNullExpression = IsNullExpression;\r\nvar IsNotNullExpression = (function (_super) {\r\n    __extends(IsNotNullExpression, _super);\r\n    function IsNotNullExpression(argument) {\r\n        var _this = _super.call(this, Types_1.tBoolean) || this;\r\n        _this.argument = argument;\r\n        return _this;\r\n    }\r\n    return IsNotNullExpression;\r\n}(Expression));\r\nexports.IsNotNullExpression = IsNotNullExpression;\r\nvar NotExpression = (function (_super) {\r\n    __extends(NotExpression, _super);\r\n    function NotExpression(argument) {\r\n        var _this = _super.call(this, argument.type) || this;\r\n        _this.argument = argument;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(NotExpression.prototype, \"precedenceLevel\", {\r\n        get: function () { return 5; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return NotExpression;\r\n}(Expression));\r\nexports.NotExpression = NotExpression;\r\nvar KnownFunctionInvocation = (function (_super) {\r\n    __extends(KnownFunctionInvocation, _super);\r\n    function KnownFunctionInvocation(functionName, args, resultType) {\r\n        var _this = _super.call(this, resultType) || this;\r\n        _this.functionName = functionName;\r\n        _this.args = args;\r\n        return _this;\r\n    }\r\n    return KnownFunctionInvocation;\r\n}(Expression));\r\nexports.KnownFunctionInvocation = KnownFunctionInvocation;\r\nvar DefaultExpression = (function (_super) {\r\n    __extends(DefaultExpression, _super);\r\n    function DefaultExpression() {\r\n        return _super.call(this, Types_1.tVoid) || this;\r\n    }\r\n    return DefaultExpression;\r\n}(Expression));\r\nexports.DefaultExpression = DefaultExpression;\r\n//# sourceMappingURL=Expressions.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Expressions.js\n// module id = 13\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Expressions.js?");

/***/ }),

/***/ 15:
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction toObject(item, keySelector, valueSelector) {\r\n    var o = {};\r\n    for (var _i = 0, item_1 = item; _i < item_1.length; _i++) {\r\n        var i = item_1[_i];\r\n        o[keySelector(i)] = valueSelector ? valueSelector(i) : i;\r\n    }\r\n    return o;\r\n}\r\nexports.toObject = toObject;\r\nfunction secondWithTypeOfFirst(t1, t2) {\r\n    return t2;\r\n}\r\nexports.secondWithTypeOfFirst = secondWithTypeOfFirst;\r\nfunction objectValues(obj) {\r\n    var result = [];\r\n    for (var _i = 0, _a = Object.getOwnPropertyNames(obj); _i < _a.length; _i++) {\r\n        var prop = _a[_i];\r\n        result.push(obj[prop]);\r\n    }\r\n    return result;\r\n}\r\nexports.objectValues = objectValues;\r\nfunction objectEntries(obj) {\r\n    var result = [];\r\n    for (var _i = 0, _a = Object.getOwnPropertyNames(obj); _i < _a.length; _i++) {\r\n        var prop = _a[_i];\r\n        result.push([prop, obj[prop]]);\r\n    }\r\n    return result;\r\n}\r\nexports.objectEntries = objectEntries;\r\nfunction combine(props, and) {\r\n    var result = {};\r\n    for (var _i = 0, _a = objectEntries(props); _i < _a.length; _i++) {\r\n        var _b = _a[_i], prop = _b[0], val = _b[1];\r\n        result[prop] = val;\r\n    }\r\n    for (var _c = 0, _d = objectEntries(and); _c < _d.length; _c++) {\r\n        var _e = _d[_c], prop = _e[0], val = _e[1];\r\n        result[prop] = val;\r\n    }\r\n    return result;\r\n}\r\nexports.combine = combine;\r\nvar DynamicDispatcher = (function () {\r\n    function DynamicDispatcher() {\r\n        this.registeredHandlers = new Map();\r\n    }\r\n    DynamicDispatcher.prototype.register = function (clazz, handler) {\r\n        this.registeredHandlers.set(clazz, handler);\r\n        return this;\r\n    };\r\n    DynamicDispatcher.prototype.dispatch = function (obj, args) {\r\n        var proto = Object.getPrototypeOf(obj);\r\n        while (proto) {\r\n            var handler = this.registeredHandlers.get(proto.constructor);\r\n            if (handler) {\r\n                return handler(obj, args);\r\n            }\r\n            proto = Object.getPrototypeOf(proto);\r\n        }\r\n        throw new Error(\"No handler was registered for '\" + obj + \"'.\");\r\n    };\r\n    return DynamicDispatcher;\r\n}());\r\nexports.DynamicDispatcher = DynamicDispatcher;\r\n//# sourceMappingURL=Helpers.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/Helpers.js\n// module id = 15\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/Helpers.js?");

/***/ }),

/***/ 164:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar React = __webpack_require__(89);\r\nvar ReactDOM = __webpack_require__(133);\r\nvar mobx_1 = __webpack_require__(126);\r\nvar mobx_react_1 = __webpack_require__(241);\r\n__webpack_require__(374);\r\nvar react_monaco_editor_1 = __webpack_require__(346);\r\nvar ts = __webpack_require__(376);\r\nvar sql = __webpack_require__(167);\r\nvar containers_1 = __webpack_require__(168);\r\nvar content = __webpack_require__(275);\r\nvar context = __webpack_require__(172);\r\nvar declarationFiles = {};\r\ncontext.keys().forEach(function (filename) {\r\n    declarationFiles[filename] = context(filename);\r\n});\r\nvar Model = (function () {\r\n    function Model() {\r\n    }\r\n    return Model;\r\n}());\r\n__decorate([\r\n    mobx_1.observable\r\n], Model.prototype, \"windowWidth\", void 0);\r\n__decorate([\r\n    mobx_1.observable\r\n], Model.prototype, \"windowHeight\", void 0);\r\nvar model = new Model();\r\nmodel.windowWidth = window.innerWidth;\r\nmodel.windowHeight = window.innerHeight;\r\nwindow.onresize = function () {\r\n    model.windowWidth = window.innerWidth;\r\n    model.windowHeight = window.innerHeight;\r\n};\r\nvar View = (function (_super) {\r\n    __extends(View, _super);\r\n    function View() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    View.prototype.componentDidMount = function () {\r\n        if (this.props.onHeightUpdate)\r\n            this.props.onHeightUpdate();\r\n    };\r\n    View.prototype.componentDidUpdate = function () {\r\n        if (this.props.onHeightUpdate)\r\n            this.props.onHeightUpdate();\r\n    };\r\n    View.prototype.render = function () {\r\n        var statement = this.props.sqlStatement;\r\n        if (containers_1.isError(statement)) {\r\n            return (React.createElement(\"div\", { className: \"sqlView\" },\r\n                React.createElement(\"span\", { className: \"error\" }, statement.value.error)));\r\n        }\r\n        return (React.createElement(\"div\", { className: \"sqlView\" },\r\n            React.createElement(\"span\", { className: \"sql\" }, statement.value.sql),\r\n            React.createElement(\"span\", { className: \"args\" }, JSON.stringify(statement.value.args))));\r\n    };\r\n    return View;\r\n}(React.Component));\r\nvar SqlViewerZone = (function () {\r\n    function SqlViewerZone(editor, lineNumber, sqlStatement) {\r\n        var _this = this;\r\n        this.editor = editor;\r\n        var d = document.createElement(\"div\");\r\n        var zone = {\r\n            afterLineNumber: lineNumber,\r\n            domNode: d,\r\n            heightInPx: SqlViewerZone.lastHeight,\r\n            suppressMouseDown: false\r\n        };\r\n        console.log(SqlViewerZone.lastHeight);\r\n        editor.changeViewZones(function (accessor) {\r\n            _this.zoneId = accessor.addZone(zone);\r\n        });\r\n        ReactDOM.render(React.createElement(View, { sqlStatement: sqlStatement, onHeightUpdate: function () {\r\n                setTimeout(function () {\r\n                    return;\r\n                    if (!d.childNodes[0] || d.childNodes[0].offsetHeight === 0)\r\n                        return;\r\n                    zone.heightInPx = d.childNodes[0].offsetHeight;\r\n                    SqlViewerZone.lastHeight = zone.heightInPx;\r\n                    editor.changeViewZones(function (accessor) {\r\n                        if (_this.zoneId === -1)\r\n                            throw \"\";\r\n                        accessor.layoutZone(_this.zoneId);\r\n                    });\r\n                }, 50);\r\n            } }), d);\r\n        d.style.zIndex = \"1\";\r\n    }\r\n    SqlViewerZone.prototype.destroy = function () {\r\n        var _this = this;\r\n        this.editor.changeViewZones(function (accessor) {\r\n            accessor.removeZone(_this.zoneId);\r\n        });\r\n    };\r\n    return SqlViewerZone;\r\n}());\r\nSqlViewerZone.lastHeight = 20;\r\nvar GUI = (function (_super) {\r\n    __extends(GUI, _super);\r\n    function GUI() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.zones = [];\r\n        _this.sqlGenerator = new sql.PostgreSqlGenerator({ shortenColumnNameIfUnambigous: true, skipQuotingIfNotRequired: true });\r\n        return _this;\r\n    }\r\n    GUI.prototype.editorDidMount = function (editor) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var m, _i, _a, fileName;\r\n            return __generator(this, function (_b) {\r\n                this.editor = editor;\r\n                editor.setModel(monaco.editor.createModel(content, \"typescript\", monaco.Uri.parse(\"file:///main.ts\")));\r\n                m = editor.getModel();\r\n                monaco.languages.typescript.typescriptDefaults.setCompilerOptions({ moduleResolution: 2 }); // ModuleResolutionKind.NodeJs\r\n                for (_i = 0, _a = Object.keys(declarationFiles); _i < _a.length; _i++) {\r\n                    fileName = _a[_i];\r\n                    monaco.languages.typescript.typescriptDefaults.addExtraLib(declarationFiles[fileName], \"file:///node_modules/hediet-typed-sql/\" + fileName);\r\n                }\r\n                mobx_1.autorun(function () {\r\n                    model.windowWidth + model.windowHeight;\r\n                    console.log(\"layout\");\r\n                    editor.layout();\r\n                });\r\n                this.onChange();\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    GUI.prototype.findSqlQueryExpressions = function (sf) {\r\n        function findSelectExpressions(node, result) {\r\n            for (var _i = 0, _a = node.getChildren(); _i < _a.length; _i++) {\r\n                var n = _a[_i];\r\n                if (n.kind === ts.SyntaxKind.CallExpression) {\r\n                    var n2 = n;\r\n                    var keywords = [\"select\", \"from\", \"values\", \"insertInto\", \"deleteFrom\", \"update\"];\r\n                    if (n2.expression && n2.expression.kind === ts.SyntaxKind.Identifier &&\r\n                        keywords.indexOf(n2.expression.text) !== -1) {\r\n                        var lastParent = n2;\r\n                        var parent = lastParent.parent;\r\n                        console.log(ts.SyntaxKind[parent.kind]);\r\n                        while (parent && ((parent.kind === ts.SyntaxKind.CallExpression && parent.expression === lastParent) ||\r\n                            (parent.kind === ts.SyntaxKind.PropertyAccessExpression) && parent.expression === lastParent)) {\r\n                            lastParent = parent;\r\n                            parent = lastParent.parent;\r\n                        }\r\n                        result.push(lastParent);\r\n                    }\r\n                }\r\n                findSelectExpressions(n, result);\r\n            }\r\n        }\r\n        var result = [];\r\n        findSelectExpressions(sf, result);\r\n        return result;\r\n    };\r\n    GUI.prototype.onChange = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            function define(args, func) {\r\n                func(undefined, {}, sql);\r\n            }\r\n            function log(id, query) {\r\n                try {\r\n                    var q = query();\r\n                    if (!(q instanceof sql.Query))\r\n                        return;\r\n                    var s = self.sqlGenerator.toSql(q);\r\n                    sqlStatements[id] = containers_1.result({ sql: s.sql, args: s.parameters });\r\n                }\r\n                catch (err) {\r\n                    sqlStatements[id] = containers_1.error({ error: err.toString() });\r\n                }\r\n            }\r\n            var m, editor, worker, svc, diags1, diags2, sf, i, exprs, lastStart, src, id, _i, exprs_1, expr, start, self, sqlStatements, scrollTop, _a, _b, zone, _c, exprs_2, expr, endPos, p;\r\n            return __generator(this, function (_d) {\r\n                switch (_d.label) {\r\n                    case 0:\r\n                        m = this.editor.getModel();\r\n                        editor = this.editor;\r\n                        return [4 /*yield*/, monaco.languages.typescript.getTypeScriptWorker()];\r\n                    case 1:\r\n                        worker = _d.sent();\r\n                        return [4 /*yield*/, worker(m.uri.toString())];\r\n                    case 2:\r\n                        svc = _d.sent();\r\n                        return [4 /*yield*/, svc.getSyntacticDiagnostics(m.uri.toString())];\r\n                    case 3:\r\n                        diags1 = _d.sent();\r\n                        return [4 /*yield*/, svc.getSemanticDiagnostics(m.uri.toString())];\r\n                    case 4:\r\n                        diags2 = _d.sent();\r\n                        console.log(svc);\r\n                        if (diags1.length + diags2.length > 0)\r\n                            return [2 /*return*/];\r\n                        sf = ts.createSourceFile(\"main.ts\", m.getValue(), ts.ScriptTarget.ESNext, true, ts.ScriptKind.TS);\r\n                        i = 0;\r\n                        exprs = this.findSqlQueryExpressions(sf);\r\n                        exprs.sort(function (a, b) { return b.end - a.end; }); // descending\r\n                        lastStart = sf.end;\r\n                        src = sf.getText();\r\n                        id = 0;\r\n                        for (_i = 0, exprs_1 = exprs; _i < exprs_1.length; _i++) {\r\n                            expr = exprs_1[_i];\r\n                            id++;\r\n                            start = expr.getStart(sf, false);\r\n                            if (start <= lastStart) {\r\n                                src = src.substring(0, start) + (\"log(\" + id + \", () => (\" + expr.getText(sf) + \"))\") + src.substr(expr.end);\r\n                            }\r\n                            lastStart = start;\r\n                        }\r\n                        src = ts.transpile(src, { module: ts.ModuleKind.AMD });\r\n                        self = this;\r\n                        sqlStatements = {};\r\n                        eval(src);\r\n                        scrollTop = editor.getScrollTop();\r\n                        for (_a = 0, _b = this.zones; _a < _b.length; _a++) {\r\n                            zone = _b[_a];\r\n                            zone.destroy();\r\n                        }\r\n                        this.zones = [];\r\n                        id = 0;\r\n                        for (_c = 0, exprs_2 = exprs; _c < exprs_2.length; _c++) {\r\n                            expr = exprs_2[_c];\r\n                            id++;\r\n                            endPos = expr.getEnd();\r\n                            p = m.getPositionAt(endPos);\r\n                            if (sqlStatements[id])\r\n                                this.zones.push(new SqlViewerZone(editor, p.lineNumber, sqlStatements[id]));\r\n                        }\r\n                        this.editor.setScrollTop(scrollTop);\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GUI.prototype.render = function () {\r\n        return (React.createElement(\"div\", { className: \"page\" },\r\n            React.createElement(\"div\", { className: \"header\" },\r\n                React.createElement(\"h1\", null, \"@hediet/typed-sql - Playground\")),\r\n            React.createElement(\"div\", { className: \"editor\" },\r\n                React.createElement(react_monaco_editor_1.default, { options: { scrollBeyondLastLine: false }, defaultValue: \"\", width: \"100%\", height: \"100%\", language: \"typescript\", editorDidMount: this.editorDidMount.bind(this), onChange: this.onChange.bind(this) }))));\r\n    };\r\n    return GUI;\r\n}(React.Component));\r\nGUI = __decorate([\r\n    mobx_react_1.observer\r\n], GUI);\r\nvar target = document.createElement(\"div\");\r\ntarget.className = \"container\";\r\nReactDOM.render(React.createElement(\"div\", { className: \"container\" },\r\n    React.createElement(GUI, null)), target); //<DevTools />\r\ndocument.body.appendChild(target);\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.tsx\n// module id = 164\n// module chunks = 1\n\n//# sourceURL=webpack:///./src/index.tsx?");

/***/ }),

/***/ 165:
/***/ (function(module, exports, __webpack_require__) {

eval("var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar PostgreSqlGenerator_1 = __webpack_require__(101);\r\nvar events_1 = __webpack_require__(170);\r\nvar synchronization_1 = __webpack_require__(171);\r\n/* TODO\r\nexport class PostgreQueryServiceFactory {\r\n    constructor(private readonly pgModule: typeof pg) {\r\n        \r\n    }\r\n\r\n    public createQueryService(connectionData: any) {\r\n\r\n    }\r\n}*/\r\nvar PostgreQueryService = (function () {\r\n    function PostgreQueryService(pool, sqlGeneratorOptions) {\r\n        if (sqlGeneratorOptions === void 0) { sqlGeneratorOptions = {}; }\r\n        this.pool = pool;\r\n        this.onSqlStatementEmitter = new events_1.EventEmitter();\r\n        this.onSqlStatement = this.onSqlStatementEmitter.asEvent();\r\n        this.PostgreExclusiveQueryService = (function () {\r\n            function PostgreExclusiveQueryService(client, queryService) {\r\n                this.client = client;\r\n                this.queryService = queryService;\r\n            }\r\n            PostgreExclusiveQueryService.prototype.exec = function (query) {\r\n                return __awaiter(this, void 0, void 0, function () {\r\n                    return __generator(this, function (_a) {\r\n                        return [2 /*return*/, this.queryService.execClient(query, this.client)];\r\n                    });\r\n                });\r\n            };\r\n            return PostgreExclusiveQueryService;\r\n        }());\r\n        this.sqlGenerator = new PostgreSqlGenerator_1.PostgreSqlGenerator(sqlGeneratorOptions);\r\n    }\r\n    PostgreQueryService.prototype.exec = function (query) {\r\n        return this.execClient(query);\r\n    };\r\n    PostgreQueryService.prototype.execClient = function (query, client) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a, queryText, parameters, resultRows, result, updatedRows;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.sqlGenerator.toSql(query), queryText = _a.sql, parameters = _a.parameters;\r\n                        resultRows = new synchronization_1.Deferred();\r\n                        this.onSqlStatementEmitter.emit(this, { sql: queryText, parameters: parameters, query: query, resultRows: resultRows.value });\r\n                        return [4 /*yield*/, (client ? client.query(queryText, parameters) : this.pool.query(queryText, parameters))];\r\n                    case 1:\r\n                        result = _b.sent();\r\n                        updatedRows = result.rows;\r\n                        /*\r\n                                if (query instanceof RetrievalQuery) {\r\n                                    const cols = query.getState().returningColumns;\r\n                                    updatedRows = updatedRows.map(row => {\r\n                                        const result = {} as any;\r\n                                        for (const prop of row) {\r\n                                            const val = row[prop];\r\n                                            const type = cols[prop] as AnyType;\r\n                                            result[prop] = type.deserialize(val);\r\n                                        }\r\n                                    });\r\n                                }\r\n                        */\r\n                        resultRows.setValue(updatedRows);\r\n                        return [2 /*return*/, updatedRows];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    PostgreQueryService.prototype.getExclusiveQueryService = function (scope) {\r\n        var _this = this;\r\n        return new Promise(function (res, rej) { return _this.pool.connect(function (err, client, done) {\r\n            if (err) {\r\n                rej(err);\r\n                return;\r\n            }\r\n            var service = new _this.PostgreExclusiveQueryService(client, _this);\r\n            scope(service)\r\n                .then(function (result) {\r\n                done();\r\n                res(result);\r\n            })\r\n                .catch(function (err) {\r\n                done();\r\n                rej(err);\r\n            });\r\n        }); });\r\n    };\r\n    return PostgreQueryService;\r\n}());\r\nexports.PostgreQueryService = PostgreQueryService;\r\n//# sourceMappingURL=Postgre.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/Adapters/Postgre.js\n// module id = 165\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/Adapters/Postgre.js?");

/***/ }),

/***/ 166:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar SqlStatement_1 = __webpack_require__(99);\r\nvar RetrievalQuery_1 = __webpack_require__(35);\r\nvar DbQueryInterface = (function () {\r\n    function DbQueryInterface(queryService) {\r\n        this.queryService = queryService;\r\n    }\r\n    DbQueryInterface.prototype.exec = function (statement) {\r\n        return this.queryService.exec(statement);\r\n    };\r\n    DbQueryInterface.prototype.values = function (query) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var rows;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.exec(query)];\r\n                    case 1:\r\n                        rows = _a.sent();\r\n                        return [2 /*return*/, rows.map(function (r) { return r[query.singleColumn]; })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DbQueryInterface.prototype.firstOrUndefined = function (query) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var rows;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (query instanceof RetrievalQuery_1.RetrievalQuery)\r\n                            query = query.limit(1);\r\n                        return [4 /*yield*/, this.exec(query)];\r\n                    case 1:\r\n                        rows = _a.sent();\r\n                        return [2 /*return*/, rows[0]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DbQueryInterface.prototype.first = function (query) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var result;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.firstOrUndefined(query)];\r\n                    case 1:\r\n                        result = _a.sent();\r\n                        if (!result)\r\n                            throw new Error(\"Expected at least one row.\");\r\n                        return [2 /*return*/, result];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DbQueryInterface.prototype.single = function (query) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var rows;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (query instanceof RetrievalQuery_1.RetrievalQuery)\r\n                            query = query.limit(2);\r\n                        return [4 /*yield*/, this.exec(query)];\r\n                    case 1:\r\n                        rows = _a.sent();\r\n                        if (rows.length === 0)\r\n                            throw new Error(\"No row found.\");\r\n                        if (rows.length >= 2)\r\n                            throw new Error(\"More than one row returned.\");\r\n                        return [2 /*return*/, rows[0]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DbQueryInterface.prototype.firstOrUndefinedValue = function (query) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var row;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.firstOrUndefined(query)];\r\n                    case 1:\r\n                        row = _a.sent();\r\n                        if (!row)\r\n                            return [2 /*return*/, undefined];\r\n                        return [2 /*return*/, row[query.singleColumn]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DbQueryInterface.prototype.firstValue = function (query) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var row;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.first(query)];\r\n                    case 1:\r\n                        row = _a.sent();\r\n                        return [2 /*return*/, row[query.singleColumn]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DbQueryInterface.prototype.singleValue = function (query) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var row;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.single(query)];\r\n                    case 1:\r\n                        row = _a.sent();\r\n                        return [2 /*return*/, row[query.singleColumn]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return DbQueryInterface;\r\n}());\r\nexports.DbQueryInterface = DbQueryInterface;\r\nvar TransactingQueryService = (function (_super) {\r\n    __extends(TransactingQueryService, _super);\r\n    function TransactingQueryService() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this._isTransactionOpen = true;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(TransactingQueryService.prototype, \"isTransactionOpen\", {\r\n        get: function () { return this._isTransactionOpen; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    TransactingQueryService.prototype.exec = function (statement) {\r\n        if (!this._isTransactionOpen)\r\n            throw new Error(\"Could not execute statement '\" + statement + \"': Transaction already has been either committed or rolled back.\");\r\n        return _super.prototype.exec.call(this, statement);\r\n    };\r\n    TransactingQueryService.prototype.rollback = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.exec(new SqlStatement_1.RollbackTransactionStatement())];\r\n                    case 1:\r\n                        _a.sent();\r\n                        this._isTransactionOpen = false;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TransactingQueryService.prototype.commit = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.exec(new SqlStatement_1.CommitTransactionStatement())];\r\n                    case 1:\r\n                        _a.sent();\r\n                        this._isTransactionOpen = false;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return TransactingQueryService;\r\n}(DbQueryInterface));\r\nexports.TransactingQueryService = TransactingQueryService;\r\nvar DbConnection = (function (_super) {\r\n    __extends(DbConnection, _super);\r\n    function DbConnection(queryService) {\r\n        var _this = _super.call(this, queryService) || this;\r\n        _this.queryService = queryService;\r\n        return _this;\r\n    }\r\n    DbConnection.prototype.transaction = function (scope) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, this.queryService.getExclusiveQueryService(function (s) { return __awaiter(_this, void 0, void 0, function () {\r\n                        var queryInterface, error, result, _a, err_1;\r\n                        return __generator(this, function (_b) {\r\n                            switch (_b.label) {\r\n                                case 0:\r\n                                    queryInterface = new TransactingQueryService(s);\r\n                                    return [4 /*yield*/, queryInterface.exec(new SqlStatement_1.StartTransactionStatement())];\r\n                                case 1:\r\n                                    _b.sent();\r\n                                    error = undefined;\r\n                                    _b.label = 2;\r\n                                case 2:\r\n                                    _b.trys.push([2, 4, , 5]);\r\n                                    _a = { success: true };\r\n                                    return [4 /*yield*/, scope(queryInterface)];\r\n                                case 3:\r\n                                    result = (_a.result = _b.sent(), _a);\r\n                                    return [3 /*break*/, 5];\r\n                                case 4:\r\n                                    err_1 = _b.sent();\r\n                                    result = { success: false, error: err_1 };\r\n                                    return [3 /*break*/, 5];\r\n                                case 5:\r\n                                    if (!result.success) return [3 /*break*/, 8];\r\n                                    if (!queryInterface.isTransactionOpen) return [3 /*break*/, 7];\r\n                                    return [4 /*yield*/, queryInterface.commit()];\r\n                                case 6:\r\n                                    _b.sent();\r\n                                    _b.label = 7;\r\n                                case 7: return [2 /*return*/, result.result];\r\n                                case 8:\r\n                                    if (!queryInterface.isTransactionOpen) return [3 /*break*/, 10];\r\n                                    return [4 /*yield*/, queryInterface.rollback()];\r\n                                case 9:\r\n                                    _b.sent();\r\n                                    _b.label = 10;\r\n                                case 10: throw result.error;\r\n                            }\r\n                        });\r\n                    }); })];\r\n            });\r\n        });\r\n    };\r\n    return DbConnection;\r\n}(DbQueryInterface));\r\nexports.DbConnection = DbConnection;\r\n//# sourceMappingURL=DbConnection.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/DbConnection.js\n// module id = 166\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/DbConnection.js?");

/***/ }),

/***/ 167:
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(13));\r\n__export(__webpack_require__(60));\r\n__export(__webpack_require__(100));\r\n__export(__webpack_require__(18));\r\n__export(__webpack_require__(63));\r\n__export(__webpack_require__(34));\r\n__export(__webpack_require__(35));\r\n__export(__webpack_require__(96));\r\n__export(__webpack_require__(98));\r\n__export(__webpack_require__(95));\r\n__export(__webpack_require__(97));\r\n__export(__webpack_require__(94));\r\n__export(__webpack_require__(166));\r\n__export(__webpack_require__(102));\r\n__export(__webpack_require__(165));\r\n__export(__webpack_require__(101));\r\n//# sourceMappingURL=index.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/index.js\n// module id = 167\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/index.js?");

/***/ }),

/***/ 168:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Wrapper {\r\n}\r\nexports.Wrapper = Wrapper;\r\nclass ResultWrapper extends Wrapper {\r\n    constructor(value) {\r\n        super();\r\n        this.value = value;\r\n    }\r\n}\r\nexports.ResultWrapper = ResultWrapper;\r\nclass ErrorWrapper extends Wrapper {\r\n    constructor(value) {\r\n        super();\r\n        this.value = value;\r\n    }\r\n}\r\nexports.ErrorWrapper = ErrorWrapper;\r\nfunction isResult(maybe) {\r\n    return maybe instanceof ResultWrapper;\r\n}\r\nexports.isResult = isResult;\r\nfunction isError(maybe) {\r\n    return maybe instanceof ErrorWrapper;\r\n}\r\nexports.isError = isError;\r\nfunction result(value) {\r\n    return new ResultWrapper(value);\r\n}\r\nexports.result = result;\r\nfunction error(value) {\r\n    return new ErrorWrapper(value);\r\n}\r\nexports.error = error;\r\n//# sourceMappingURL=containers.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/hediet-framework/api/containers.js\n// module id = 168\n// module chunks = 1\n\n//# sourceURL=webpack:///../~/hediet-framework/api/containers.js?");

/***/ }),

/***/ 169:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction createDisposable(disposable) {\r\n    if (!disposable)\r\n        return { dispose: () => undefined };\r\n    if (disposable instanceof Function)\r\n        return { dispose: disposable };\r\n    if (\"dispose\" in disposable)\r\n        return disposable;\r\n    else\r\n        return { dispose: () => dispose(disposable) };\r\n}\r\nexports.createDisposable = createDisposable;\r\nfunction limitLifeTime(callback) {\r\n    const mortals = [];\r\n    try {\r\n        const result = callback(mortals);\r\n        return result;\r\n    }\r\n    finally {\r\n        dispose(mortals);\r\n    }\r\n}\r\nexports.limitLifeTime = limitLifeTime;\r\nfunction dispose(disposable) {\r\n    if (!disposable)\r\n        return;\r\n    if (Array.isArray(disposable)) {\r\n        for (var d of disposable)\r\n            d.dispose();\r\n    }\r\n    else {\r\n        disposable.dispose();\r\n    }\r\n}\r\nexports.dispose = dispose;\r\nexports.emptyDisposable = { dispose: () => { } };\r\nclass Disposable {\r\n    constructor() {\r\n        this.disposables = [];\r\n    }\r\n    addDisposable(disposable) {\r\n        this.disposables.push(disposable);\r\n    }\r\n    dispose() {\r\n        dispose(this.disposables);\r\n    }\r\n}\r\nexports.Disposable = Disposable;\r\n//# sourceMappingURL=disposable.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/hediet-framework/api/disposable.js\n// module id = 169\n// module chunks = 1\n\n//# sourceURL=webpack:///../~/hediet-framework/api/disposable.js?");

/***/ }),

/***/ 170:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst disposable_1 = __webpack_require__(169);\r\nfunction waitOne(event) {\r\n    return new Promise(resolve => event.one(resolve));\r\n}\r\nexports.waitOne = waitOne;\r\n/**\r\n * Base class for implementation of the emitter. It facilitates the subscribe\r\n * and unsubscribe methods based on generic handlers. The TEventType specifies\r\n * the type of event that should be exposed. Use the asEvent to expose the\r\n * emitter as event.\r\n */\r\n/**\r\n * Stores a handler. Manages execution meta data.\r\n * @class Subscription\r\n * @template TEventHandler\r\n */\r\nclass Subscription {\r\n    /**\r\n     * Creates an instance of Subscription.\r\n     *\r\n     * @param {TEventHandler} handler The handler for the subscription.\r\n     * @param {boolean} isOnce Indicates if the handler should only be executed` once.\r\n     */\r\n    constructor(handler, isOnce) {\r\n        this.handler = handler;\r\n        this.isOnce = isOnce;\r\n    }\r\n    /**\r\n     * Executes the handler.\r\n     *\r\n     * @param {boolean} executeAsync True if the even should be executed async.\r\n     * @param {*} The scope the scope of the event.\r\n     * @param {IArguments} args The arguments for the event.\r\n     */\r\n    execute(scope, args) {\r\n        var fn = this.handler;\r\n        fn.apply(scope, args);\r\n    }\r\n}\r\nexports.Subscription = Subscription;\r\nclass EmitterBase {\r\n    constructor() {\r\n        this.wrap = new EmitterWrapper(this);\r\n        this.subscriptions = new Set();\r\n    }\r\n    /**\r\n     * Subscribe to the event emitter.\r\n     * @param fn The event handler that is called when the event is emitted.\r\n     */\r\n    sub(fn) {\r\n        const sub = new Subscription(fn, false);\r\n        this.subscriptions.add(sub);\r\n        return disposable_1.createDisposable(() => this.subscriptions.delete(sub));\r\n    }\r\n    /**\r\n     * Subscribe once to the event with the specified name.\r\n     * @param fn The event handler that is called when the event is emitted.\r\n     */\r\n    one(fn) {\r\n        const sub = new Subscription(fn, true);\r\n        this.subscriptions.add(sub);\r\n        return disposable_1.createDisposable(() => this.subscriptions.delete(sub));\r\n    }\r\n    /**\r\n     * Generic emitter will emit the handlers with the given arguments.\r\n     *\r\n     * @protected\r\n     * @param {*} The scope the scope of the event.\r\n     * @param {IArguments} args The arguments for the event.\r\n     */\r\n    _emit(scope, args) {\r\n        for (const sub of this.subscriptions.values()) {\r\n            if (sub.isOnce)\r\n                this.subscriptions.delete(sub);\r\n            sub.execute(scope, args);\r\n        }\r\n    }\r\n    /**\r\n     * Creates an event from the dispatcher. Will return the dispatcher\r\n     * in a wrapper. This will prevent exposure of any dispatcher methods.\r\n     */\r\n    asEvent() { return this.wrap; }\r\n}\r\nexports.EmitterBase = EmitterBase;\r\n/**\r\n * Dispatcher implementation for events. Can be used to subscribe, unsubscribe\r\n * or dispatch events. Use the ToEvent() method to expose the event.\r\n */\r\nclass EventEmitter extends EmitterBase {\r\n    /**\r\n     * Emits the event.\r\n     * @param sender The sender.\r\n     * @param args The arguments object.\r\n     */\r\n    emit(sender, args) { this._emit(this, arguments); }\r\n}\r\nexports.EventEmitter = EventEmitter;\r\n/**\r\n * The dispatcher handles the storage of subsciptions and facilitates\r\n * subscription, unsubscription and dispatching of a simple event\r\n */\r\nclass SimpleEventEmitter extends EmitterBase {\r\n    /**\r\n     * Emits the event.\r\n     * @param args The arguments object.\r\n     */\r\n    emit(args) { this._emit(this, arguments); }\r\n}\r\nexports.SimpleEventEmitter = SimpleEventEmitter;\r\n/**\r\n * The dispatcher handles the storage of subsciptions and facilitates\r\n * subscription, unsubscription and dispatching of a signal event.\r\n */\r\nclass SignalEmitter extends EmitterBase {\r\n    /**\r\n     * Emits the signal.\r\n     */\r\n    emit() { this._emit(this, arguments); }\r\n}\r\nexports.SignalEmitter = SignalEmitter;\r\n/**\r\n * Hides the implementation of the event dispatcher. Will expose methods that\r\n * are relevent to the event.\r\n */\r\nclass EmitterWrapper {\r\n    /**\r\n     * Creates a new EventDispatcherWrapper instance.\r\n     * @param dispatcher The dispatcher.\r\n     */\r\n    constructor(emitter) { this.__emitter = emitter; }\r\n    /**\r\n     * Subscribe to the event dispatcher.\r\n     * @param fn The event handler that is called when the event is dispatched.\r\n     */\r\n    sub(fn) { return this.__emitter.sub(fn); }\r\n    /**\r\n     * Subscribe once to the event with the specified name.\r\n     * @param fn The event handler that is called when the event is dispatched.\r\n     */\r\n    one(fn) { return this.__emitter.one(fn); }\r\n}\r\nexports.EmitterWrapper = EmitterWrapper;\r\n//# sourceMappingURL=events.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/hediet-framework/api/events.js\n// module id = 170\n// module chunks = 1\n\n//# sourceURL=webpack:///../~/hediet-framework/api/events.js?");

/***/ }),

/***/ 171:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Barrier {\r\n    constructor() {\r\n        this.onUnlocked = new Promise((resolve, reject) => { this.unlock = resolve; this.reject = reject; });\r\n    }\r\n}\r\nexports.Barrier = Barrier;\r\nclass Deferred {\r\n    constructor() {\r\n        this.value = new Promise((resolve, reject) => { this.setValue = resolve; this.reject = reject; });\r\n    }\r\n}\r\nexports.Deferred = Deferred;\r\nclass ProducerConsumer {\r\n    constructor() {\r\n        this.barriers = [];\r\n        this.nextBarriers = [];\r\n    }\r\n    popOrNext() {\r\n        let b = this.barriers.shift();\r\n        if (!b) {\r\n            b = new Deferred();\r\n            this.nextBarriers.push(b);\r\n        }\r\n        return b;\r\n    }\r\n    produce(value) { this.popOrNext().setValue(value); }\r\n    rejectSingle(reason) { this.popOrNext().reject(reason); }\r\n    consume() {\r\n        let b = this.nextBarriers.shift();\r\n        if (!b) {\r\n            b = new Deferred();\r\n            this.barriers.push(b);\r\n        }\r\n        return b.value;\r\n    }\r\n}\r\nexports.ProducerConsumer = ProducerConsumer;\r\n//# sourceMappingURL=synchronization.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/hediet-framework/api/synchronization.js\n// module id = 171\n// module chunks = 1\n\n//# sourceURL=webpack:///../~/hediet-framework/api/synchronization.js?");

/***/ }),

/***/ 172:
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./AST/Expressions.ts\": 252,\n\t\"./AST/FromFactor.ts\": 253,\n\t\"./AST/Ordering.ts\": 254,\n\t\"./AST/Queries/Common.ts\": 255,\n\t\"./AST/Queries/DeleteQuery.ts\": 256,\n\t\"./AST/Queries/InsertQuery.ts\": 257,\n\t\"./AST/Queries/JoinMixin.ts\": 258,\n\t\"./AST/Queries/Query.ts\": 259,\n\t\"./AST/Queries/RetrievalQuery.ts\": 260,\n\t\"./AST/Queries/SelectQuery.ts\": 261,\n\t\"./AST/Queries/UpdateQuery.ts\": 262,\n\t\"./AST/Queries/ValuesQuery.ts\": 263,\n\t\"./AST/Queries/WhereMixin.ts\": 264,\n\t\"./AST/SqlStatement.ts\": 265,\n\t\"./AST/Table.ts\": 266,\n\t\"./AST/Types.ts\": 267,\n\t\"./Adapters/Postgre.ts\": 268,\n\t\"./Adapters/PostgreSqlGenerator.ts\": 269,\n\t\"./DbConnection.ts\": 270,\n\t\"./Helpers.ts\": 271,\n\t\"./SqlGenerator.ts\": 272,\n\t\"./index.ts\": 273,\n\t\"./main.d.ts\": 274\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 172;\n\n//////////////////\n// WEBPACK FOOTER\n// ../src ./~/raw-loader! \\.(ts)$\n// module id = 172\n// module chunks = 1\n\n//# sourceURL=webpack:///_\\.(ts)$?../src_./~/raw-loader");

/***/ }),

/***/ 18:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Expressions_1 = __webpack_require__(13);\r\nvar Helpers_1 = __webpack_require__(15);\r\nvar FromFactor = (function () {\r\n    function FromFactor() {\r\n    }\r\n    FromFactor.getAllFromFactors = function (factor) {\r\n        if (factor instanceof FromItem)\r\n            return [factor];\r\n        else if (factor instanceof FromFactorAbstractJoin) {\r\n            return FromFactor.getAllFromFactors(factor.leftArg).concat(FromFactor.getAllFromFactors(factor.rightArg));\r\n        }\r\n        throw new Error(\"Unsupported from factor\");\r\n    };\r\n    FromFactor.crossJoin = function (factor1, factor2) {\r\n        if (!factor1)\r\n            return factor2;\r\n        if (!factor2)\r\n            return factor1;\r\n        return new FromFactorCrossJoin(factor1, factor2);\r\n    };\r\n    return FromFactor;\r\n}());\r\nexports.FromFactor = FromFactor;\r\nvar FromFactorAbstractJoin = (function (_super) {\r\n    __extends(FromFactorAbstractJoin, _super);\r\n    function FromFactorAbstractJoin(leftArg, rightArg) {\r\n        var _this = _super.call(this) || this;\r\n        _this.leftArg = leftArg;\r\n        _this.rightArg = rightArg;\r\n        return _this;\r\n    }\r\n    return FromFactorAbstractJoin;\r\n}(FromFactor));\r\nexports.FromFactorAbstractJoin = FromFactorAbstractJoin;\r\nvar FromFactorAbstractConditionalJoin = (function (_super) {\r\n    __extends(FromFactorAbstractConditionalJoin, _super);\r\n    function FromFactorAbstractConditionalJoin(leftArg, rightArg, joinCondition) {\r\n        var _this = _super.call(this, leftArg, rightArg) || this;\r\n        _this.joinCondition = joinCondition;\r\n        return _this;\r\n    }\r\n    return FromFactorAbstractConditionalJoin;\r\n}(FromFactorAbstractJoin));\r\nexports.FromFactorAbstractConditionalJoin = FromFactorAbstractConditionalJoin;\r\nvar FromFactorLeftJoin = (function (_super) {\r\n    __extends(FromFactorLeftJoin, _super);\r\n    function FromFactorLeftJoin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    FromFactorLeftJoin.prototype.getType = function () { return \"left\"; };\r\n    return FromFactorLeftJoin;\r\n}(FromFactorAbstractConditionalJoin));\r\nexports.FromFactorLeftJoin = FromFactorLeftJoin;\r\n;\r\nvar FromFactorFullJoin = (function (_super) {\r\n    __extends(FromFactorFullJoin, _super);\r\n    function FromFactorFullJoin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    FromFactorFullJoin.prototype.getType = function () { return \"full\"; };\r\n    return FromFactorFullJoin;\r\n}(FromFactorAbstractConditionalJoin));\r\nexports.FromFactorFullJoin = FromFactorFullJoin;\r\n;\r\nvar FromFactorInnerJoin = (function (_super) {\r\n    __extends(FromFactorInnerJoin, _super);\r\n    function FromFactorInnerJoin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    FromFactorInnerJoin.prototype.getType = function () { return \"inner\"; };\r\n    return FromFactorInnerJoin;\r\n}(FromFactorAbstractConditionalJoin));\r\nexports.FromFactorInnerJoin = FromFactorInnerJoin;\r\n;\r\nvar FromFactorCrossJoin = (function (_super) {\r\n    __extends(FromFactorCrossJoin, _super);\r\n    function FromFactorCrossJoin() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    FromFactorCrossJoin.prototype.getType = function () { return \"cross\"; };\r\n    return FromFactorCrossJoin;\r\n}(FromFactorAbstractJoin));\r\nexports.FromFactorCrossJoin = FromFactorCrossJoin;\r\n;\r\nvar FromItem = (function (_super) {\r\n    __extends(FromItem, _super);\r\n    function FromItem(columns, castToColumns) {\r\n        var _this = _super.call(this) || this;\r\n        _this.castToColumns = castToColumns;\r\n        _this.$all = new Expressions_1.AllExpression(_this);\r\n        _this.$columns = columns;\r\n        for (var _i = 0, _a = Helpers_1.objectEntries(columns); _i < _a.length; _i++) {\r\n            var _b = _a[_i], name_1 = _b[0], col = _b[1];\r\n            if (!(name_1 in _this))\r\n                _this[name_1] = col;\r\n        }\r\n        return _this;\r\n    }\r\n    FromItem.prototype.as = function (name) {\r\n        var setters = [];\r\n        var columns = Helpers_1.objectValues(this.$columns)\r\n            .map(function (col) { return new Expressions_1.ColumnBoundToExpression(col, function (s) { return setters.push(s); }); });\r\n        var result = new NamedFromItem(name, Helpers_1.toObject(columns, function (c) { return c.name; }), this, false);\r\n        for (var _i = 0, setters_1 = setters; _i < setters_1.length; _i++) {\r\n            var s = setters_1[_i];\r\n            s(result);\r\n        }\r\n        return result;\r\n    };\r\n    FromItem.prototype.asNullable = function () {\r\n        return this;\r\n    };\r\n    FromItem.prototype.asExpression = function () {\r\n        return new Expressions_1.FromItemExpression(this);\r\n    };\r\n    return FromItem;\r\n}(FromFactor));\r\nexports.FromItem = FromItem;\r\nfunction isCastToColumns(fromItem) {\r\n    return fromItem[\"castToColumns\"];\r\n}\r\nexports.isCastToColumns = isCastToColumns;\r\nfunction getColumn(fromItem, column) {\r\n    var result = fromItem.$columns[column];\r\n    if (!result)\r\n        throw new Error(\"Column '\" + column + \"' does not exist on table '\" + fromItem + \"'.\");\r\n    return result;\r\n}\r\nexports.getColumn = getColumn;\r\nvar NamedFromItem = (function (_super) {\r\n    __extends(NamedFromItem, _super);\r\n    function NamedFromItem($name, columns, fromItem, castToColumns) {\r\n        var _this = _super.call(this, columns, castToColumns) || this;\r\n        _this.$name = $name;\r\n        _this.fromItem = fromItem;\r\n        return _this;\r\n    }\r\n    return NamedFromItem;\r\n}(FromItem));\r\nexports.NamedFromItem = NamedFromItem;\r\nvar QueryFromItem = (function (_super) {\r\n    __extends(QueryFromItem, _super);\r\n    function QueryFromItem($name, columns, query, castToColumns) {\r\n        var _this = _super.call(this, columns, castToColumns) || this;\r\n        _this.$name = $name;\r\n        _this.query = query;\r\n        return _this;\r\n    }\r\n    return QueryFromItem;\r\n}(FromItem));\r\nexports.QueryFromItem = QueryFromItem;\r\n/* TODO, for recursion\r\nexport class BindableFromItem<TColumns extends ImplicitColumns> extends FromItem<TColumns> {\r\n    public bind(fromItem: FromItem<TColumns>): void;\r\n    public bindAndOverrideColumnNames(view: FromItem<any>): void;\r\n}\r\n\r\ntype BindableViewCtor<TColumns extends ImplicitColumns> = BindableFromItem<TColumns> & ImplicitColumnsToColumns<TColumns>;\r\n\r\nexport function view<TColumnsWithTypes extends { [columnName: string]: Columns.ColumnDescription<any> }>(\r\n        tableName: string, columns: TColumnsWithTypes):\r\n    BindableViewCtor<ColumnsWithTypesToImplicit<TColumnsWithTypes>> {\r\n    \r\n    return null!;\r\n}\r\n*/ \r\n//# sourceMappingURL=FromFactor.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/FromFactor.js\n// module id = 18\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/FromFactor.js?");

/***/ }),

/***/ 195:
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(196)();\n// imports\n\n\n// module\nexports.push([module.i, \"html {\\n  height: 100%;\\n  margin: 0; }\\n\\nbody {\\n  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\\n  height: 100%;\\n  margin: 0px;\\n  padding: 10px;\\n  padding-bottom: 25px;\\n  box-sizing: border-box; }\\n\\n.container {\\n  height: 100%;\\n  margin: 0px;\\n  padding: 0px; }\\n\\n.page {\\n  display: flex;\\n  flex-direction: column;\\n  width: 100%;\\n  height: 100%; }\\n\\n.header {\\n  flex-shrink: 1; }\\n\\n.editor {\\n  flex: 1;\\n  overflow: hidden;\\n  padding: 0;\\n  border: 1px solid black; }\\n\\n.sqlView .sql {\\n  font-family: Consolas; }\\n\\n.sqlView .args {\\n  font-family: Consolas;\\n  margin-left: 30px; }\\n\\n.sqlView {\\n  border: black solid 1px;\\n  padding-left: 5px;\\n  background-color: #f2f2f2;\\n  font-size: 14px; }\\n\", \"\"]);\n\n// exports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/sass-loader/lib/loader.js!./src/style.scss\n// module id = 195\n// module chunks = 1\n\n//# sourceURL=webpack:///./src/style.scss?./~/css-loader!./~/sass-loader/lib/loader.js");

/***/ }),

/***/ 252:
/***/ (function(module, exports) {

eval("module.exports = \"import { Ordering } from \\\"./Ordering\\\";\\r\\nimport { FromItem, Row, getColumn } from \\\"./FromFactor\\\";\\r\\nimport { RetrievalQuery } from \\\"./Queries/RetrievalQuery\\\";\\r\\nimport { Table } from \\\"./Table\\\";\\r\\nimport {\\r\\n\\tAnyType,\\r\\n\\tBooleanType,\\r\\n\\tGetInType,\\r\\n\\tIntegerType,\\r\\n\\tJson,\\r\\n\\tRecord,\\r\\n\\tRecordTypeToJson,\\r\\n\\ttBoolean,\\r\\n\\tTextType,\\r\\n\\ttInteger,\\r\\n\\ttJson,\\r\\n\\ttText,\\r\\n\\ttVoid,\\r\\n\\tVoidType,\\r\\n\\tType,\\r\\n\\ttRecord\\r\\n} from './Types';\\r\\n\\r\\nexport type ExpressionTypeOf<T extends Expression<any>> = T[\\\"type\\\"];\\r\\n\\r\\nexport abstract class Expression<T extends AnyType> {\\r\\n\\tpublic readonly type: T;\\r\\n\\r\\n\\tconstructor(type: T) {\\r\\n\\t\\tif (!type || !type.serialize) throw new Error(`No type given: ${type}.`);\\r\\n\\t\\tthis.type = type;\\r\\n\\t}\\r\\n\\r\\n\\tpublic get precedenceLevel(): number { return 0; }\\r\\n\\r\\n\\tpublic cast<T2 extends AnyType>(type: T2): Expression<T2> { return new CastExpression(this, type); }\\r\\n\\tpublic narrow<T2 extends T>(): Expression<T2> { return this as any; }\\r\\n\\r\\n\\tpublic as<TName extends string>(name: TName): NamedExpression<TName, T> {\\r\\n\\t\\treturn new NamedExpressionWrapper<TName, T>(name, this); }\\r\\n\\r\\n\\tpublic isEqualTo(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new EqualsExpression(this, normalize(this.type, other)); }\\r\\n\\tpublic isNotEqualTo(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new UnequalsExpression(this, normalize(this.type, other)); }\\r\\n\\r\\n\\tpublic isLessThan(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new LessExpression(this, normalize(this.type, other)); }\\r\\n\\tpublic isAtMost(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new LessOrEqualExpression(this, normalize(this.type, other)); }\\r\\n\\tpublic isGreaterThan(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new GreaterExpression(this, normalize(this.type, other)); }\\r\\n\\tpublic isAtLeast(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new GreaterOrEqualExpression(this, normalize(this.type, other)); }\\r\\n\\r\\n\\tpublic isNull(): Expression<BooleanType> { return new IsNullExpression(this); }\\r\\n\\tpublic isNotNull(): Expression<BooleanType> { return new IsNotNullExpression(this); }\\r\\n\\r\\n\\tpublic and(this: Expression<BooleanType>, other: Expression<BooleanType>): Expression<BooleanType> {\\r\\n\\t\\treturn new AndExpression(this, other); }\\r\\n\\tpublic or(this: Expression<BooleanType>, other: Expression<BooleanType>): Expression<BooleanType> {\\r\\n\\t\\treturn new OrExpression(this, other); }\\r\\n\\r\\n\\tpublic not(this: Expression<BooleanType>): Expression<BooleanType> { return new NotExpression(this); }\\r\\n\\r\\n\\tpublic isIn(values: ExpressionOrInputValue<T>[]): Expression<BooleanType> { return new IsInValuesExpression(this, values.map(v => normalize(this.type, v))); }\\r\\n\\tpublic isInQuery<TRow extends { [name: string]: AnyType }, TSingleColumn extends keyof TRow>(this: Expression<TRow[TSingleColumn]>,\\r\\n\\t\\tvalues: RetrievalQuery<TRow, TSingleColumn>): Expression<BooleanType> { return new IsInQueryExpression(this, values); }\\r\\n\\t\\r\\n\\tpublic minus(this: Expression<IntegerType>, other: ExpressionOrInputValue<IntegerType>): Expression<IntegerType> {\\r\\n\\t\\treturn new SubtractionExpression(this, normalize(tInteger, other)); }\\r\\n\\tpublic plus(this: Expression<IntegerType>, other: ExpressionOrInputValue<IntegerType>): Expression<IntegerType> {\\r\\n\\t\\treturn new AdditionExpression(this, normalize(tInteger, other)); }\\r\\n\\tpublic mult(this: Expression<IntegerType>, other: ExpressionOrInputValue<IntegerType>): Expression<IntegerType> {\\r\\n\\t\\treturn new MultiplicationExpression(this, normalize(tInteger, other)); }\\r\\n\\tpublic div(this: Expression<IntegerType>, other: ExpressionOrInputValue<IntegerType>): Expression<IntegerType> {\\r\\n\\t\\treturn new DivisionExpression(this, normalize(tInteger, other)); }\\r\\n\\r\\n\\tpublic toUpper(this: Expression<TextType>): Expression<TextType> { return new KnownFunctionInvocation(\\\"upper\\\", [this], tText); }\\r\\n\\tpublic toLower(this: Expression<TextType>): Expression<TextType> { return new KnownFunctionInvocation(\\\"lower\\\", [this], tText); }\\r\\n\\r\\n\\tpublic sum(this: Expression<IntegerType>): Expression<IntegerType> { return new KnownFunctionInvocation(\\\"sum\\\", [this], tInteger); }\\r\\n\\tpublic count(this: Expression<any>): Expression<IntegerType> { return new KnownFunctionInvocation(\\\"count\\\", [this], tInteger); }\\r\\n\\r\\n\\tpublic isLike(this: Expression<TextType>, other: ExpressionOrInputValue<TextType>): Expression<BooleanType> { return new LikeExpression(this, normalize(this.type, other)); }\\r\\n\\r\\n\\tpublic asc(): Ordering<Expression<T>> { return { asc: this } };\\r\\n\\tpublic desc(): Ordering<Expression<T>> { return { desc: this } };\\r\\n\\r\\n\\tpublic toJson<TColumns>(this: Expression<Record<TColumns>>): Expression<Json<RecordTypeToJson<Record<TColumns>>>> {\\r\\n\\t\\treturn new KnownFunctionInvocation(\\\"row_to_json\\\", [this], tJson<RecordTypeToJson<Record<TColumns>>>());\\r\\n\\t}\\r\\n\\r\\n\\tpublic prop<TKey extends keyof GetInType<ExpressionTypeOf<this>>>(this: Expression<Json<any>>, key: TKey): Expression<Json<GetInType<ExpressionTypeOf<this>>[TKey]>> {\\r\\n\\t\\treturn new JsonPropertyAccess(this, key);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class CastExpression<T extends AnyType> extends Expression<T> {\\r\\n\\tget precedenceLevel() { return this.expression.precedenceLevel; }\\r\\n\\r\\n\\tconstructor(public readonly expression: Expression<AnyType>, newType: T) {\\r\\n\\t\\tsuper(newType);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class JsonPropertyAccess extends Expression<Json<any>> {\\r\\n\\tconstructor(public readonly expression: Expression<Json<any>>, public readonly key: string) {\\r\\n\\t\\tsuper(tJson());\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class FromItemExpression<T extends Row> extends Expression<Record<T>> {\\r\\n\\tconstructor(public readonly fromItem: FromItem<T>) {\\r\\n\\t\\tsuper(tRecord<T>());\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport function normalize<T extends AnyType>(type: T, expr: ExpressionOrInputValue<T>): Expression<T> {\\r\\n\\tif (expr instanceof Expression) return expr;\\r\\n\\treturn new ValueExpression<T>(type, expr);\\r\\n}\\r\\n\\r\\nexport function not(expression: Expression<BooleanType>): Expression<BooleanType> {\\r\\n\\treturn new NotExpression(expression);\\r\\n}\\r\\n\\r\\nexport function and(expression1: Expression<BooleanType>, ...expressions: Expression<BooleanType>[]): Expression<BooleanType>;\\r\\nexport function and(...expressions: (Expression<BooleanType> | undefined)[]): Expression<BooleanType>|undefined;\\r\\nexport function and(...expressions: (Expression<BooleanType> | undefined)[]): Expression<BooleanType>|undefined {\\r\\n\\treturn expressions\\r\\n\\t\\t.filter(expr => !!expr)\\r\\n\\t\\t.reduce((prev, cur) => prev ? prev.and(cur!) : cur, undefined);\\r\\n}\\r\\n\\r\\nexport function concat(...expressions: ExpressionOrInputValue<TextType>[]): Expression<TextType> {\\r\\n\\treturn new KnownFunctionInvocation(\\\"concat\\\", expressions.map(e => normalize(tText, e)), tText);\\r\\n}\\r\\n\\r\\nexport function coalesce<T extends AnyType>(...expressions: Expression<T>[]): Expression<T> {\\r\\n\\treturn new KnownFunctionInvocation(\\\"coalesce\\\", expressions, expressions[expressions.length - 1].type);\\r\\n}\\r\\n\\r\\nexport function val(value: string, preferEscaping?: boolean): ValueExpression<TextType>;\\r\\nexport function val(value: boolean, preferEscaping?: boolean): ValueExpression<BooleanType>;\\r\\nexport function val(value: number, preferEscaping?: boolean): ValueExpression<IntegerType>;\\r\\nexport function val<T extends AnyType>(value: GetInType<T>, type: T, preferEscaping?: boolean): ValueExpression<T>;\\r\\nexport function val(value: string|boolean|number, ...other: any[]) {\\r\\n\\tlet preferEscaping: boolean;\\r\\n\\tif (other[0] instanceof Type) {\\r\\n\\t\\tpreferEscaping = !!other[1];\\r\\n\\t\\treturn new ValueExpression(other[0], value, preferEscaping);\\r\\n\\t}\\r\\n\\tpreferEscaping = !!other[0];\\r\\n\\r\\n\\tlet t: AnyType;\\r\\n\\tif (typeof value === \\\"string\\\") t = tText;\\r\\n\\telse if (typeof value === \\\"boolean\\\") t = tBoolean;\\r\\n\\telse if (typeof value === \\\"number\\\") t = tInteger;\\r\\n\\telse throw new Error(`Unsupported value: '${value}'.`);\\r\\n\\r\\n\\treturn new ValueExpression(t, value, preferEscaping);\\r\\n}\\r\\n\\r\\nexport function jsonVal<T>(value: T) {\\r\\n\\treturn val(value, tJson<T>());\\r\\n}\\r\\n\\r\\nexport function defaultValue(): DefaultExpression { return new DefaultExpression(); }\\r\\n\\r\\nexport function toCondition<TColumns>(fromItem: FromItem<TColumns>|undefined, args: (Expression<BooleanType>[]) | [ Partial<MapExpressionOrInputValue<TColumns>> ])\\r\\n\\t\\t: Expression<BooleanType>|undefined {\\r\\n\\r\\n\\tconst firstArg = args[0];\\r\\n\\tif (firstArg && !(firstArg instanceof Expression)) {\\r\\n\\t\\tif (typeof firstArg !== \\\"object\\\" || Array.isArray(firstArg)) throw new Error(`Where argument must be an object, but was '${firstArg}'.`);\\r\\n\\r\\n\\t\\treturn and(...Object.keys(firstArg).map(columnName => {\\r\\n\\t\\t\\tconst expression = firstArg[columnName as keyof TColumns];\\r\\n\\t\\t\\tif (!fromItem) throw new Error(\\\"No table to select from specified.\\\");\\r\\n\\t\\t\\tconst column = getColumn(fromItem, columnName);\\r\\n\\t\\t\\treturn column.isEqualTo(expression);\\r\\n\\t\\t}));\\r\\n\\t}\\r\\n\\telse {\\r\\n\\t\\treturn and(...(args as Expression<BooleanType>[]).map((arg, argIdx) => {\\r\\n\\t\\t\\tif (!(arg instanceof Expression))\\r\\n\\t\\t\\t\\tthrow new Error(`Argument at position '${argIdx}' is not of type expression.`);\\r\\n\\t\\t\\treturn arg;\\r\\n\\t\\t}));\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport type NamedExpressionNameOf<T extends NamedExpression<any, any>> = T[\\\"name\\\"];\\r\\n\\r\\nexport class NamedExpression<TColumnName extends string, T extends AnyType> extends Expression<T> {\\r\\n\\tconstructor(public readonly name: TColumnName, type: T) { super(type); }\\r\\n}\\r\\n\\r\\nexport class Column<TColumnName extends string, T extends AnyType> extends NamedExpression<TColumnName, T> {\\r\\n\\tprivate _fromItem: FromItem<any>;\\r\\n\\tpublic get fromItem() { return this._fromItem; }\\r\\n\\r\\n\\tconstructor(name: TColumnName, type: T, fromItemSetterProvider: (setter: (fromItem: FromItem<any>) => void) => void) {\\r\\n\\t\\tsuper(name, type);\\r\\n\\r\\n\\t\\tfromItemSetterProvider(fromItem => this._fromItem = fromItem);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class TableColumn<TColumnName extends string, T extends AnyType> extends Column<TColumnName, T> {\\r\\n\\tconstructor(name: TColumnName, type: T, fromItemSetterProvider: (setter: (fromItem: Table<any, any>) => void) => void) {\\r\\n\\t\\tsuper(name, type, fromItemSetterProvider);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class AsColumn<TColumnName extends string, T extends AnyType> extends Column<TColumnName, T> {\\r\\n\\tconstructor(name: TColumnName, type: T, fromItemSetterProvider: (setter: (fromItem: Table<any, any>) => void) => void) {\\r\\n\\t\\tsuper(name, type, fromItemSetterProvider);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class ColumnBoundToExpression<TColumnName extends string, T extends AnyType> extends Column<TColumnName, T> {\\r\\n\\tconstructor(private readonly expression: NamedExpression<TColumnName, T>, fromItemSetterProvider: (setter: (fromItem: FromItem<any>) => void) => void) {\\r\\n\\t\\tsuper(expression.name, expression.type, fromItemSetterProvider);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class AllExpression<TColumns extends Row> extends Expression<VoidType> {\\r\\n\\tconstructor(public readonly fromItem: FromItem<TColumns>) {\\r\\n\\t\\tsuper(tVoid);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class NamedExpressionWrapper<TColumnName extends string, T extends AnyType> extends NamedExpression<TColumnName, T> {\\r\\n\\tconstructor(name: TColumnName, public readonly expression: Expression<T>) { super(name, expression.type); }\\r\\n}\\r\\n\\r\\n\\r\\nexport class RetrievalQueryAsExpression<T extends AnyType> extends Expression<T> {\\r\\n\\tconstructor(public readonly query: RetrievalQuery<any, any>, type: T) { super(type); }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nexport class ValueExpression<T extends AnyType> extends Expression<T> {\\r\\n\\tconstructor(type: T, public readonly value: GetInType<T>, public readonly preferEscaping: boolean = false) { super(type); }\\r\\n}\\r\\n\\r\\n\\r\\nexport type ExpressionOrInputValue<T extends AnyType> = GetInType<T>|Expression<T>;\\r\\nexport type MapExpressionOrInputValue<T extends { [key: string]: any }> = { [TKey in keyof T]: ExpressionOrInputValue<T[TKey]> };\\r\\n\\r\\nexport class Variable<T extends AnyType> extends Expression<T> {\\r\\n\\tconstructor(public readonly name: string, type: T) { super(type); }\\r\\n}\\r\\n\\r\\nexport abstract class BinaryOperatorExpression<TLeft extends AnyType, TRight extends AnyType, TResult extends AnyType> extends Expression<TResult> {\\r\\n\\tconstructor(\\r\\n\\t\\t\\tpublic readonly left: Expression<TLeft>,\\r\\n\\t\\t\\tpublic readonly right: Expression<TRight>, \\r\\n\\t\\t\\ttype: TResult) {\\r\\n\\r\\n\\t\\tsuper(type);\\r\\n\\t}\\r\\n\\r\\n\\tpublic abstract get operator(): string;\\r\\n}\\r\\n\\r\\nexport interface ConcreteBinaryExpression<TLeft extends AnyType, TRight extends AnyType, TResult extends AnyType> extends BinaryOperatorExpression<TLeft, TRight, TResult> {\\r\\n\\toperator: string;\\r\\n\\tprecedenceLevel: number;\\r\\n}\\r\\nexport interface ConcreteBinaryExpressionStatic<TLeft extends AnyType, TRight extends AnyType, TResult extends AnyType> {\\r\\n\\tnew (...args: any[]): ConcreteBinaryExpression<TLeft, TRight, TResult>;\\r\\n}\\r\\n\\r\\nexport function ConcreteBinaryExpression<TLeft extends AnyType, TRight extends AnyType, TResult extends AnyType>(\\r\\n\\t\\tsymbol: string, resultType: TResult, precedenceLevel: number): ConcreteBinaryExpressionStatic<TLeft, TRight, TResult> {\\r\\n\\treturn class extends BinaryOperatorExpression<TLeft, TRight, TResult> {\\r\\n\\t\\tconstructor(left: Expression<TLeft>, right: Expression<TRight>) { super(left, right, resultType); }\\r\\n\\t\\tpublic get operator(): string { return symbol; }\\r\\n\\t\\tpublic get precedenceLevel(): number { return precedenceLevel; }\\r\\n\\t};\\r\\n}\\r\\n\\r\\nexport class AdditionExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"+\\\", tInteger, 3) {}\\r\\nexport class SubtractionExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"-\\\", tInteger, 3) {}\\r\\nexport class MultiplicationExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"*\\\", tInteger, 2) {}\\r\\nexport class DivisionExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"/\\\", tInteger, 2) {}\\r\\nexport class ModulusExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"%\\\", tInteger, 2) {}\\r\\n\\r\\n\\r\\nexport class EqualsExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"=\\\", tBoolean, 4) {}\\r\\nexport class UnequalsExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"!=\\\", tBoolean, 4) {}\\r\\nexport class GreaterExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\">\\\", tBoolean, 4) {}\\r\\nexport class LessExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"<\\\", tBoolean, 4) {}\\r\\nexport class GreaterOrEqualExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\">=\\\", tBoolean, 4) {}\\r\\nexport class LessOrEqualExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"<=\\\", tBoolean, 4) {}\\r\\nexport class NotLessExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"!<\\\", tBoolean, 4) {}\\r\\nexport class NotGreaterExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"!>\\\", tBoolean, 4) {}\\r\\n\\r\\nexport class OrExpression extends ConcreteBinaryExpression<BooleanType, BooleanType, BooleanType>(\\\"OR\\\", tBoolean, 7) {}\\r\\nexport class AndExpression extends ConcreteBinaryExpression<BooleanType, BooleanType, BooleanType>(\\\"AND\\\", tBoolean, 6) {}\\r\\n\\r\\nexport class LikeExpression extends Expression<BooleanType> {\\r\\n\\tpublic get precedenceLevel() { return 7; }\\r\\n\\tconstructor(public readonly argument: Expression<TextType>, public readonly like: Expression<TextType>) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class IsInValuesExpression<T extends AnyType> extends Expression<BooleanType> {\\r\\n\\tpublic get precedenceLevel() { return 7; }\\r\\n\\r\\n\\tconstructor(public readonly argument: Expression<T>, public readonly values: Expression<T>[]) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class IsInQueryExpression<T extends AnyType> extends Expression<BooleanType> {\\r\\n\\tpublic get precedenceLevel() { return 7; }\\r\\n\\r\\n\\tconstructor(public readonly argument: Expression<T>, public readonly query: RetrievalQuery<any, any>) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class IsNullExpression extends Expression<BooleanType> {\\r\\n\\tconstructor(public readonly argument: Expression<any>) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class IsNotNullExpression extends Expression<BooleanType> {\\r\\n\\tconstructor(public readonly argument: Expression<any>) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class NotExpression extends Expression<BooleanType> {\\r\\n\\tpublic get precedenceLevel() { return 5; }\\r\\n\\r\\n\\tconstructor(public readonly argument: Expression<BooleanType>) { super(argument.type); }\\r\\n}\\r\\n\\r\\nexport class KnownFunctionInvocation<TResultType extends AnyType> extends Expression<TResultType> {\\r\\n\\tconstructor(public readonly functionName: string, public readonly args: Expression<any>[], resultType: TResultType) { super(resultType); }\\r\\n}\\r\\n\\r\\nexport class DefaultExpression extends Expression<AnyType> { constructor() { super(tVoid); } }\\r\\n\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Expressions.ts\n// module id = 252\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Expressions.ts?./~/raw-loader");

/***/ }),

/***/ 253:
/***/ (function(module, exports) {

eval("module.exports = \"import { Expression, Column, ColumnBoundToExpression, AllExpression, ExpressionTypeOf, FromItemExpression } from \\\"./Expressions\\\";\\r\\nimport { toObject, objectEntries, objectValues } from \\\"../Helpers\\\";\\r\\nimport { Query } from \\\"./Queries/Query\\\";\\r\\nimport { AnyType, Record, BooleanType } from \\\"./Types\\\";\\r\\n\\r\\nexport interface Row {\\r\\n\\t[name: string]: any;//AnyType;\\r\\n}\\r\\n\\r\\nexport interface Columns {\\r\\n\\t[name: string]: any;//Column<string, AnyType>;\\r\\n}\\r\\n\\r\\nexport type RowToColumns<TColumns extends Row> =\\r\\n\\t{[TName in keyof TColumns]: Column<TName, TColumns[TName]> };\\r\\n\\r\\nexport type ColumnsToRow<TColumns extends Columns>\\r\\n\\t= {[TName in keyof TColumns]: ExpressionTypeOf<TColumns[TName]> };\\r\\n\\r\\nexport class FromFactor {\\r\\n\\t_brand: \\\"FromFactor\\\";\\r\\n\\r\\n\\tpublic static getAllFromFactors(factor: FromFactor): FromItem<any>[] {\\r\\n\\t\\tif (factor instanceof FromItem) return [factor];\\r\\n\\t\\telse if (factor instanceof FromFactorAbstractJoin) {\\r\\n\\t\\t\\treturn FromFactor.getAllFromFactors(factor.leftArg).concat(\\r\\n\\t\\t\\t\\tFromFactor.getAllFromFactors(factor.rightArg)\\r\\n\\t\\t\\t);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthrow new Error(\\\"Unsupported from factor\\\");\\r\\n\\t}\\r\\n\\r\\n\\tpublic static crossJoin(factor1: FromFactor | undefined, factor2: FromFactor | undefined): FromFactor | undefined {\\r\\n\\t\\tif (!factor1) return factor2;\\r\\n\\t\\tif (!factor2) return factor1;\\r\\n\\t\\treturn new FromFactorCrossJoin(factor1, factor2);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport abstract class FromFactorAbstractJoin extends FromFactor {\\r\\n\\tconstructor(public readonly leftArg: FromFactor,\\r\\n\\t\\tpublic readonly rightArg: FromFactor) {\\r\\n\\r\\n\\t\\tsuper();\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport abstract class FromFactorAbstractConditionalJoin extends FromFactorAbstractJoin {\\r\\n\\tconstructor(leftArg: FromFactor, rightArg: FromFactor,\\r\\n\\t\\tpublic readonly joinCondition: Expression<BooleanType>) {\\r\\n\\r\\n\\t\\tsuper(leftArg, rightArg);\\r\\n\\t}\\r\\n\\r\\n\\tpublic abstract getType(): string;\\r\\n}\\r\\n\\r\\nexport class FromFactorLeftJoin extends FromFactorAbstractConditionalJoin { public getType() { return \\\"left\\\"; } };\\r\\nexport class FromFactorFullJoin extends FromFactorAbstractConditionalJoin { public getType() { return \\\"full\\\"; } };\\r\\nexport class FromFactorInnerJoin extends FromFactorAbstractConditionalJoin { public getType() { return \\\"inner\\\"; } };\\r\\nexport class FromFactorCrossJoin extends FromFactorAbstractJoin { public getType() { return \\\"cross\\\"; } };\\r\\n\\r\\nexport type FromItemToRow<TFromItem extends FromItem<any>> =\\r\\n\\t{[TName in keyof TFromItem[\\\"$columns\\\"]]: ExpressionTypeOf<TFromItem[\\\"$columns\\\"][TName]> };\\r\\n\\r\\nexport abstract class FromItem<TColumns extends Row> extends FromFactor {\\r\\n\\tpublic readonly $columns: RowToColumns<TColumns>;\\r\\n\\tpublic readonly $all: AllExpression<TColumns> = new AllExpression(this);\\r\\n\\r\\n\\tconstructor(columns: RowToColumns<TColumns>, private readonly castToColumns: boolean) {\\r\\n\\t\\tsuper();\\r\\n\\t\\tthis.$columns = columns;\\r\\n\\r\\n\\t\\tfor (const [name, col] of objectEntries(columns)) {\\r\\n\\t\\t\\tif (!(name in this))\\r\\n\\t\\t\\t\\t(this as any)[name] = col;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tpublic as(name: string): FromItemCtor<TColumns> {\\r\\n\\t\\tconst setters: ((fromItem: FromItem<any>) => void)[] = [];\\r\\n\\t\\tconst columns = objectValues(this.$columns)\\r\\n\\t\\t\\t.map((col: Column<any, any>) => new ColumnBoundToExpression(col, s => setters.push(s)));\\r\\n\\t\\tconst result = new NamedFromItem<TColumns>(name, toObject(columns, c => c.name), this, false) as any;\\r\\n\\t\\tfor (const s of setters) s(result);\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n\\tpublic asNullable(): FromItemCtor<{[TKey in keyof TColumns]: TColumns[TKey] | null }> {\\r\\n\\t\\treturn this as any;\\r\\n\\t}\\r\\n\\r\\n\\tpublic asExpression(): Expression<Record<TColumns>> {\\r\\n\\t\\treturn new FromItemExpression<TColumns>(this);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport function isCastToColumns(fromItem: FromItem<any>): boolean {\\r\\n\\treturn fromItem[\\\"castToColumns\\\"];\\r\\n}\\r\\n\\r\\nexport function getColumn(fromItem: FromItem<any>, column: string): Column<string, AnyType> {\\r\\n\\tconst result = fromItem.$columns[column];\\r\\n\\tif (!result) throw new Error(`Column '${column}' does not exist on table '${fromItem}'.`);\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nexport class NamedFromItem<TColumns extends Row> extends FromItem<TColumns> {\\r\\n\\tconstructor(public readonly $name: string, columns: RowToColumns<TColumns>, public readonly fromItem: FromItem<TColumns>, castToColumns: boolean) {\\r\\n\\t\\tsuper(columns, castToColumns);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class QueryFromItem<TColumns> extends FromItem<TColumns> {\\r\\n\\tconstructor(public readonly $name: string, columns: RowToColumns<TColumns>, public readonly query: Query<TColumns, any>, castToColumns: boolean) {\\r\\n\\t\\tsuper(columns, castToColumns);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport type FromItemCtor<TColumns extends Row> = FromItem<TColumns> & RowToColumns<TColumns>;\\r\\n\\r\\n\\r\\n/* TODO, for recursion\\r\\nexport class BindableFromItem<TColumns extends ImplicitColumns> extends FromItem<TColumns> {\\r\\n\\tpublic bind(fromItem: FromItem<TColumns>): void;\\r\\n\\tpublic bindAndOverrideColumnNames(view: FromItem<any>): void;\\r\\n}\\r\\n\\r\\ntype BindableViewCtor<TColumns extends ImplicitColumns> = BindableFromItem<TColumns> & ImplicitColumnsToColumns<TColumns>;\\r\\n\\r\\nexport function view<TColumnsWithTypes extends { [columnName: string]: Columns.ColumnDescription<any> }>(\\r\\n\\t\\ttableName: string, columns: TColumnsWithTypes):\\r\\n\\tBindableViewCtor<ColumnsWithTypesToImplicit<TColumnsWithTypes>> {\\r\\n\\t\\r\\n\\treturn null!;\\r\\n}\\r\\n*/\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/FromFactor.ts\n// module id = 253\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/FromFactor.ts?./~/raw-loader");

/***/ }),

/***/ 254:
/***/ (function(module, exports) {

eval("module.exports = \"export type Ordering<T> = { asc: T } | { desc: T };\\r\\n\\r\\nexport function isOrderingAsc(obj: any): obj is { asc: any } {\\r\\n\\tconst keys = Object.keys(obj);\\r\\n\\treturn keys.length === 1 && keys[0] === \\\"asc\\\";\\r\\n}\\r\\n\\r\\nexport function isOrderingDesc(obj: any): obj is { desc: any } {\\r\\n\\tconst keys = Object.keys(obj);\\r\\n\\treturn keys.length === 1 && keys[0] === \\\"desc\\\";\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Ordering.ts\n// module id = 254\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Ordering.ts?./~/raw-loader");

/***/ }),

/***/ 255:
/***/ (function(module, exports) {

eval("module.exports = \"import { Expression, Column, NamedExpression, NamedExpressionNameOf, ExpressionTypeOf, AllExpression } from \\\"../Expressions\\\";\\r\\nimport { FromItem } from \\\"../FromFactor\\\";\\r\\nimport { objectValues } from \\\"../../Helpers\\\";\\r\\nimport { AnyType } from \\\"../Types\\\";\\r\\n\\r\\n/**\\r\\n * An helper for mixins.\\r\\n * @private\\r\\n */\\r\\nexport type Constructable<T> = new (...args: any[]) => T;\\r\\n\\r\\n/**\\r\\n * If `expression` is a string, it returns the column from `fromItem` that has the name `expression` (or throws an exception).\\r\\n * Otherwise, it ensures that `expression` is an `Expression` and returns it.\\r\\n * @private\\r\\n */\\r\\nexport function resolveColumnReference<TExpr extends Expression<any>, TFromTblCols>(\\r\\n\\tfromItem: FromItem<TFromTblCols> | undefined, expression: TExpr | keyof TFromTblCols): TExpr | Column<string, AnyType> {\\r\\n\\r\\n\\tif (expression instanceof Expression) return expression;\\r\\n\\r\\n\\tif (typeof expression !== \\\"string\\\") throw new Error(`Expression must be either of type string or of type Expression, but was '${expression}'.`);\\r\\n\\r\\n\\tif (!fromItem) {\\r\\n\\t\\tthrow new Error(`Columns cannot be referenced by string if no table is specified to select from. `\\r\\n\\t\\t\\t+ `Use method 'from' before.`);\\r\\n\\t}\\r\\n\\r\\n\\tconst column = fromItem.$columns[expression] as Column<string, any>;\\r\\n\\tif (!column) throw new Error(`Column with name '${expression}' does not exist on last table that has been specified in from.`);\\r\\n\\treturn column;\\r\\n}\\r\\n\\r\\n/**\\r\\n * An helper method for select or returning.\\r\\n * @private\\r\\n */\\r\\nexport function handleSelect<TFromTblCols>(\\r\\n\\tfromItem: FromItem<TFromTblCols> | undefined,\\r\\n\\tselectedExpressions: ((keyof TFromTblCols) | NmdExpr | AllExpression<object>)[],\\r\\n\\tallReturningColumns: { [exprName: string]: NamedExpression<string, AnyType> },\\r\\n\\tallSelectedExpressions: (NamedExpression<string, AnyType> | AllExpression<object>)[]) {\\r\\n\\r\\n\\tconst normalizedExpressions = selectedExpressions.map(arg => resolveColumnReference<NmdExpr | AllExpression<object>, TFromTblCols>(fromItem, arg));\\r\\n\\r\\n\\tfor (const expr of normalizedExpressions) {\\r\\n\\t\\tif (!(expr instanceof NamedExpression || expr instanceof AllExpression))\\r\\n\\t\\t\\tthrow new Error(`Given argument '${expr}' must be a named or an all expression.`);\\r\\n\\t}\\r\\n\\r\\n\\tfor (const expr of normalizedExpressions) {\\r\\n\\t\\tfor (const col of (expr instanceof AllExpression) ? objectValues(expr.fromItem.$columns) as Column<string, AnyType>[] : [expr])\\r\\n\\t\\t\\tallReturningColumns[col.name] = col;\\r\\n\\r\\n\\t\\tallSelectedExpressions.push(expr);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * A functor that forces typescript to resolve `|` and `&` operators.\\r\\n * @private\\r\\n */\\r\\nexport type Simplify<T> = {[TKey in keyof T]: T[TKey]};\\r\\n\\r\\n/**\\r\\n * A short form for `NamedExpression<any, any>`.\\r\\n * @private\\r\\n */\\r\\nexport type NmdExpr = NamedExpression<string, AnyType>;\\r\\n\\r\\n/**\\r\\n * \\r\\n * @private\\r\\n */\\r\\nexport type NmdExprToRow<TCol extends NmdExpr> =\\r\\n\\t{[TKey in NamedExpressionNameOf<TCol>]: ExpressionTypeOf<TCol> };\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/Common.ts\n// module id = 255\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/Common.ts?./~/raw-loader");

/***/ }),

/***/ 256:
/***/ (function(module, exports) {

eval("module.exports = \"import { FromItem, Row, FromFactor } from \\\"../FromFactor\\\";\\r\\nimport { Table } from \\\"../Table\\\";\\r\\nimport { ExpressionOrInputValue, AllExpression, NamedExpression, Expression, NamedExpressionNameOf } from \\\"../Expressions\\\";\\r\\nimport { Query, NoColumnsSelected, MoreThanOneColumnSelected, SingleColumn } from \\\"./Query\\\";\\r\\nimport { NmdExpr, Simplify, NmdExprToRow, resolveColumnReference, handleSelect, Constructable } from \\\"./Common\\\";\\r\\nimport { JoinMixin, JoinMixinInstance } from \\\"./JoinMixin\\\";\\r\\nimport { WhereMixin, WhereMixinInstance } from \\\"./WhereMixin\\\";\\r\\nimport { combine } from \\\"../../Helpers\\\";\\r\\nimport { BooleanType } from \\\"../Types\\\";\\r\\n\\r\\n/**\\r\\n * Creates a DELETE FROM statement.\\r\\n * \\r\\n * @param table The table to delete from.\\r\\n */\\r\\nexport function deleteFrom<T extends Row>(table: FromItem<T> & Table<any, any>): DeleteQuery<T, {}, NoColumnsSelected> {\\r\\n\\treturn new DeleteQuery<T, {}, NoColumnsSelected>(table);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Represents a DELETE FROM query.\\r\\n */\\r\\nexport class DeleteQuery<TLastFromRow extends Row, TReturningRow extends Row, TSingleColumn extends SingleColumn<TReturningRow>>\\r\\n\\textends JoinMixin(WhereMixin<Constructable<Query<TReturningRow, TSingleColumn>>, TLastFromRow>(Query)) {\\r\\n\\r\\n\\tprotected _from: FromFactor | undefined = undefined;\\r\\n\\tprotected _whereCondition: Expression<BooleanType> | undefined;\\r\\n\\tprotected lastFromItem: FromItem<TLastFromRow> | undefined;\\r\\n\\r\\n\\tconstructor(private readonly table: FromItem<any> & Table<any, any>) {\\r\\n\\t\\tsuper();\\r\\n\\t\\tthis.lastFromItem = table;\\r\\n\\t}\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn combine(super.getState(), {\\r\\n\\t\\t\\ttable: this.table,\\r\\n\\t\\t\\tusing: this._from,\\r\\n\\t\\t\\twhereCondition: this._whereCondition\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Brings an additional query into scope that can be used to specify more complex delete conditions.\\r\\n\\t * \\r\\n\\t * @param fromItem The query to use.\\r\\n\\t */\\r\\n\\tpublic using<TFromRow extends Row>(fromItem: FromItem<TFromRow>): DeleteQuery<TFromRow, TReturningRow, TSingleColumn> {\\r\\n\\t\\tthis._from = FromFactor.crossJoin(this._from, fromItem);\\r\\n\\t\\tthis.lastFromItem = fromItem as any;\\r\\n\\t\\treturn this as any;\\r\\n\\t}\\r\\n\\r\\n\\t/** Selects all columns from the given table. */\\r\\n\\tpublic returning<T extends Row>(table: AllExpression<T>): DeleteQuery<TLastFromRow, TReturningRow & {[TName in keyof T]: T[TName]}, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single named expression. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(this: DeleteQuery<TLastFromRow, TReturningRow, NoColumnsSelected> | void, expr1: T1): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1>, NamedExpressionNameOf<T1>>;\\r\\n\\r\\n\\t/** Selects 1 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(expr1: T1): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 2 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr>(expr1: T1, expr2: T2): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 3 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 4 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 5 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 6 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 7 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 8 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr, T8 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7, expr8: T8): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7> & NmdExprToRow<T8>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single column that is currently in scope. */\\r\\n\\tpublic returning<TColumnName extends keyof TLastFromRow>(this: DeleteQuery<TLastFromRow, TReturningRow, NoColumnsSelected>, column1: TColumnName): DeleteQuery<TLastFromRow, TReturningRow & {[TName in TColumnName]: TLastFromRow[TName]}, TColumnName>;\\r\\n\\r\\n\\t/** Selects columns that are currently in scope. */\\r\\n\\tpublic returning<TColumnNames extends keyof TLastFromRow>(...columns: TColumnNames[]): DeleteQuery<TLastFromRow, TReturningRow & {[TName in TColumnNames]: TLastFromRow[TName]}, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\tpublic returning(...args: ((keyof TLastFromRow) | NmdExpr | AllExpression<any>)[]): any {\\r\\n\\t\\thandleSelect(this.lastFromItem, args, this.returningColumns as any, this.selectedExpressions);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/DeleteQuery.ts\n// module id = 256\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/DeleteQuery.ts?./~/raw-loader");

/***/ }),

/***/ 257:
/***/ (function(module, exports) {

eval("module.exports = \"import { MapExpressionOrInputValue, AllExpression, NamedExpression, NamedExpressionNameOf } from '../Expressions';\\r\\nimport { RetrievalQuery } from './RetrievalQuery';\\r\\nimport { Table, TableRequiredColumns, TableOptionalColumns } from \\\"../Table\\\";\\r\\nimport { Row, FromItem } from \\\"../FromFactor\\\";\\r\\nimport { Query, MoreThanOneColumnSelected, NoColumnsSelected, SingleColumn } from \\\"./Query\\\";\\r\\nimport { Simplify, NmdExprToRow, NmdExpr, handleSelect } from \\\"./Common\\\";\\r\\nimport { combine } from \\\"../../Helpers\\\";\\r\\n\\r\\n/**\\r\\n * Creates an INSERT INTO statement.\\r\\n * \\r\\n * @param table The table to insert into.\\r\\n */\\r\\nexport function insertInto<TTable extends Table<any, any>>(table: TTable):\\r\\n\\tInsertQueryBuilder<TableRequiredColumns<TTable>, TableOptionalColumns<TTable>> {\\r\\n\\r\\n\\treturn new InsertQueryBuilder<TableRequiredColumns<TTable>, TableOptionalColumns<TTable>>(table);\\r\\n}\\r\\n\\r\\nexport type InsertRows<TRequiredColumns, TOptionalColumns> = (MapExpressionOrInputValue<TRequiredColumns> & Partial<MapExpressionOrInputValue<TOptionalColumns>>)[];\\r\\nexport type InsertRowQuery<TRequiredColumns, TOptionalColumns> = RetrievalQuery<TRequiredColumns & Partial<TOptionalColumns>, any>;\\r\\n\\r\\n/**\\r\\n * Represents an INSERT INTO statement that needs values.\\r\\n */\\r\\nexport class InsertQueryBuilder<TRequiredColumns extends Row, TOptionalColumns extends Row> {\\r\\n\\tconstructor(private readonly table: Table<TRequiredColumns, TOptionalColumns>) { }\\r\\n\\r\\n\\t/**\\r\\n\\t * Inserts one or more items.\\r\\n\\t * @param items The items to be inserted.\\r\\n\\t */\\r\\n\\tpublic value(...items: InsertRows<TRequiredColumns, TOptionalColumns>) {\\r\\n\\t\\treturn this.values(items);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Inserts an array of items.\\r\\n\\t * @param items The items to be inserted.\\r\\n\\t */\\r\\n\\tpublic values(items: InsertRows<TRequiredColumns, TOptionalColumns>): InsertQuery<TRequiredColumns & TOptionalColumns, {}, NoColumnsSelected> {\\r\\n\\t\\treturn new InsertQuery<TRequiredColumns & TOptionalColumns, {}, NoColumnsSelected>(this.table, items);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Uses a subquery to retrieve the items to be inserted.\\r\\n\\t * @param query A query that returns the items to be inserted.\\r\\n\\t */\\r\\n\\tpublic valuesFrom(query: InsertRowQuery<TRequiredColumns, TOptionalColumns>): InsertQuery<TRequiredColumns & TOptionalColumns, {}, NoColumnsSelected> {\\r\\n\\t\\treturn new InsertQuery<TRequiredColumns & TOptionalColumns, {}, NoColumnsSelected>(this.table, query);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n/**\\r\\n * Represents an INSERT INTO statement.\\r\\n */\\r\\nexport class InsertQuery<TTableColumns extends Row, TReturningColumns extends Row, TSingleColumn extends SingleColumn<TTableColumns>>\\r\\n\\textends Query<TReturningColumns, TSingleColumn> {\\r\\n\\r\\n\\tconstructor(private readonly table: Table<any, any>, private readonly values: InsertRows<any, any> | InsertRowQuery<any, any>) {\\r\\n\\t\\tsuper();\\r\\n\\t}\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn combine(super.getState(), {\\r\\n\\t\\t\\ttable: this.table,\\r\\n\\t\\t\\tvalues: this.values\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\t/** Selects all columns from the given table. */\\r\\n\\tpublic returning<T extends Row>(table: AllExpression<T>): InsertQuery<TTableColumns, Simplify<TReturningColumns & {[TName in keyof T]: T[TName]}>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single named expression. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(this: InsertQuery<TTableColumns, TReturningColumns, NoColumnsSelected> | void, expr1: T1): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1>>, NamedExpressionNameOf<T1>>;\\r\\n\\r\\n\\t/** Selects 1 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(expr1: T1): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 2 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr>(expr1: T1, expr2: T2): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 3 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 4 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 5 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 6 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 7 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 8 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr, T8 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7, expr8: T8): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7> & NmdExprToRow<T8>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single column that is currently in scope. */\\r\\n\\tpublic returning<TColumnName extends keyof TTableColumns>(this: InsertQuery<TTableColumns, TReturningColumns, NoColumnsSelected>, column1: TColumnName): InsertQuery<TTableColumns, Simplify<TReturningColumns & {[TName in TColumnName]: TTableColumns[TName]}>, TColumnName>;\\r\\n\\r\\n\\t/** Selects columns that are currently in scope. */\\r\\n\\tpublic returning<TColumnNames extends keyof TTableColumns>(...columns: TColumnNames[]): InsertQuery<TTableColumns, Simplify<TReturningColumns & {[TName in TColumnNames]: TTableColumns[TName]}>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\tpublic returning(...args: ((keyof TTableColumns) | NmdExpr | AllExpression<any>)[]): any {\\r\\n\\t\\thandleSelect(this.table, args, this.returningColumns as any, this.selectedExpressions);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/InsertQuery.ts\n// module id = 257\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/InsertQuery.ts?./~/raw-loader");

/***/ }),

/***/ 258:
/***/ (function(module, exports) {

eval("module.exports = \"import { BooleanType } from '../Types';\\r\\nimport { Expression, ExpressionOrInputValue, ExpressionTypeOf, toCondition, MapExpressionOrInputValue } from \\\"../Expressions\\\";\\r\\nimport { FromItem, FromFactor, FromFactorFullJoin, FromFactorInnerJoin, FromFactorLeftJoin } from \\\"../FromFactor\\\";\\r\\nimport { Constructable } from \\\"./Common\\\";\\r\\n\\r\\nexport interface JoinMixinInstance {\\r\\n\\t/**\\r\\n\\t * Performs a full join on the current query (`cur`) and a specified table (`joined`).\\r\\n\\t * These rows are returned:\\r\\n\\t * ```\\r\\n\\t * for (row r in cur): for (row j in joined that matches r)\\r\\n\\t * \\tyield row(r, j)\\r\\n\\t * for (row r in cur): if (joined has no row that matches r)\\r\\n\\t * \\tyield row(r, null)\\r\\n\\t * for (row j in joined): if (cur has no row that matches j)\\r\\n\\t * \\tyield row(null, j)\\r\\n\\t * ```\\r\\n\\t */\\r\\n\\tfullJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this>;\\r\\n\\r\\n\\t/**\\r\\n\\t * Performs a left join on the current query (`cur`) and a specified table (`joined`).\\r\\n\\t * These rows are returned:\\r\\n\\t * ```\\r\\n\\t * for (row r in cur): for (row j in joined that matches r)\\r\\n\\t * \\tyield row(r, j)\\r\\n\\t * for (row r in cur): if (joined has no row that matches r)\\r\\n\\t * \\tyield row(r, null)\\r\\n\\t * ```\\r\\n\\t */\\r\\n\\tleftJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this>;\\r\\n\\r\\n\\t/**\\r\\n\\t * Performs an inner join on the current query (`cur`) and a specified table (`joined`).\\r\\n\\t * These rows are returned:\\r\\n\\t * ```\\r\\n\\t * for (row r in cur): for (row j in joined that matches r)\\r\\n\\t * \\tyield row(r, j)\\r\\n\\t * ```\\r\\n\\t */\\r\\n\\tinnerJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this>;\\r\\n}\\r\\n\\r\\nexport function JoinMixin<BC extends Constructable<object>>(Base: BC): Constructable<JoinMixinInstance> & BC {\\r\\n\\treturn class extends Base {\\r\\n\\t\\tprotected _from: FromFactor | undefined = undefined;\\r\\n\\r\\n\\t\\tprivate curriedOnJoin(ctor: new (fromFactor: FromFactor, joined: FromFactor, condition: Expression<BooleanType>) => FromFactor) {\\r\\n\\t\\t\\treturn (joined: FromItem<any>, condition: Expression<BooleanType>): this => {\\r\\n\\t\\t\\t\\tif (!this._from) throw new Error(\\\"A primary table must be selected before other tables can be joined.\\\");\\r\\n\\t\\t\\t\\tthis._from = new ctor(this._from, joined, condition);\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic fullJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this> {\\r\\n\\t\\t\\treturn new JoinConditionBuilder(fromItem, this.curriedOnJoin(FromFactorFullJoin));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic leftJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this> {\\r\\n\\t\\t\\treturn new JoinConditionBuilder(fromItem, this.curriedOnJoin(FromFactorLeftJoin));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic innerJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this> {\\r\\n\\t\\t\\treturn new JoinConditionBuilder(fromItem, this.curriedOnJoin(FromFactorInnerJoin));\\r\\n\\t\\t}\\r\\n\\t};\\r\\n}\\r\\n\\r\\nexport class JoinConditionBuilder<TFromItemColumns, TReturn> {\\r\\n\\tconstructor(private readonly fromItem: FromItem<any>, private readonly onJoin: (joined: FromItem<any>, condition: Expression<BooleanType>) => TReturn) { }\\r\\n\\r\\n\\t/**\\r\\n\\t * Specifies the condition of the join.\\r\\n\\t * At least one condition must be set.\\r\\n\\t * \\r\\n\\t * @param condition The condition.\\r\\n\\t * @param furtherConditions More conditions.\\r\\n\\t */\\r\\n\\tpublic on(condition: Expression<BooleanType>, ...furtherConditions: Expression<BooleanType>[]): TReturn;\\r\\n\\t/**\\r\\n\\t * Specifies the condition of the join.\\r\\n\\t * At least one property must be set.\\r\\n\\t * \\r\\n\\t * @param condition An object that represents multiple equals conditions.\\r\\n\\t *\\tEach property refers to a column of the joined table, its value to the expression the column must be equal to.\\r\\n\\t */\\r\\n\\tpublic on(condition: Partial<MapExpressionOrInputValue<TFromItemColumns>>): TReturn;\\r\\n\\tpublic on(...conditions: any[]): TReturn {\\r\\n\\t\\tconst condition = toCondition(this.fromItem, conditions);\\r\\n\\t\\tif (!condition) throw new Error(\\\"No condition for joined was given.\\\");\\r\\n\\t\\treturn this.onJoin(this.fromItem, condition);\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/JoinMixin.ts\n// module id = 258\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/JoinMixin.ts?./~/raw-loader");

/***/ }),

/***/ 259:
/***/ (function(module, exports) {

eval("module.exports = \"import { AnyType } from '../Types';\\r\\nimport { FromItem, QueryFromItem, FromItemCtor, RowToColumns, Row } from \\\"../FromFactor\\\";\\r\\nimport { NamedExpression, ColumnBoundToExpression, NamedExpressionNameOf, ExpressionTypeOf, AllExpression, AsColumn } from \\\"../Expressions\\\";\\r\\nimport { RowDescriptionToRow } from \\\"../Table\\\";\\r\\nimport { objectValues, objectEntries } from \\\"../../Helpers\\\";\\r\\n\\r\\nexport type RowToNmdExprs<TRow extends Row> =\\r\\n\\t{ [TName in keyof TRow]: NamedExpression<TName, TRow[TName]> };\\r\\n\\r\\nexport interface NoColumnsSelected { _brand: \\\"NoColumnSelected\\\" }\\r\\nexport interface MoreThanOneColumnSelected { _brand: \\\"MoreThanOneColumnSelected\\\" }\\r\\nexport type SingleColumn<TSelectedCols> = NoColumnsSelected|(keyof TSelectedCols)|MoreThanOneColumnSelected;\\r\\n\\r\\nexport class Query<TReturningRow extends Row, TSingleColumn extends SingleColumn<TReturningRow>> {\\r\\n\\tprotected returningColumns: RowToNmdExprs<TReturningRow> = {} as any;\\r\\n\\tprotected selectedExpressions: (NamedExpression<any, any>|AllExpression<any>)[] = [];\\r\\n\\r\\n\\t/**\\r\\n\\t * Returns `NoColumnsSelected` if no columns are selected,\\r\\n\\t * `MoreThanOneColumnSelected` if more than one columns are selected or \\r\\n\\t * the name of the column if exactly one column is selected.\\r\\n\\t */\\r\\n\\tpublic get singleColumn(): TSingleColumn {\\r\\n\\t\\tconst first = this.selectedExpressions[0];\\r\\n\\t\\tif (this.selectedExpressions.length === 1 && !(first instanceof AllExpression))\\r\\n\\t\\t\\treturn first.name;\\r\\n\\t\\treturn undefined as any;\\r\\n\\t}\\r\\n\\r\\n\\tprivate _isWithRecursive: boolean = false;\\r\\n\\tprivate _withItems: FromItem<any>[] = [];\\r\\n\\t\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tisWithRecursive: this._isWithRecursive,\\r\\n\\t\\t\\twithItems: this._withItems,\\r\\n\\t\\t\\tselected: this.selectedExpressions,\\r\\n\\t\\t\\treturningColumns: this.returningColumns\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n/* Not supported yet.\\r\\n\\tpublic withRecursive(view: FromItem<any>): this {\\r\\n\\t\\tthis._isWithRecursive = true;\\r\\n\\t\\treturn this.with(view);\\r\\n\\t}\\r\\n\\r\\n\\tpublic with(view: FromItem<any>): this {\\r\\n\\t\\tthis._withItems.push(view);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\t*/\\r\\n\\r\\n\\t/**\\r\\n\\t * Names this query and returns it as `FromItem`.\\r\\n\\t * @param name The name of the query that will be used in the SQL statement.\\r\\n\\t */\\r\\n\\tpublic as(name: string): FromItemCtor<TReturningRow>;\\r\\n\\r\\n\\t/**\\r\\n\\t * Names this query and renames its columns and returns it as `FromItem`.\\r\\n\\t * @param name The name of the query that will be used in the SQL statement.\\r\\n\\t * @param columns The columns to cast to.\\r\\n\\t */\\r\\n\\tpublic as<TColumnsWithTypes extends { [columnName: string]: AnyType }>(name: string, columns: TColumnsWithTypes): FromItemCtor<RowDescriptionToRow<TColumnsWithTypes>>;\\r\\n\\tpublic as(name: string, columns?: { [columnName: string]: AnyType }): FromItemCtor<TReturningRow> {\\r\\n\\t\\tconst newColumns = {} as any;\\r\\n\\t\\tconst setters: ((fromItem: FromItem<any>) => void)[] = [];\\r\\n\\r\\n\\t\\tlet castToColumns: boolean;\\r\\n\\r\\n\\t\\tif (!columns) {\\r\\n\\t\\t\\tcastToColumns = false;\\r\\n\\t\\t\\tfor (const nmdExpr of objectValues(this.returningColumns) as NamedExpression<any, any>[]) {\\r\\n\\t\\t\\t\\tnewColumns[nmdExpr.name] = new ColumnBoundToExpression(nmdExpr, setter => setters.push(setter));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tcastToColumns = true;\\r\\n\\t\\t\\tfor (const [name, type] of objectEntries(columns)) {\\r\\n\\t\\t\\t\\tnewColumns[name] = new AsColumn(name, type, setter => setters.push(setter));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tconst fromItem = new QueryFromItem(name, newColumns, this, castToColumns);\\r\\n\\t\\tfor (const setter of setters) setter(fromItem);\\r\\n\\r\\n\\t\\treturn fromItem as any; // fields are set in constructor\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/Query.ts\n// module id = 259\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/Query.ts?./~/raw-loader");

/***/ }),

/***/ 260:
/***/ (function(module, exports) {

eval("module.exports = \"import { IntegerType, tInteger } from '../Types';\\r\\nimport { Query, SingleColumn } from \\\"./Query\\\";\\r\\nimport { Expression, ExpressionOrInputValue, RetrievalQueryAsExpression, Variable, normalize, AllExpression, NamedExpression } from \\\"../Expressions\\\";\\r\\nimport { FromItem, Row, getColumn } from \\\"../FromFactor\\\";\\r\\n\\r\\nexport class RetrievalQuery<TRow extends Row, TSingleColumn extends SingleColumn<TRow>> extends Query<TRow, TSingleColumn> {\\r\\n\\tprivate _limit: Expression<IntegerType> | undefined;\\r\\n\\tprivate _offset: Expression<IntegerType> | undefined;\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn Object.assign({\\r\\n\\t\\t\\tlimit: this._limit,\\r\\n\\t\\t\\toffset: this._offset\\r\\n\\t\\t}, super.getState());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets an limit on how many rows are returned.\\r\\n\\t * Overwrites any limit that was set before.\\r\\n\\t * \\r\\n\\t * @param count The limit.\\r\\n\\t */\\r\\n\\tpublic limit(count: ExpressionOrInputValue<IntegerType>): this {\\r\\n\\t\\tthis._limit = normalize(tInteger, count);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets how many rows are skipped.\\r\\n\\t * Overwrites any offset that was set before.\\r\\n\\t * \\r\\n\\t * @param count The offset.\\r\\n\\t */\\r\\n\\tpublic offset(count: ExpressionOrInputValue<IntegerType>): this {\\r\\n\\t\\tthis._offset = normalize(tInteger, count);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Wraps this query as expression. The query must return exactly one row with exactly one column.\\r\\n\\t */\\r\\n\\tpublic asExpression<TSingleColumn2 extends keyof TRow>\\r\\n\\t\\t(this: RetrievalQuery<TRow, TSingleColumn2>): Expression<TRow[TSingleColumn2]> {\\r\\n\\t\\tconst column = this.returningColumns[this.singleColumn];\\r\\n\\t\\treturn new RetrievalQueryAsExpression<TRow[TSingleColumn2]>(this, column.type);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nexport class UnionQuery<TColumns, TSingleColumn extends SingleColumn<TColumns>> extends RetrievalQuery<TColumns, TSingleColumn> {\\r\\n\\tconstructor(public readonly query1: RetrievalQuery<TColumns, TSingleColumn>, public readonly query2: RetrievalQuery<TColumns, any>) {\\r\\n\\t\\tsuper();\\r\\n\\r\\n\\t\\tconst s = query1.getState();\\r\\n\\t\\tthis.returningColumns = s.returningColumns;\\r\\n\\t\\tthis.selectedExpressions = s.selected;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport function unionAll<TColumns, TSingleColumn extends SingleColumn<TColumns>>(query1: RetrievalQuery<TColumns, TSingleColumn>, ...queries: RetrievalQuery<any, any>[])\\r\\n\\t: RetrievalQuery<TColumns, TSingleColumn> {\\r\\n\\r\\n\\treturn queries.reduce((p, c) => new UnionQuery(p, c), query1);\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/RetrievalQuery.ts\n// module id = 260\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/RetrievalQuery.ts?./~/raw-loader");

/***/ }),

/***/ 261:
/***/ (function(module, exports) {

eval("module.exports = \"import { BooleanType, AnyType } from '../Types';\\r\\nimport {\\r\\n\\tExpression, NamedExpression, ExpressionOrInputValue, MapExpressionOrInputValue,\\r\\n\\tExpressionTypeOf, AllExpression, and, toCondition, Column, NamedExpressionNameOf\\r\\n} from \\\"../Expressions\\\";\\r\\nimport {\\r\\n\\tFromItem, FromFactor, Row, RowToColumns,\\r\\n\\tFromFactorFullJoin, FromFactorInnerJoin, FromFactorLeftJoin, FromFactorCrossJoin\\r\\n} from \\\"../FromFactor\\\";\\r\\nimport { RetrievalQuery } from \\\"./RetrievalQuery\\\";\\r\\nimport { NoColumnsSelected, MoreThanOneColumnSelected, SingleColumn } from \\\"./Query\\\";\\r\\nimport { Ordering, isOrderingAsc, isOrderingDesc } from \\\"../Ordering\\\";\\r\\nimport { Simplify, NmdExpr, NmdExprToRow, handleSelect, resolveColumnReference, Constructable } from \\\"./Common\\\";\\r\\nimport { JoinMixin, JoinMixinInstance } from \\\"./JoinMixin\\\";\\r\\nimport { WhereMixin, WhereMixinInstance } from \\\"./WhereMixin\\\";\\r\\nimport { secondWithTypeOfFirst } from \\\"../../Helpers\\\";\\r\\n\\r\\nexport class SelectQuery<TSelectedCols extends Row, TFromTblCols extends Row, TSingleColumn extends SingleColumn<TSelectedCols>>\\r\\n\\textends JoinMixin(\\r\\n\\t\\tWhereMixin<Constructable<RetrievalQuery<TSelectedCols, TSingleColumn>>, TFromTblCols>(\\r\\n\\t\\t\\tRetrievalQuery))\\r\\n{\\r\\n\\tprotected _from: FromFactor | undefined = undefined;\\r\\n\\tprotected _whereCondition: Expression<BooleanType> | undefined;\\r\\n\\tprotected lastFromItem: FromItem<TFromTblCols> | undefined;\\r\\n\\r\\n\\tprivate _orderBys: Ordering<Expression<AnyType>>[] = [];\\r\\n\\tprivate _havingCondition: Expression<BooleanType> | undefined;\\r\\n\\tprivate _groupBys: Expression<AnyType>[] = [];\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn Object.assign({\\r\\n\\t\\t\\torderBys: this._orderBys,\\r\\n\\t\\t\\twhereCondition: this._whereCondition,\\r\\n\\t\\t\\thavingCondition: this._havingCondition,\\r\\n\\t\\t\\tgroupBys: this._groupBys,\\r\\n\\t\\t\\tfrom: this._from\\r\\n\\t\\t}, super.getState());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Selects from a table. If previous tables are already specified, they are cross joined.\\r\\n\\t * @param table The table to select from.\\r\\n\\t */\\r\\n\\tpublic from<TTableColumns>(table: FromItem<TTableColumns>):\\r\\n\\t\\tSelectQuery<TSelectedCols, TTableColumns, TSingleColumn> {\\r\\n\\t\\tthis._from = FromFactor.crossJoin(this._from, table);\\r\\n\\t\\tthis.lastFromItem = table as any;\\r\\n\\t\\treturn this as any;\\r\\n\\t}\\r\\n\\r\\n\\t/** Selects all columns from the given table. */\\r\\n\\tpublic select<T extends Row>(table: AllExpression<T>): SelectQuery<Simplify<TSelectedCols & {[TName in keyof T]: T[TName]}>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single named expression. */\\r\\n\\tpublic select<T1 extends NmdExpr>(this: SelectQuery<TSelectedCols, TFromTblCols, NoColumnsSelected> | void, expr1: T1): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1>>, TFromTblCols, NamedExpressionNameOf<T1>>;\\r\\n\\r\\n\\t/** Selects 1 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr>(expr1: T1): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 2 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr>(expr1: T1, expr2: T2): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 3 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 4 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 5 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 6 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 7 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 8 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr, T8 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7, expr8: T8): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7> & NmdExprToRow<T8>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single column that is currently in scope. */\\r\\n\\tpublic select<TColumnName extends keyof TFromTblCols>(this: SelectQuery<TSelectedCols, TFromTblCols, NoColumnsSelected>, column1: TColumnName): SelectQuery<Simplify<TSelectedCols & {[TName in TColumnName]: TFromTblCols[TName]}>, TFromTblCols, TColumnName>;\\r\\n\\r\\n\\t/** Selects columns that are currently in scope. */\\r\\n\\tpublic select<TColumnNames extends keyof TFromTblCols>(...columns: TColumnNames[]): SelectQuery<Simplify<TSelectedCols & {[TName in TColumnNames]: TFromTblCols[TName]}>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\tpublic select(...args: ((keyof TFromTblCols) | NmdExpr | AllExpression<any>)[]): any {\\r\\n\\t\\thandleSelect(this.lastFromItem, args, this.returningColumns as any, this.selectedExpressions);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds expressions to the order-by list of this query.\\r\\n\\t * Use `expression.desc()` or `{ desc: \\\"columnName\\\" }` for descending order.\\r\\n\\t * @param expressions The expressions to add to the order-by list.\\r\\n\\t */\\r\\n\\tpublic orderBy(...expressions: (\\r\\n\\t\\tOrdering<(Expression<any> | keyof TFromTblCols)> | Expression<any> | keyof TFromTblCols\\r\\n\\t)[]): this;\\r\\n\\t/**\\r\\n\\t * Adds expressions to the order-by list of this query. The `expressionSelector` can be used to refer to already selected expressions.\\r\\n\\t * @param expressionSelector A selector that must return the expressions to add to the order-by list.\\r\\n\\t */\\r\\n\\tpublic orderBy(expressionSelector: (selectedColumns: RowToColumns<TSelectedCols>)\\r\\n\\t\\t=> (Ordering<Expression<any>> | Expression<any>)[] | (Ordering<Expression<any>> | Expression<any>)): this;\\r\\n\\tpublic orderBy(...expressions: any[]): this {\\r\\n\\r\\n\\t\\tconst expressions2 = ((): (Ordering<(Expression<any> | keyof TFromTblCols)> | Expression<any> | keyof TFromTblCols)[] => {\\r\\n\\t\\t\\tconst firstExpr = expressions[0];\\r\\n\\t\\t\\tif (firstExpr && (typeof firstExpr) === \\\"function\\\") {\\r\\n\\t\\t\\t\\tconst expr = firstExpr(this.returningColumns);\\r\\n\\t\\t\\t\\tif (Array.isArray(expr)) return expr;\\r\\n\\t\\t\\t\\treturn [ expr ];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn expressions;\\r\\n\\t\\t})();\\r\\n\\r\\n\\t\\tconst exprs = expressions2.map(e => {\\r\\n\\t\\t\\tif (typeof e === \\\"string\\\") return resolveColumnReference(this.lastFromItem, e).asc();\\r\\n\\t\\t\\tif (e instanceof Expression) return e.asc();\\r\\n\\t\\t\\tif (isOrderingAsc(e)) return resolveColumnReference(this.lastFromItem, e.asc).asc();\\r\\n\\t\\t\\tif (isOrderingDesc(e)) return resolveColumnReference(this.lastFromItem, e.desc).desc();\\r\\n\\t\\t\\tthrow new Error(`Unexpected value in orderBy: '${e}'.`);\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\tthis._orderBys.push(...exprs);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds having-conditions.\\r\\n\\t * In contrast to where-conditions, having-conditions are evaluated after grouping is done.\\r\\n\\t * @param conditionSelector \\r\\n\\t */\\r\\n\\tpublic having(condition: Expression<BooleanType>, ...conditions: Expression<BooleanType>[]): this;\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds having-conditions.\\r\\n\\t * In contrast to where-conditions, having-conditions are evaluated after grouping is done.\\r\\n\\t * @param conditionSelector \\r\\n\\t */\\r\\n\\tpublic having(conditionSelector: (selectedColumns: RowToColumns<TSelectedCols>) => Expression<BooleanType>): this;\\r\\n\\tpublic having(...args: any[]): this {\\r\\n\\t\\tlet expression: Expression<BooleanType> | undefined = undefined;\\r\\n\\t\\tif ((typeof args[0]) === \\\"function\\\") {\\r\\n\\t\\t\\tconst func = args[0];\\r\\n\\t\\t\\texpression = func(this.returningColumns);\\r\\n\\t\\t}\\r\\n\\t\\telse\\r\\n\\t\\t\\texpression = toCondition(this.lastFromItem, args);\\r\\n\\r\\n\\t\\tthis._havingCondition = and(this._havingCondition, expression);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds expressions to the group-by list of this query.\\r\\n\\t * @param expressions The expressions to add.\\r\\n\\t */\\r\\n\\tpublic groupBy(...expressions: (Expression<AnyType> | keyof TFromTblCols)[]): this;\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds expressions to the group-by list of this query. The `expressionSelector` can be used to refer to already selected expressions.\\r\\n\\t * @param expressionSelector A selector that must return the expressions to add to the group-by list.\\r\\n\\t */\\r\\n\\tpublic groupBy(expressionSelector: (selectedColumns: RowToColumns<TSelectedCols>) => Expression<AnyType> | Expression<AnyType>[]): this;\\r\\n\\tpublic groupBy(...expressions: any[]): this {\\r\\n\\t\\tconst exprs = (() => {\\r\\n\\t\\t\\tconst firstExpr = expressions[0];\\r\\n\\t\\t\\tif ((typeof firstExpr) === \\\"function\\\") {\\r\\n\\t\\t\\t\\tlet result = firstExpr(this.returningColumns);\\r\\n\\t\\t\\t\\tif (Array.isArray(result)) return result;\\r\\n\\t\\t\\t\\treturn [result];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse return expressions.map(e => resolveColumnReference(this.lastFromItem, e));\\r\\n\\t\\t})();\\r\\n\\r\\n\\t\\tthis._groupBys.push(...exprs);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a SELECT query that selects from the given table.\\r\\n * @param table The table to select from.\\r\\n */\\r\\nexport function from<TTableColumns>(table: FromItem<TTableColumns>) {\\r\\n\\tconst result = new SelectQuery<{}, {}, NoColumnsSelected>();\\r\\n\\treturn result.from(table);\\r\\n}\\r\\n\\r\\nexport const select = secondWithTypeOfFirst(new SelectQuery<{}, {}, NoColumnsSelected>().select, function (...args: any[]): any {\\r\\n\\tconst result = new SelectQuery<{}, {}, NoColumnsSelected>();\\r\\n\\treturn result.select.call(result, ...args);\\r\\n});\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/SelectQuery.ts\n// module id = 261\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/SelectQuery.ts?./~/raw-loader");

/***/ }),

/***/ 262:
/***/ (function(module, exports) {

eval("module.exports = \"import {\\r\\n\\tFromItem, Row, FromFactor,\\r\\n\\tFromFactorFullJoin, FromFactorInnerJoin, FromFactorLeftJoin, FromFactorCrossJoin, getColumn\\r\\n} from \\\"../FromFactor\\\";\\r\\nimport { Table } from \\\"../Table\\\";\\r\\nimport { Expression, ExpressionOrInputValue, AllExpression, toCondition, and, normalize, NamedExpression, NamedExpressionNameOf, Column } from \\\"../Expressions\\\";\\r\\nimport { Query, SingleColumn, MoreThanOneColumnSelected, NoColumnsSelected } from './Query';\\r\\nimport { NmdExpr, Simplify, NmdExprToRow, resolveColumnReference, handleSelect, Constructable } from \\\"./Common\\\";\\r\\nimport { JoinMixin, JoinMixinInstance } from \\\"./JoinMixin\\\";\\r\\nimport { WhereMixin, WhereMixinInstance } from \\\"./WhereMixin\\\";\\r\\nimport { BooleanType, AnyType } from \\\"../Types\\\";\\r\\nimport { objectEntries } from \\\"../../Helpers\\\";\\r\\n\\r\\nexport function update<T extends Row>(table: FromItem<T> & Table<any, any>): UpdateQuery<T, {}, T, NoColumnsSelected> {\\r\\n\\treturn new UpdateQuery<T, {}, T, NoColumnsSelected>(table);\\r\\n}\\r\\nexport class UpdateQuery<TUpdatedColumns extends Row, TReturningColumns extends Row, TFromTblCols extends Row, TSingleColumn extends SingleColumn<TReturningColumns>>\\r\\n\\textends JoinMixin(WhereMixin<Constructable<Query<TReturningColumns, TSingleColumn>>, TFromTblCols>(Query)) {\\r\\n\\r\\n\\tprotected _from: FromFactor | undefined = undefined;\\r\\n\\tprotected _whereCondition: Expression<BooleanType> | undefined;\\r\\n\\tprotected lastFromItem: FromItem<TFromTblCols> | undefined;\\r\\n\\r\\n\\tprivate readonly _table: FromItem<TUpdatedColumns> & Table<any, any>;\\r\\n\\r\\n\\tprivate _updatedColumns: {[TColumnName in keyof TFromTblCols]?: Expression<TFromTblCols[TColumnName]>} = {};\\r\\n\\r\\n\\tconstructor(table: FromItem<TUpdatedColumns> & Table<any, any>) {\\r\\n\\t\\tsuper();\\r\\n\\t\\tthis.lastFromItem = table;\\r\\n\\t\\tthis._table = table;\\r\\n\\t}\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn Object.assign({\\r\\n\\t\\t\\twhereCondition: this._whereCondition,\\r\\n\\t\\t\\tupdatedColumns: this._updatedColumns,\\r\\n\\t\\t\\ttable: this._table,\\r\\n\\t\\t\\tfrom: this._from\\r\\n\\t\\t}, super.getState());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Selects from a table. If previous tables are already specified, they are cross joined.\\r\\n\\t * These tables can be used to for condition or value expressions.\\r\\n\\t * @param table The table to select from.\\r\\n\\t */\\r\\n\\tpublic from<TTableColumns>(table: FromItem<TTableColumns>): UpdateQuery<TUpdatedColumns, TReturningColumns, TTableColumns, TSingleColumn> {\\r\\n\\t\\tthis._from = FromFactor.crossJoin(this._from, table);\\r\\n\\t\\tthis.lastFromItem = table as any;\\r\\n\\t\\treturn this as any;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets a new value for a column.\\r\\n\\t * Use `defaultValue()` to reset a column to its default value.\\r\\n\\t * \\r\\n\\t * @param column The column to update.\\r\\n\\t * @param value The new value for the column.\\r\\n\\t */\\r\\n\\tpublic set<TColumn extends keyof TUpdatedColumns>(column: TColumn, value: ExpressionOrInputValue<TUpdatedColumns[TColumn]>): this;\\r\\n\\t/**\\r\\n\\t * Sets new values for specified columns.\\r\\n\\t * @param obj The columns to update and their new values.\\r\\n\\t */\\r\\n\\tpublic set(obj: {[TColumnName in keyof TUpdatedColumns]?: ExpressionOrInputValue<TUpdatedColumns[TColumnName]>}): this;\\r\\n\\tpublic set(columnOrObject: string | object, value?: ExpressionOrInputValue<any>): this {\\r\\n\\t\\tif (typeof columnOrObject === \\\"string\\\") {\\r\\n\\t\\t\\tconst column = getColumn(this._table, columnOrObject);\\r\\n\\t\\t\\tconst expr = normalize(column.type, value);\\r\\n\\t\\t\\tthis._updatedColumns[columnOrObject] = expr;\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tfor (const [name, value] of objectEntries(columnOrObject)) {\\r\\n\\t\\t\\t\\tconst column = getColumn(this._table, name);\\r\\n\\t\\t\\t\\tconst expr = normalize(column.type, value);\\r\\n\\t\\t\\t\\tthis._updatedColumns[name as string] = expr;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/** Selects all columns from the given table. */\\r\\n\\tpublic returning<T extends Row>(table: AllExpression<T>): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & {[TName in keyof T]: T[TName]}>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single named expression. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(this: UpdateQuery<TUpdatedColumns, TReturningColumns, TFromTblCols, NoColumnsSelected> | void, expr1: T1): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1>>, TFromTblCols, NamedExpressionNameOf<T1>>;\\r\\n\\r\\n\\t/** Selects 1 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(expr1: T1): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 2 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr>(expr1: T1, expr2: T2): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 3 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 4 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 5 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 6 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 7 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 8 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr, T8 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7, expr8: T8): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7> & NmdExprToRow<T8>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single column that is currently in scope. */\\r\\n\\tpublic returning<TColumnName extends keyof TFromTblCols>(this: UpdateQuery<TUpdatedColumns, TReturningColumns, TFromTblCols, NoColumnsSelected>, column1: TColumnName): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & {[TName in TColumnName]: TFromTblCols[TName]}>, TFromTblCols, TColumnName>;\\r\\n\\r\\n\\t/** Selects columns that are currently in scope. */\\r\\n\\tpublic returning<TColumnNames extends keyof TFromTblCols>(...columns: TColumnNames[]): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & {[TName in TColumnNames]: TFromTblCols[TName]}>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\tpublic returning(...args: ((keyof TFromTblCols) | NmdExpr | AllExpression<object>)[]): any {\\r\\n\\t\\thandleSelect(this.lastFromItem, args, this.returningColumns as any, this.selectedExpressions);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/UpdateQuery.ts\n// module id = 262\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/UpdateQuery.ts?./~/raw-loader");

/***/ }),

/***/ 263:
/***/ (function(module, exports) {

eval("module.exports = \"import { AnyType, tVoid, GetInType } from '../Types';\\r\\nimport { MoreThanOneColumnSelected } from './Query';\\r\\nimport { RowDescriptionToRow } from \\\"../Table\\\";\\r\\nimport { FromItemCtor, QueryFromItem, FromItem } from \\\"../FromFactor\\\";\\r\\nimport { RetrievalQuery } from \\\"./RetrievalQuery\\\";\\r\\nimport { AsColumn } from \\\"../Expressions\\\";\\r\\nimport { toObject, objectEntries } from \\\"../../Helpers\\\";\\r\\n\\r\\nexport function values<T extends { [columnName: string]: AnyType }>(columns: T, items?: { [TName in keyof T]: GetInType<T[TName]> }[]): ValuesQuery<T> {\\r\\n\\tconst values = new ValuesQuery<T>(columns);\\r\\n\\tif (items)\\r\\n\\t\\tvalues.withValues(items);\\r\\n\\treturn values;\\r\\n}\\r\\n\\r\\nexport class ValuesQuery<TAsColumns extends { [columnName: string]: AnyType }> extends RetrievalQuery<{}, MoreThanOneColumnSelected> {\\r\\n\\tpublic readonly values: { [TName in keyof TAsColumns]: GetInType<TAsColumns[TName]> }[] = [];\\r\\n\\r\\n\\tconstructor(public readonly columns: TAsColumns) {\\r\\n\\t\\tsuper();\\r\\n\\t}\\r\\n\\r\\n\\tpublic withValues(items: { [TName in keyof TAsColumns]: GetInType<TAsColumns[TName]> }[]): this {\\r\\n\\t\\tthis.values.push(...items);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\tpublic as(name: string): FromItemCtor<TAsColumns> {\\r\\n\\t\\tconst setters: ((fromItem: FromItem<any>) => void)[] = [];\\r\\n\\t\\tconst first = this.values[0];\\r\\n\\t\\tconst columns = toObject(objectEntries(this.columns), ([name]) => name, ([name, type]) => type);\\r\\n\\r\\n\\t\\treturn super.as(name, columns);\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/ValuesQuery.ts\n// module id = 263\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/ValuesQuery.ts?./~/raw-loader");

/***/ }),

/***/ 264:
/***/ (function(module, exports) {

eval("module.exports = \"import { FromItem } from \\\"../FromFactor\\\";\\r\\nimport { Query } from \\\"./Query\\\";\\r\\nimport { MapExpressionOrInputValue, Expression, and, toCondition } from \\\"../Expressions\\\";\\r\\nimport { Constructable } from \\\"./Common\\\";\\r\\nimport { BooleanType } from \\\"../Types\\\";\\r\\n\\r\\nexport interface WhereMixinInstance<TFromTblCols> {\\r\\n\\t/**\\r\\n\\t * Sets where conditions.\\r\\n\\t * @param obj The object that defines equals expressions.\\r\\n\\t */\\r\\n\\twhere(obj: Partial<MapExpressionOrInputValue<TFromTblCols>>): this;\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets where conditions.\\r\\n\\t * @param conditions The condition expressions.\\r\\n\\t */\\r\\n\\twhere(...conditions: Expression<BooleanType>[]): this;\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets negated where conditions.\\r\\n\\t */\\r\\n\\twhereNot(condition: Expression<BooleanType>, ...conditions: Expression<BooleanType>[]): this;\\r\\n}\\r\\n\\r\\nexport function WhereMixin<BC extends Constructable<object>, TFromTblCols>(Base: BC): Constructable<WhereMixinInstance<TFromTblCols>> & BC {\\r\\n\\treturn class extends Base {\\r\\n\\t\\tprotected _whereCondition: Expression<BooleanType> | undefined;\\r\\n\\t\\tprotected lastFromItem: FromItem<TFromTblCols> | undefined;\\r\\n\\r\\n\\t\\tpublic where(obj: Partial<MapExpressionOrInputValue<TFromTblCols>>): this;\\r\\n\\t\\tpublic where(...conditions: Expression<BooleanType>[]): this;\\r\\n\\t\\tpublic where(...args: any[]): this {\\r\\n\\t\\t\\tconst expression = toCondition(this.lastFromItem, args);\\r\\n\\t\\t\\tthis._whereCondition = and(this._whereCondition, expression);\\r\\n\\t\\t\\treturn this;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic whereNot(condition: Expression<BooleanType>, ...conditions: Expression<BooleanType>[]): this {\\r\\n\\t\\t\\tthis._whereCondition = and(condition.not(), ...conditions.map(c => c.not()));\\r\\n\\t\\t\\treturn this;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/WhereMixin.ts\n// module id = 264\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/WhereMixin.ts?./~/raw-loader");

/***/ }),

/***/ 265:
/***/ (function(module, exports) {

eval("module.exports = \"import { DeleteQuery } from \\\"./Queries/DeleteQuery\\\";\\r\\nimport { InsertQuery } from \\\"./Queries/InsertQuery\\\";\\r\\nimport { SelectQuery } from \\\"./Queries/SelectQuery\\\";\\r\\nimport { UpdateQuery } from \\\"./Queries/UpdateQuery\\\";\\r\\nimport { ValuesQuery } from \\\"./Queries/ValuesQuery\\\";\\r\\n\\r\\nexport type SqlStatement = DeleteQuery<any, any, any> | InsertQuery<any, any, any> | SelectQuery<any, any, any> | UpdateQuery<any, any, any, any> | ValuesQuery<any> | StartTransactionStatement | CommitTransactionStatement;\\r\\n\\r\\nexport class StartTransactionStatement {\\r\\n\\tpublic toString() { return \\\"START TRANSACTION\\\"; }\\r\\n}\\r\\n\\r\\nexport class CommitTransactionStatement {\\r\\n\\tpublic toString() { return \\\"COMMIT\\\"; }\\r\\n}\\r\\n\\r\\nexport class RollbackTransactionStatement {\\r\\n\\tpublic toString() { return \\\"ROLLBACK\\\"; }\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/SqlStatement.ts\n// module id = 265\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/SqlStatement.ts?./~/raw-loader");

/***/ }),

/***/ 266:
/***/ (function(module, exports) {

eval("module.exports = \"import { Row, FromItem, RowToColumns, ColumnsToRow } from \\\"./FromFactor\\\";\\r\\nimport { TableColumn } from \\\"./Expressions\\\";\\r\\nimport { toObject, combine, objectEntries } from \\\"../Helpers\\\";\\r\\nimport { AnyType } from \\\"./Types\\\";\\r\\n\\r\\nexport interface TableName {\\r\\n\\tschema?: string,\\r\\n\\tname: string\\r\\n}\\r\\n\\r\\nexport class Table<TRequiredColumns extends Row, TOptionalColumns extends Row>\\r\\n\\t\\t\\textends FromItem<TRequiredColumns & TOptionalColumns> {\\r\\n\\tpublic $requiredColumns: RowToColumns<TRequiredColumns>;\\r\\n\\tpublic $optionalColumns: RowToColumns<TOptionalColumns>;\\r\\n\\r\\n\\tconstructor(public readonly $name: TableName, requiredColumns: RowToColumns<TRequiredColumns>, \\r\\n\\t\\t\\toptionalColumns: RowToColumns<TOptionalColumns>) {\\r\\n\\t\\tsuper(combine(requiredColumns, optionalColumns), false);\\r\\n\\r\\n\\t\\tthis.$requiredColumns = requiredColumns;\\r\\n\\t\\tthis.$optionalColumns = optionalColumns;\\r\\n\\t}\\r\\n\\r\\n\\tpublic toString() {\\r\\n\\t\\tlet str = \\\"\\\";\\r\\n\\t\\tif (this.$name.schema)\\r\\n\\t\\t\\tstr = `${this.$name.schema}.`\\r\\n\\t\\tstr += this.$name.name;\\r\\n\\t\\treturn str;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport type TableRequiredColumns<TTable extends Table<any, any>> = ColumnsToRow<TTable[\\\"$requiredColumns\\\"]>;\\r\\nexport type TableOptionalColumns<TTable extends Table<any, any>> = ColumnsToRow<TTable[\\\"$optionalColumns\\\"]>;\\r\\n\\r\\nexport type TableCtor<TRequiredColumns extends Row, TOptionalColumns extends Row> \\r\\n\\t= Table<TRequiredColumns, TOptionalColumns> & RowToColumns<TRequiredColumns & TOptionalColumns>;\\r\\n\\r\\nexport interface RowDescription { [columnName: string]: AnyType };\\r\\n\\r\\nexport type RowDescriptionToRow<TColumns extends RowDescription> = TColumns;\\r\\n\\r\\n/**\\r\\n * Declares a table.\\r\\n * @param tableName The name of the table.\\r\\n * @param requiredColumns Columns that need a value when inserting new rows.\\r\\n */\\r\\nexport function table<\\r\\n\\t\\tTColumnsWithTypes1 extends RowDescription>(\\r\\n\\t\\t\\ttableName: string | TableName,\\r\\n\\t\\t\\trequiredColumns: TColumnsWithTypes1,\\r\\n\\t\\t): TableCtor<RowDescriptionToRow<TColumnsWithTypes1>, {}>;\\r\\n/**\\r\\n * Declares a table.\\r\\n * @param tableName The name of the table.\\r\\n * @param requiredColumns Columns that need a value when inserting new rows.\\r\\n * @param optionalColumns Columns that don't need a value when inserting new rows.\\r\\n */\\r\\nexport function table<\\r\\n\\t\\tTColumnsWithTypes1 extends RowDescription,\\r\\n\\t\\tTColumnsWithTypes2 extends RowDescription>(\\r\\n\\t\\t\\ttableName: string | TableName,\\r\\n\\t\\t\\trequiredColumns: TColumnsWithTypes1,\\r\\n\\t\\t\\toptionalColumns: TColumnsWithTypes2\\r\\n\\t\\t):\\r\\n\\tTableCtor<RowDescriptionToRow<TColumnsWithTypes1>, RowDescriptionToRow<TColumnsWithTypes2>>;\\r\\nexport function table(tableName: string | TableName, requiredColumns: RowDescription, optionalColumns: RowDescription = {}) {\\r\\n\\t\\r\\n\\tconst setters: ((fromItem: FromItem<any>) => void)[] = [];\\r\\n\\tconst toTableColumn = (name: string, columnType: AnyType) => {\\r\\n\\t\\tif (!columnType) throw new Error(`Column '${name}' has no type.`);\\r\\n\\t\\treturn new TableColumn(name, columnType, setter => setters.push(setter));\\r\\n\\t};\\r\\n\\r\\n\\tconst reqColumns = toObject(objectEntries(requiredColumns)\\r\\n\\t\\t.map(([name, columnType]) => toTableColumn(name, columnType)), i => i.name);\\r\\n\\t\\t\\r\\n\\tconst optColumns = toObject(objectEntries(optionalColumns)\\r\\n\\t\\t.map(([name, columnType]) => toTableColumn(name, columnType)), i => i.name);\\r\\n\\t\\r\\n\\tconst tblName = (typeof tableName === \\\"string\\\") ? { name: tableName, schema: undefined } : tableName;\\r\\n\\r\\n\\tconst table = new Table(tblName, reqColumns, optColumns);\\r\\n\\tfor (const setter of setters)\\r\\n\\t\\tsetter(table);\\r\\n\\r\\n\\treturn table;\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Table.ts\n// module id = 266\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Table.ts?./~/raw-loader");

/***/ }),

/***/ 267:
/***/ (function(module, exports) {

eval("module.exports = \"import { Row } from \\\"./FromFactor\\\";\\r\\n\\r\\nexport type AnyType = Type<any, any, string>;\\r\\n\\r\\n\\r\\nexport type MapOutType<TRow extends Row> = { [TName in keyof TRow]: GetOutType<TRow[TName]> };\\r\\n\\r\\nexport type GetInType<TType extends any> = TType[\\\"_inType\\\"];\\r\\nexport type GetOutType<TType extends any> = TType[\\\"_outType\\\"];\\r\\n\\r\\nexport abstract class Type<TInType, TOutType, TBrand extends string> {\\r\\n\\tpublic readonly _brand: TBrand;\\r\\n\\tprivate _inType: TInType;\\r\\n\\tprivate _outType: TOutType;\\r\\n\\r\\n\\tpublic abstract serialize(arg: TInType): string|number|boolean|null;\\r\\n\\tpublic abstract deserialize(arg: string|number|boolean): TOutType;\\r\\n\\r\\n\\tpublic orNull(): Type<TInType|null, TOutType|null, TBrand|\\\"null\\\"> {\\r\\n\\t\\treturn new NullType(this);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class NullType<TInType, TOutType, TBrand extends string> extends Type<TInType|null, TOutType|null, TBrand|\\\"null\\\"> {\\r\\n\\tconstructor(private readonly type: Type<TInType, TOutType, TBrand>) {\\r\\n\\t\\tsuper();\\r\\n\\t}\\r\\n\\r\\n\\tpublic serialize(arg: TInType|null): string|number|boolean|null {\\r\\n\\t\\tif (arg === null) return null;\\r\\n\\t\\treturn this.type.serialize(arg);\\r\\n\\t}\\r\\n\\r\\n\\tpublic deserialize(arg: string|number|boolean|null): TOutType|null {\\r\\n\\t\\tif (arg === null) return null;\\r\\n\\t\\treturn this.type.deserialize(arg);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class VoidType extends Type<void, void, \\\"void\\\"> {\\r\\n\\tpublic serialize(arg: void): string|number|boolean|null { throw new Error(\\\"Void type does not support serialization\\\"); }\\r\\n\\tpublic deserialize(arg: string|number|boolean): void { throw new Error(\\\"Void type does not support deserialization\\\"); }\\r\\n}\\r\\nexport const tVoid = new VoidType();\\r\\n\\r\\nexport type RecordTypeToJson<T extends { _brand: string }> = RecordTypeToJson2<T>[\\\"result\\\"];\\r\\nexport type RecordTypeToJson1<T extends { result: any }> = { [TName in keyof T]: T[TName][\\\"result\\\"] };\\r\\nexport type RecordTypeToJson2<T extends { _brand: string }> =\\r\\n{\\r\\n\\tresult: // result is required for TypeScript to accept recursion\\r\\n\\t\\t(\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\trecord: RecordTypeToJson1<{ [TName in keyof T[\\\"_recordType\\\"]]: RecordTypeToJson2<T[\\\"_recordType\\\"][TName]> }>\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t&\\r\\n\\t\\t\\t{ [other: string]: GetInType<T> }\\r\\n\\t\\t)[T[\\\"_brand\\\"]]\\r\\n};\\r\\n\\r\\n// let test: RecordTypeToJson2<{ _brand: \\\"record\\\", _recordType: { p2: { _brand: \\\"record\\\", _recordType: { fooa: { _brand: \\\"record\\\", _recordType: { bla: IntegerType } } } } } }> = null!;\\r\\n\\r\\n\\r\\nexport function tJson<T>(): Json<T> {\\r\\n\\treturn new Json<T>();\\r\\n}\\r\\n\\r\\nexport class Json<T extends any> extends Type<T, T, \\\"json\\\"> {\\r\\n\\r\\n\\tserialize(arg: T): string|number|boolean {\\r\\n\\t\\treturn JSON.stringify(arg);\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): T {\\r\\n\\t\\tif (typeof arg !== \\\"string\\\") throw new Error(\\\"Arg must be of type string.\\\");\\r\\n\\r\\n\\t\\treturn JSON.parse(arg);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class Record<T> extends Type<never, string, \\\"record\\\"> {\\r\\n\\t_recordType: T;\\r\\n\\r\\n\\tserialize(arg: never): string|number|boolean {\\r\\n\\t\\tthrow \\\"\\\";\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string): string {\\r\\n\\t\\treturn arg;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport function tRecord<T>() {\\r\\n\\treturn new Record<T>();\\r\\n}\\r\\n\\r\\nexport class BooleanType extends Type<boolean, boolean, \\\"boolean\\\"> {\\r\\n\\r\\n\\tserialize(arg: boolean): string|number|boolean {\\r\\n\\t\\treturn arg;\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): boolean {\\r\\n\\t\\treturn !!arg;\\r\\n\\t}\\r\\n}\\r\\nexport const tBoolean = new BooleanType();\\r\\n\\r\\nexport class TextType extends Type<string, string, \\\"text\\\"> {\\r\\n\\r\\n\\tserialize(arg: string): string|number|boolean {\\r\\n\\t\\treturn arg;\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): string {\\r\\n\\t\\treturn \\\"\\\" + arg;\\r\\n\\t}\\r\\n}\\r\\nexport const tText = new TextType();\\r\\n\\r\\n\\r\\nexport class IntegerType extends Type<number, number, \\\"integer\\\"> {\\r\\n\\r\\n\\tserialize(arg: number): string|number|boolean {\\r\\n\\t\\treturn arg;\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): number {\\r\\n\\t\\treturn +arg;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport const tInteger = new IntegerType();\\r\\n\\r\\n\\r\\nexport class DateType extends Type<Date, Date, \\\"date\\\"> {\\r\\n\\tserialize(arg: Date): string|number|boolean {\\r\\n\\t\\treturn arg.toString();\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): Date {\\r\\n\\t\\treturn new Date(\\\"\\\"+ arg);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport const tDate = new DateType();\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Types.ts\n// module id = 267\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Types.ts?./~/raw-loader");

/***/ }),

/***/ 268:
/***/ (function(module, exports) {

eval("module.exports = \"import { toObject } from '../Helpers';\\r\\nimport { RetrievalQuery } from '../AST/Queries/RetrievalQuery';\\r\\nimport { AnyType, MapOutType } from '../AST/Types';\\r\\nimport { SqlStatement } from '../AST/SqlStatement';\\r\\nimport pg = require('pg');\\r\\nimport { PostgreSqlGenerator } from \\\"./PostgreSqlGenerator\\\";\\r\\nimport { SqlGeneratorOptions } from \\\"../SqlGenerator\\\";\\r\\nimport { Query } from \\\"../AST/Queries/Query\\\";\\r\\nimport { DbQueryService, SimpleDbQueryService } from \\\"../DbConnection\\\";\\r\\nimport { EventEmitter, ISubscribable } from \\\"hediet-framework/api/events\\\";\\r\\nimport { Deferred } from \\\"hediet-framework/api/synchronization\\\";\\r\\n\\r\\n/* TODO\\r\\nexport class PostgreQueryServiceFactory {\\r\\n\\tconstructor(private readonly pgModule: typeof pg) {\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\r\\n\\tpublic createQueryService(connectionData: any) {\\r\\n\\r\\n\\t}\\r\\n}*/\\r\\n\\r\\nexport class PostgreQueryService implements DbQueryService {\\r\\n\\tpublic readonly sqlGenerator: PostgreSqlGenerator;\\r\\n\\tprivate readonly onSqlStatementEmitter = new EventEmitter<this, { sql: string, parameters: any[], query: SqlStatement, resultRows: Promise<any[]> }>();\\r\\n\\tpublic readonly onSqlStatement = this.onSqlStatementEmitter.asEvent();\\r\\n\\r\\n\\tconstructor(private readonly pool: pg.Pool, sqlGeneratorOptions: SqlGeneratorOptions = {}) {\\r\\n\\t\\tthis.sqlGenerator = new PostgreSqlGenerator(sqlGeneratorOptions);\\r\\n\\t}\\r\\n\\r\\n\\tpublic exec<TRow>(query: Query<TRow, any>): Promise<MapOutType<TRow>[]>;\\r\\n\\tpublic exec<TRow>(statement: SqlStatement): Promise<void>;\\r\\n\\tpublic exec(query: SqlStatement): Promise<any> {\\r\\n\\t\\treturn this.execClient(query);\\r\\n\\t}\\r\\n\\r\\n\\tprivate async execClient(query: SqlStatement, client?: pg.Client): Promise<any> {\\r\\n\\t\\tconst { sql:queryText, parameters } = this.sqlGenerator.toSql(query);\\r\\n\\t\\tconst resultRows = new Deferred<any[]>();\\r\\n\\t\\tthis.onSqlStatementEmitter.emit(this, { sql: queryText, parameters: parameters, query: query, resultRows: resultRows.value });\\r\\n\\r\\n\\t\\tconst result = await (client ? client.query(queryText, parameters) : this.pool.query(queryText, parameters));\\r\\n\\r\\n\\t\\tlet updatedRows = result.rows;\\r\\n\\r\\n/*\\r\\n\\t\\tif (query instanceof RetrievalQuery) {\\r\\n\\t\\t\\tconst cols = query.getState().returningColumns;\\r\\n\\t\\t\\tupdatedRows = updatedRows.map(row => {\\r\\n\\t\\t\\t\\tconst result = {} as any;\\r\\n\\t\\t\\t\\tfor (const prop of row) {\\r\\n\\t\\t\\t\\t\\tconst val = row[prop];\\r\\n\\t\\t\\t\\t\\tconst type = cols[prop] as AnyType;\\r\\n\\t\\t\\t\\t\\tresult[prop] = type.deserialize(val);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n*/\\r\\n\\r\\n\\t\\tresultRows.setValue(updatedRows);\\r\\n\\t\\treturn updatedRows;\\r\\n\\t}\\r\\n\\r\\n\\tpublic getExclusiveQueryService<T>(scope: (service: SimpleDbQueryService) => Promise<T>): Promise<T> {\\r\\n\\t\\treturn new Promise((res, rej) => this.pool.connect((err, client, done) => {\\r\\n\\t\\t\\tif (err) { rej(err); return; }\\r\\n\\r\\n\\t\\t\\tconst service = new this.PostgreExclusiveQueryService(client, this);\\r\\n\\t\\t\\tscope(service)\\r\\n\\t\\t\\t\\t.then(result => {\\r\\n\\t\\t\\t\\t\\tdone();\\r\\n\\t\\t\\t\\t\\tres(result);\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.catch(err => {\\r\\n\\t\\t\\t\\t\\tdone();\\r\\n\\t\\t\\t\\t\\trej(err);\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t}));\\r\\n\\t}\\r\\n\\r\\n\\tprivate readonly PostgreExclusiveQueryService = class PostgreExclusiveQueryService implements SimpleDbQueryService {\\r\\n\\t\\tconstructor(private readonly client: pg.Client, private readonly queryService: PostgreQueryService) {}\\r\\n\\r\\n\\t\\tpublic exec<TColumns>(query: Query<TColumns, any>): Promise<TColumns[]>;\\r\\n\\t\\tpublic exec<TColumns>(statement: SqlStatement): Promise<void>;\\r\\n\\t\\tpublic async exec(query: SqlStatement): Promise<any> {\\r\\n\\t\\t\\treturn this.queryService.execClient(query, this.client);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/Adapters/Postgre.ts\n// module id = 268\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/Adapters/Postgre.ts?./~/raw-loader");

/***/ }),

/***/ 269:
/***/ (function(module, exports) {

eval("module.exports = \"import { SqlGenerator, Context, ExpressionContext } from \\\"../SqlGenerator\\\";\\r\\nimport { ValueExpression } from \\\"../AST/Expressions\\\";\\r\\nimport { AnyType } from \\\"../index\\\";\\r\\n\\r\\nexport class PostgreSqlGenerator extends SqlGenerator {\\r\\n\\tprotected quoteSchemaOrTableOrColumnName(name: string): string {\\r\\n\\t\\tif (this.options.skipQuotingIfNotRequired && /^[a-z_][a-z_0-9]*$/.test(name))\\r\\n\\t\\t\\treturn name;\\r\\n\\t\\treturn this.escapeIdentifier(name);\\r\\n\\t}\\r\\n\\r\\n\\tprotected escapeValue(expr: ValueExpression<AnyType>, context: ExpressionContext): string {\\r\\n\\t\\tconst val = expr.type.serialize(expr.value);\\r\\n\\r\\n\\t\\tif (expr.preferEscaping) {\\r\\n\\t\\t\\tif (val === null) return \\\"null\\\";\\r\\n\\t\\t\\tif (typeof val === \\\"string\\\") return this.escapeLiteral(val);\\r\\n\\t\\t\\tif (typeof val === \\\"number\\\") return val.toString();\\r\\n\\t\\t\\tif (typeof val === \\\"boolean\\\") return val.toString();\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthrow new Error(`Unsupported value: '${val}'.`);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tcontext.context.parameters.push(val);\\r\\n\\t\\t\\tconst id = context.context.parameters.length;\\r\\n\\t\\t\\treturn `$${id}`;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t// https://github.com/brianc/node-postgres/blob/f42924bf057943d5a79ff02c4d35b18777dc5754/lib/client.js#L261\\r\\n\\tprivate escapeIdentifier(str: string) {\\r\\n\\t\\tlet escaped = '\\\"';\\r\\n\\r\\n\\t\\tfor (let i = 0; i < str.length; i++) {\\r\\n\\t\\t\\tconst c = str[i];\\r\\n\\t\\t\\tif (c === '\\\"') {\\r\\n\\t\\t\\t\\tescaped += c + c;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tescaped += c;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tescaped += '\\\"';\\r\\n\\t\\treturn escaped;\\r\\n\\t}\\r\\n\\r\\n\\t// https://github.com/brianc/node-postgres/blob/f42924bf057943d5a79ff02c4d35b18777dc5754/lib/client.js#L280\\r\\n\\tprivate escapeLiteral(str: string) {\\r\\n\\t\\tlet hasBackslash = false;\\r\\n\\t\\tlet escaped = '\\\\'';\\r\\n\\r\\n\\t\\tfor(let i = 0; i < str.length; i++) {\\r\\n\\t\\t\\tconst c = str[i];\\r\\n\\t\\t\\tif(c === '\\\\'') {\\r\\n\\t\\t\\t\\tescaped += c + c;\\r\\n\\t\\t\\t} else if (c === '\\\\\\\\') {\\r\\n\\t\\t\\t\\tescaped += c + c;\\r\\n\\t\\t\\t\\thasBackslash = true;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tescaped += c;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tescaped += '\\\\'';\\r\\n\\r\\n\\t\\tif(hasBackslash === true) {\\r\\n\\t\\t\\tescaped = ' E' + escaped;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn escaped;\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/Adapters/PostgreSqlGenerator.ts\n// module id = 269\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/Adapters/PostgreSqlGenerator.ts?./~/raw-loader");

/***/ }),

/***/ 270:
/***/ (function(module, exports) {

eval("module.exports = \"import { CommitTransactionStatement, RollbackTransactionStatement, SqlStatement, StartTransactionStatement } from './AST/SqlStatement';\\r\\nimport { Query } from \\\"./AST/Queries/Query\\\";\\r\\nimport { RetrievalQuery } from \\\"./AST/Queries/RetrievalQuery\\\";\\r\\nimport { GetOutType, MapOutType } from \\\"./AST/Types\\\";\\r\\nimport { Row } from \\\"./AST/FromFactor\\\";\\r\\n\\r\\nexport interface SimpleDbQueryService {\\r\\n\\texec<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow>[]>;\\r\\n\\texec<TRow extends Row>(statement: SqlStatement): Promise<void>;\\r\\n}\\r\\n\\r\\nexport interface DbQueryService extends SimpleDbQueryService {\\r\\n\\tgetExclusiveQueryService<T>(scope: (service: SimpleDbQueryService) => Promise<T>): Promise<T>;\\r\\n}\\r\\n\\r\\nexport class DbQueryInterface {\\r\\n\\tconstructor(protected readonly queryService: SimpleDbQueryService) { }\\r\\n\\r\\n\\tpublic exec<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow>[]>;\\r\\n\\tpublic exec<TRow extends Row>(statement: SqlStatement): Promise<void>;\\r\\n\\tpublic exec<TRow extends Row>(statement: SqlStatement): Promise<MapOutType<TRow>[]> | Promise<void> {\\r\\n\\t\\treturn this.queryService.exec(statement);\\r\\n\\t}\\r\\n\\r\\n\\tpublic async values<TRow extends Row, TColumn extends keyof TRow>(query: Query<TRow, TColumn>): Promise<GetOutType<TRow[TColumn]>[]> {\\r\\n\\t\\tconst rows = await this.exec(query);\\r\\n\\t\\treturn rows.map(r => r[query.singleColumn]);\\r\\n\\t}\\r\\n\\r\\n\\tpublic async firstOrUndefined<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow> | undefined> {\\r\\n\\t\\tif (query instanceof RetrievalQuery)\\r\\n\\t\\t\\tquery = query.limit(1);\\r\\n\\t\\tconst rows = await this.exec(query);\\r\\n\\t\\treturn rows[0];\\r\\n\\t}\\r\\n\\r\\n\\tpublic async first<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow>> {\\r\\n\\t\\tconst result = await this.firstOrUndefined(query);\\r\\n\\t\\tif (!result) throw new Error(\\\"Expected at least one row.\\\");\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n\\tpublic async single<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow>> {\\r\\n\\t\\tif (query instanceof RetrievalQuery)\\r\\n\\t\\t\\tquery = query.limit(2);\\r\\n\\t\\tconst rows = await this.exec(query);\\r\\n\\t\\tif (rows.length === 0) throw new Error(\\\"No row found.\\\");\\r\\n\\t\\tif (rows.length >= 2) throw new Error(\\\"More than one row returned.\\\");\\r\\n\\t\\treturn rows[0];\\r\\n\\t}\\r\\n\\r\\n\\tpublic async firstOrUndefinedValue<TRow extends Row, TColumn extends keyof TRow>(query: Query<TRow, TColumn>): Promise<GetOutType<TRow[TColumn]> | undefined> {\\r\\n\\t\\tconst row = await this.firstOrUndefined(query);\\r\\n\\t\\tif (!row) return undefined;\\r\\n\\t\\treturn row[query.singleColumn];\\r\\n\\t}\\r\\n\\r\\n\\tpublic async firstValue<TRow extends Row, TColumn extends keyof TRow>(query: Query<TRow, TColumn>): Promise<GetOutType<TRow[TColumn]>> {\\r\\n\\t\\tconst row = await this.first(query);\\r\\n\\t\\treturn row[query.singleColumn];\\r\\n\\t}\\r\\n\\r\\n\\tpublic async singleValue<TRow extends Row, TColumn extends keyof TRow>(query: Query<TRow, TColumn>): Promise<GetOutType<TRow[TColumn]>> {\\r\\n\\t\\tconst row = await this.single(query);\\r\\n\\t\\treturn row[query.singleColumn];\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class TransactingQueryService extends DbQueryInterface {\\r\\n\\tprivate _isTransactionOpen: boolean = true;\\r\\n\\r\\n\\tpublic get isTransactionOpen(): boolean { return this._isTransactionOpen; }\\r\\n\\r\\n\\tpublic exec<TColumns>(query: Query<TColumns, any>): Promise<TColumns[]>;\\r\\n\\tpublic exec<TColumns>(statement: SqlStatement): Promise<void>;\\r\\n\\tpublic exec<TColumns>(statement: SqlStatement): Promise<TColumns[]> | Promise<void> {\\r\\n\\t\\tif (!this._isTransactionOpen) throw new Error(`Could not execute statement '${statement}': Transaction already has been either committed or rolled back.`);\\r\\n\\t\\treturn super.exec(statement);\\r\\n\\t}\\r\\n\\r\\n\\tpublic async rollback() {\\r\\n\\t\\tawait this.exec(new RollbackTransactionStatement());\\r\\n\\t\\tthis._isTransactionOpen = false;\\r\\n\\t}\\r\\n\\r\\n\\tpublic async commit() {\\r\\n\\t\\tawait this.exec(new CommitTransactionStatement());\\r\\n\\t\\tthis._isTransactionOpen = false;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class DbConnection extends DbQueryInterface {\\r\\n\\tconstructor(protected readonly queryService: DbQueryService) { super(queryService); }\\r\\n\\r\\n\\tpublic async transaction<T>(scope: (queryInterface: TransactingQueryService) => Promise<T>): Promise<T> {\\r\\n\\t\\treturn this.queryService.getExclusiveQueryService(async s => {\\r\\n\\t\\t\\tconst queryInterface = new TransactingQueryService(s);\\r\\n\\t\\t\\tawait queryInterface.exec(new StartTransactionStatement());\\r\\n\\t\\t\\tlet error = undefined;\\r\\n\\t\\t\\tlet result: { success: true, result: T } | { success: false, error: any };\\r\\n\\t\\t\\ttry {\\r\\n\\t\\t\\t\\tresult = { success: true, result: await scope(queryInterface) };\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcatch (err) {\\r\\n\\t\\t\\t\\tresult = { success: false, error: err };\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (result.success) {\\r\\n\\t\\t\\t\\tif (queryInterface.isTransactionOpen)\\r\\n\\t\\t\\t\\t\\tawait queryInterface.commit();\\r\\n\\t\\t\\t\\treturn result.result;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tif (queryInterface.isTransactionOpen)\\r\\n\\t\\t\\t\\t\\tawait queryInterface.rollback();\\r\\n\\t\\t\\t\\tthrow result.error;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/DbConnection.ts\n// module id = 270\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/DbConnection.ts?./~/raw-loader");

/***/ }),

/***/ 271:
/***/ (function(module, exports) {

eval("module.exports = \"\\r\\nexport function toObject<T, K>(item: T[], keySelector: (item: T) => K): any\\r\\nexport function toObject<T, K, V>(item: T[], keySelector: (item: T) => K, valueSelector: (item: T) => V): any\\r\\nexport function toObject<T, K, V>(item: T[], keySelector: (item: T) => K, valueSelector?: (item: T) => V): any {\\r\\n\\tconst o = {} as any;\\r\\n\\tfor (const i of item) {\\r\\n\\t\\to[keySelector(i)] = valueSelector ? valueSelector(i) : i;\\r\\n\\t}\\r\\n\\treturn o;\\r\\n}\\r\\n\\r\\nexport function secondWithTypeOfFirst<T1>(t1: T1, t2: any): T1 {\\r\\n\\treturn t2;\\r\\n}\\r\\n\\r\\nexport function objectValues<T extends {}>(obj: T): T[keyof T][] {\\r\\n\\tconst result: T[keyof T][] = [];\\r\\n\\tfor (const prop of Object.getOwnPropertyNames(obj) as (keyof T)[]) {\\r\\n\\t\\tresult.push(obj[prop]);\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nexport function objectEntries<T extends {}>(obj: T): [keyof T, T[keyof T]][] {\\r\\n\\tconst result: [keyof T, T[keyof T]][] = [];\\r\\n\\tfor (const prop of Object.getOwnPropertyNames(obj) as (keyof T)[]) {\\r\\n\\t\\tresult.push([prop, obj[prop]]);\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nexport function combine<T1, T2>(props: T1, and: T2): T1 & T2 {\\r\\n\\tconst result: any = {};\\r\\n\\tfor (const [prop, val] of objectEntries(props)) {\\r\\n\\t\\tresult[prop] = val;\\r\\n\\t}\\r\\n\\tfor (const [prop, val] of objectEntries(and)) {\\r\\n\\t\\tresult[prop] = val;\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nexport class DynamicDispatcher<TBase, TArgs, TResult> {\\r\\n\\tprivate registeredHandlers = new Map<Function, (subject: TBase, arg: TArgs) => TResult>();\\r\\n\\r\\n\\tpublic register<T extends TBase>(clazz: (new (...args: any[]) => T) | Function, handler: (subject: T, arg: TArgs) => TResult) {\\r\\n\\t\\tthis.registeredHandlers.set(clazz, handler);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\tpublic dispatch(obj: TBase, args: TArgs): TResult {\\r\\n\\t\\tlet proto = Object.getPrototypeOf(obj);\\r\\n\\t\\twhile (proto) {\\r\\n\\t\\t\\tconst handler = this.registeredHandlers.get(proto.constructor);\\r\\n\\t\\t\\tif (handler) {\\r\\n\\t\\t\\t\\treturn handler(obj, args);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tproto = Object.getPrototypeOf(proto);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthrow new Error(`No handler was registered for '${obj}'.`);\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/Helpers.ts\n// module id = 271\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/Helpers.ts?./~/raw-loader");

/***/ }),

/***/ 272:
/***/ (function(module, exports) {

eval("module.exports = \"import { UnionQuery } from './AST/Queries/RetrievalQuery';\\r\\nimport { ValuesQuery } from './AST/Queries/ValuesQuery';\\r\\nimport { InsertQuery } from './AST/Queries/InsertQuery';\\r\\nimport { UpdateQuery } from './AST/Queries/UpdateQuery';\\r\\nimport { DeleteQuery } from './AST/Queries/DeleteQuery';\\r\\nimport { SqlStatement, CommitTransactionStatement, RollbackTransactionStatement, StartTransactionStatement } from './AST/SqlStatement';\\r\\nimport {\\r\\n\\tFromFactor,\\r\\n\\tFromFactorAbstractConditionalJoin,\\r\\n\\tFromFactorAbstractJoin,\\r\\n\\tFromFactorCrossJoin,\\r\\n\\tFromFactorFullJoin,\\r\\n\\tFromFactorInnerJoin,\\r\\n\\tFromFactorLeftJoin,\\r\\n\\tFromItem,\\r\\n\\tisCastToColumns,\\r\\n\\tNamedFromItem,\\r\\n\\tQueryFromItem\\r\\n} from './AST/FromFactor';\\r\\nimport { Query } from \\\"./AST/Queries/Query\\\";\\r\\nimport { SelectQuery } from \\\"./AST/Queries/SelectQuery\\\";\\r\\nimport * as Exprs from './AST/Expressions';\\r\\nimport { Table, TableName } from \\\"./AST/Table\\\";\\r\\nimport { isOrderingAsc } from \\\"./AST/Ordering\\\";\\r\\nimport { objectValues, objectEntries, DynamicDispatcher } from \\\"./Helpers\\\";\\r\\nimport { AnyType } from \\\"./index\\\";\\r\\n\\r\\nexport interface SqlGeneratorOptions {\\r\\n\\tshortenColumnNameIfUnambigous?: boolean;\\r\\n\\tskipQuotingIfNotRequired?: boolean;\\r\\n}\\r\\n\\r\\n\\r\\nexport interface ExpressionContext {\\r\\n\\tisColumnNameUnambigous(name: string): boolean;\\r\\n\\tresolveNamedExpression: boolean;\\r\\n\\tcontext: Context;\\r\\n}\\r\\n\\r\\nexport interface Context {\\r\\n\\tparameters: any[];\\r\\n}\\r\\n\\r\\n// IMPORTANT IMPLEMENTATION NOTICE: expressions must be generated in the order they appear in the final sql string!\\r\\n// Otherwise prepared statements with parameters get messed up.\\r\\n\\r\\nexport abstract class SqlGenerator {\\r\\n\\tconstructor(protected readonly options: SqlGeneratorOptions = {}) { }\\r\\n\\r\\n\\tpublic toSql(statement: SqlStatement): { sql: string, parameters: any[] } {\\r\\n\\t\\tconst context: Context = { parameters: [] };\\r\\n\\t\\tconst sql = this.transformToSql(statement, context);\\r\\n\\t\\treturn { sql, parameters: context.parameters };\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformToSql(statement: SqlStatement, context: Context): string {\\r\\n\\t\\tif (statement instanceof SelectQuery) return this.transformSelectQueryToSql(statement, context);\\r\\n\\t\\tif (statement instanceof UpdateQuery) return this.transformUpdateQueryToSql(statement, context);\\r\\n\\t\\tif (statement instanceof InsertQuery) return this.transformInsertQueryToSql(statement, context);\\r\\n\\t\\tif (statement instanceof DeleteQuery) return this.transformDeleteQueryToSql(statement, context);\\r\\n\\t\\tif (statement instanceof ValuesQuery) return this.transformValuesQueryToSql(statement, context);\\r\\n\\r\\n\\t\\tif (statement instanceof UnionQuery) return this.transformUnionQueyToSql(statement, context);\\r\\n\\r\\n\\t\\tif (statement instanceof StartTransactionStatement) return \\\"BEGIN\\\";\\r\\n\\t\\tif (statement instanceof CommitTransactionStatement) return \\\"COMMIT\\\";\\r\\n\\t\\tif (statement instanceof RollbackTransactionStatement) return \\\"ROLLBACK\\\";\\r\\n\\r\\n\\t\\tthrow new Error(`Unsupported query: ${statement}`);\\r\\n\\t}\\r\\n\\r\\n\\tprotected createExpressionContext(froms: (FromFactor | undefined)[], context: Context): ExpressionContext {\\r\\n\\t\\tif (!this.options.shortenColumnNameIfUnambigous)\\r\\n\\t\\t\\treturn { isColumnNameUnambigous: name => false, resolveNamedExpression: false, context };\\r\\n\\r\\n\\t\\tlet allColumns: Exprs.Column<any, any>[] = [];\\r\\n\\t\\tfor (const from of froms) {\\r\\n\\t\\t\\tif (!from) continue;\\r\\n\\r\\n\\t\\t\\tconst allFromFactors = FromFactor.getAllFromFactors(from);\\r\\n\\r\\n\\t\\t\\tallColumns = allColumns.concat(\\r\\n\\t\\t\\t\\t...allFromFactors.map(f => objectValues(f.$columns)));\\r\\n\\t\\t}\\r\\n\\t\\tconst set = new Set<string>();\\r\\n\\t\\tconst duplicates = new Set<string>();\\r\\n\\t\\tfor (const col of allColumns) {\\r\\n\\t\\t\\tif (set.has(col.name)) duplicates.add(col.name);\\r\\n\\t\\t\\telse set.add(col.name);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn { isColumnNameUnambigous: name => !duplicates.has(name), resolveNamedExpression: false, context };\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformUnionQueyToSql(query: UnionQuery<any, any>, context: Context): string {\\r\\n\\t\\tconst query1Sql = this.transformToSql(query.query1, context);\\r\\n\\t\\tconst query2Sql = this.transformToSql(query.query2, context);\\r\\n\\r\\n\\t\\treturn `(${query1Sql}) UNION (${query2Sql})`;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformValuesQueryToSql(query: ValuesQuery<any>, context: Context): string {\\r\\n\\t\\tconst columns = query.columns;\\r\\n\\r\\n\\t\\tif (query.values.length === 0) {\\r\\n\\t\\t\\treturn `SELECT ${Object.keys(columns).map(k => \\\"null\\\").join(\\\", \\\")} WHERE false`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tlet sql = \\\"VALUES \\\";\\r\\n\\r\\n\\t\\tconst expressionContext: ExpressionContext = { isColumnNameUnambigous: c => true, resolveNamedExpression: true, context };\\r\\n\\r\\n\\t\\tsql += query.values.map(v =>\\r\\n\\t\\t\\t`(${objectEntries(columns).map(([name, type]) => this.escapeValue(new Exprs.ValueExpression(type, v[name]), expressionContext)).join(\\\", \\\")})`\\r\\n\\t\\t).join(\\\", \\\");\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformInsertQueryToSql(query: InsertQuery<any, any, any>, context: Context): string {\\r\\n\\t\\tconst data = query.getState();\\r\\n\\t\\tlet sql = `INSERT INTO ${this.referToFromItem(data.table)}`;\\r\\n\\r\\n\\t\\tconst expressionContext: ExpressionContext = { isColumnNameUnambigous: c => true, resolveNamedExpression: true, context };\\r\\n\\r\\n\\t\\tif (Array.isArray(data.values)) {\\r\\n\\t\\t\\tif (data.values.length === 0) {\\r\\n\\t\\t\\t\\tsql += ` (SELECT null WHERE false)`;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tconst firstRow = data.values[0];\\r\\n\\t\\t\\t\\tconst columnNames = Object.keys(firstRow);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfor (const selectedCol of columnNames) {\\r\\n\\t\\t\\t\\t\\tif (!(selectedCol in data.table.$columns))\\r\\n\\t\\t\\t\\t\\t\\tthrow new Error(`Column '${selectedCol}' does not exist on table '${data.table}'.`);\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tsql += `(${columnNames.map(c => this.quoteColumnName(c)).join(\\\", \\\")}) VALUES `;\\r\\n\\t\\t\\t\\tsql += data.values.map(v => `(${columnNames.map(colName => \\r\\n\\t\\t\\t\\t\\tthis.escapeValue(Exprs.val(v[colName], data.table.$columns[colName].type), expressionContext)).join(\\\", \\\")})`).join(\\\", \\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tconst s = data.values.getState();\\r\\n\\t\\t\\tconst columnNames = s.selected.map(selectedCol => {\\r\\n\\t\\t\\t\\tif (selectedCol instanceof Exprs.AllExpression)\\r\\n\\t\\t\\t\\t\\tthrow new Error(\\\"AllExpressions in insert into query are not supported.\\\");\\r\\n\\t\\t\\t\\tif (!(selectedCol.name in data.table.$columns))\\r\\n\\t\\t\\t\\t\\tthrow new Error(`Column '${selectedCol.name}' does not exist on table '${data.table}'.`);\\r\\n\\t\\t\\t\\treturn selectedCol.name;\\r\\n\\t\\t\\t});\\r\\n\\r\\n\\t\\t\\tsql += `(${columnNames.map(c => this.quoteColumnName(c)).join(\\\", \\\")}) ${this.transformToSql(data.values, context)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.selected.length > 0) {\\r\\n\\t\\t\\tsql += \\\" RETURNING \\\" + this.toSelectStatementStr(data.selected, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformDeleteQueryToSql(query: DeleteQuery<any, any, any>, context: Context): string {\\r\\n\\t\\tconst data = query.getState();\\r\\n\\t\\tlet sql = `DELETE FROM ${this.referToFromItem(data.table)}`;\\r\\n\\r\\n\\t\\tconst expressionContext = this.createExpressionContext([data.using, data.table], context);\\r\\n\\r\\n\\t\\tif (data.using) {\\r\\n\\t\\t\\tsql += ` USING ${this.fromToSql(data.using, expressionContext)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!data.whereCondition) throw new Error(\\\"Delete Queries must have a where condition.\\\");\\r\\n\\t\\tsql += ` WHERE ${this.expressionToSql(data.whereCondition, expressionContext)}`;\\r\\n\\r\\n\\t\\tif (data.selected.length > 0) {\\r\\n\\t\\t\\tsql += \\\" RETURNING \\\" + this.toSelectStatementStr(data.selected, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformUpdateQueryToSql(query: UpdateQuery<any, any, any, any>, context: Context): string {\\r\\n\\t\\tconst data = query.getState();\\r\\n\\t\\tlet sql = `UPDATE ${this.referToFromItem(data.table)}`;\\r\\n\\r\\n\\t\\tconst expressionContext = this.createExpressionContext([data.from, data.table], context);\\r\\n\\r\\n\\t\\tsql += \\\" SET \\\" + objectEntries(data.updatedColumns).map(([name, value]: [string, Exprs.Expression<any>]) =>\\r\\n\\t\\t\\t`${this.quoteColumnName(name)} = ${this.expressionToSql(value, expressionContext)}`\\r\\n\\t\\t).join(\\\", \\\");\\r\\n\\r\\n\\t\\tif (data.from) {\\r\\n\\t\\t\\tsql += ` FROM ${this.fromToSql(data.from, expressionContext)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!data.whereCondition) throw new Error(\\\"Update Queries must have a where condition.\\\");\\r\\n\\t\\tsql += ` WHERE ${this.expressionToSql(data.whereCondition, expressionContext)}`;\\r\\n\\r\\n\\t\\tif (data.selected.length > 0) {\\r\\n\\t\\t\\tsql += \\\" RETURNING \\\" + this.toSelectStatementStr(data.selected, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformSelectQueryToSql(query: SelectQuery<any, any, any>, context: Context): string {\\r\\n\\t\\tconst data = query.getState();\\r\\n\\t\\tlet sql = \\\"SELECT\\\";\\r\\n\\r\\n\\t\\tconst expressionContext = this.createExpressionContext([data.from], context);\\r\\n\\r\\n\\t\\tif (data.selected.length > 0) {\\r\\n\\t\\t\\tsql += \\\" \\\" + this.toSelectStatementStr(data.selected, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.from) {\\r\\n\\t\\t\\tsql += ` FROM ${this.fromToSql(data.from, expressionContext)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.whereCondition) {\\r\\n\\t\\t\\tsql += ` WHERE ${this.expressionToSql(data.whereCondition, expressionContext)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.groupBys.length > 0) {\\r\\n\\t\\t\\tconst exprCt = { isColumnNameUnambigous: expressionContext.isColumnNameUnambigous, resolveNamedExpression: false, context: context };\\r\\n\\t\\t\\tconst statements = data.groupBys.map(e => this.expressionToSql(e, exprCt)).join(\\\", \\\");\\r\\n\\t\\t\\tsql += ` GROUP BY ${statements}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.havingCondition) {\\r\\n\\t\\t\\tconst havingCondition = this.expressionToSql(data.havingCondition,\\r\\n\\t\\t\\t\\t{ isColumnNameUnambigous: expressionContext.isColumnNameUnambigous, resolveNamedExpression: true, context: context });\\r\\n\\t\\t\\tsql += ` HAVING ${havingCondition}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.orderBys.length > 0) {\\r\\n\\t\\t\\tsql += \\\" ORDER BY \\\" + data.orderBys.map(d => isOrderingAsc(d) ? this.expressionToSql(d.asc, expressionContext) : (this.expressionToSql(d.desc, expressionContext) + \\\" DESC\\\"));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.limit) {\\r\\n\\t\\t\\tsql += \\\" LIMIT \\\" + this.expressionToSql(data.limit, expressionContext);\\r\\n\\t\\t}\\r\\n\\t\\tif (data.offset) {\\r\\n\\t\\t\\tsql += \\\" OFFSET \\\" + this.expressionToSql(data.offset, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected toSelectStatementStr(selected: (Exprs.NamedExpression<string, AnyType> | Exprs.AllExpression<object>)[], context: ExpressionContext): string {\\r\\n\\t\\treturn selected.map(expr => {\\r\\n\\t\\t\\tif (expr instanceof Exprs.NamedExpressionWrapper) {\\r\\n\\t\\t\\t\\treturn `${this.expressionToSql(expr.expression, context)} AS ${this.quoteColumnName(expr.name)}`;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn this.expressionToSql(expr, context);\\r\\n\\t\\t}).join(\\\", \\\");\\r\\n\\t}\\r\\n\\r\\n\\tprotected quoteSchemaName(name: string): string {\\r\\n\\t\\treturn this.quoteSchemaOrTableOrColumnName(name);\\r\\n\\t}\\r\\n\\r\\n\\tprotected quoteTableName(name: string): string {\\r\\n\\t\\treturn this.quoteSchemaOrTableOrColumnName(name);\\r\\n\\t}\\r\\n\\r\\n\\tprotected quoteColumnName(name: string): string {\\r\\n\\t\\treturn this.quoteSchemaOrTableOrColumnName(name);\\r\\n\\t}\\r\\n\\r\\n\\tprotected abstract quoteSchemaOrTableOrColumnName(name: string): string;\\r\\n\\r\\n\\tprotected referToFromItem(fromItem: FromItem<any>, includeSchema: boolean = true): string {\\r\\n\\t\\tif (fromItem instanceof Table) {\\r\\n\\t\\t\\tlet result = \\\"\\\";\\r\\n\\t\\t\\tif (fromItem.$name.schema && includeSchema) result += this.quoteSchemaName(fromItem.$name.schema) + \\\".\\\";\\r\\n\\t\\t\\tresult += this.quoteTableName(fromItem.$name.name);\\r\\n\\t\\t\\treturn result;\\r\\n\\t\\t}\\r\\n\\t\\telse if (fromItem instanceof NamedFromItem || fromItem instanceof QueryFromItem) {\\r\\n\\t\\t\\treturn this.quoteTableName(fromItem.$name);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthrow \\\"Unsupported\\\";\\r\\n\\t}\\r\\n\\r\\n\\tprivate fromFactorDispatcherInitialized = false;\\r\\n\\tprivate fromFactorDispatcher = new DynamicDispatcher<FromFactor, ExpressionContext, string>();\\r\\n\\r\\n\\tprivate fromToSql(f: FromFactor, context: ExpressionContext): string {\\r\\n\\t\\tif (!this.fromFactorDispatcherInitialized) {\\r\\n\\t\\t\\tthis.fromFactorDispatcherInitialized = true;\\r\\n\\r\\n\\t\\t\\tthis.fromFactorDispatcher\\r\\n\\t\\t\\t\\t.register(Table, (f, context) => {\\r\\n\\t\\t\\t\\t\\treturn this.referToFromItem(f);\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(NamedFromItem, (f, context) => {\\r\\n\\t\\t\\t\\t\\tconst oldName = this.referToFromItem(f.fromItem);\\r\\n\\t\\t\\t\\t\\tconst newName = this.referToFromItem(f);\\r\\n\\r\\n\\t\\t\\t\\t\\tlet sql = `${oldName} AS ${newName}`;\\r\\n\\t\\t\\t\\t\\tif (isCastToColumns(f))\\r\\n\\t\\t\\t\\t\\t\\tsql += `(${Object.keys(f.$columns).join(\\\", \\\")})`;\\r\\n\\t\\t\\t\\t\\treturn sql;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(QueryFromItem, (f, context) => {\\r\\n\\t\\t\\t\\t\\tconst newName = this.referToFromItem(f);\\r\\n\\r\\n\\t\\t\\t\\t\\tlet sql = `(${this.transformToSql(f.query, context.context)}) AS ${newName}`;\\r\\n\\t\\t\\t\\t\\tif (isCastToColumns(f))\\r\\n\\t\\t\\t\\t\\t\\tsql += `(${Object.keys(f.$columns).join(\\\", \\\")})`;\\r\\n\\t\\t\\t\\t\\treturn sql;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(FromFactorAbstractJoin, (f, context) => {\\r\\n\\t\\t\\t\\t\\tconst left = this.fromToSql(f.leftArg, context);\\r\\n\\t\\t\\t\\t\\tconst right = this.fromToSql(f.rightArg, context);\\r\\n\\r\\n\\t\\t\\t\\t\\tlet sql: string;\\r\\n\\t\\t\\t\\t\\tif (f instanceof FromFactorAbstractConditionalJoin) {\\r\\n\\t\\t\\t\\t\\t\\tconst condition = this.expressionToSql(f.joinCondition, context);\\r\\n\\t\\t\\t\\t\\t\\tlet join: string;\\r\\n\\t\\t\\t\\t\\t\\tif (f instanceof FromFactorCrossJoin)\\r\\n\\t\\t\\t\\t\\t\\t\\tjoin = \\\"CROSS JOIN\\\";\\r\\n\\t\\t\\t\\t\\t\\telse if (f instanceof FromFactorFullJoin)\\r\\n\\t\\t\\t\\t\\t\\t\\tjoin = \\\"FULL JOIN\\\";\\r\\n\\t\\t\\t\\t\\t\\telse if (f instanceof FromFactorInnerJoin)\\r\\n\\t\\t\\t\\t\\t\\t\\tjoin = \\\"JOIN\\\";\\r\\n\\t\\t\\t\\t\\t\\telse if (f instanceof FromFactorLeftJoin)\\r\\n\\t\\t\\t\\t\\t\\t\\tjoin = \\\"LEFT JOIN\\\";\\r\\n\\t\\t\\t\\t\\t\\telse throw new Error(\\\"Unsupported join\\\");\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn `${left} ${join} ${right} ON ${condition}`;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\telse if (f instanceof FromFactorCrossJoin) {\\r\\n\\t\\t\\t\\t\\t\\treturn `${left} CROSS JOIN ${right}`;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\telse throw new Error(\\\"Unknown join.\\\");\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.fromFactorDispatcher.dispatch(f, context);\\r\\n\\t}\\r\\n\\r\\n\\tprotected escapeValue(expr: Exprs.ValueExpression<AnyType>, context: ExpressionContext): string {\\r\\n\\t\\tconst val = expr.value;\\r\\n\\t\\tconst serialized = expr.type.serialize(val);\\r\\n\\r\\n\\t\\tcontext.context.parameters.push(serialized);\\r\\n\\t\\treturn \\\"?\\\";\\r\\n\\t}\\r\\n\\r\\n\\tprivate expressionToSql(e: Exprs.Expression<AnyType>, context: ExpressionContext, parentPrecedenceLevel: number = 1000): string {\\r\\n\\t\\tconst result = this.expressionToSqlAutoParenthesis(e, context);\\r\\n\\t\\tif (e.precedenceLevel > parentPrecedenceLevel)\\r\\n\\t\\t\\treturn `(${result})`;\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n\\tprivate expressionDispatcherInitialized = false;\\r\\n\\tprivate expressionDispatcher = new DynamicDispatcher<Exprs.Expression<AnyType>, ExpressionContext, string>();\\r\\n\\r\\n\\tprivate expressionToSqlAutoParenthesis(e: Exprs.Expression<AnyType>, context: ExpressionContext): string {\\r\\n\\t\\tif (!this.expressionDispatcherInitialized) {\\r\\n\\t\\t\\tthis.expressionDispatcherInitialized = true;\\r\\n\\r\\n\\t\\t\\tthis.expressionDispatcher\\r\\n\\t\\t\\t\\t.register(Exprs.NamedExpressionWrapper, (e, context) => {\\r\\n\\t\\t\\t\\t\\tif (context.resolveNamedExpression)\\r\\n\\t\\t\\t\\t\\t\\treturn this.expressionToSql(e.expression, context);\\r\\n\\t\\t\\t\\t\\telse\\r\\n\\t\\t\\t\\t\\t\\treturn this.quoteColumnName(e.name);\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.ValueExpression, (e, context) => this.escapeValue(e, context))\\r\\n\\t\\t\\t\\t.register(Exprs.Column, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst columnName = this.quoteColumnName(e.name);\\r\\n\\t\\t\\t\\t\\tif (context.isColumnNameUnambigous(e.name))\\r\\n\\t\\t\\t\\t\\t\\treturn columnName;\\r\\n\\r\\n\\t\\t\\t\\t\\tconst tableName = this.referToFromItem(e.fromItem);\\r\\n\\t\\t\\t\\t\\treturn `${tableName}.${columnName}`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.FromItemExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst tableName = this.referToFromItem(e.fromItem, false);\\r\\n\\t\\t\\t\\t\\treturn tableName;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.AllExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst tableName = this.referToFromItem(e.fromItem);\\r\\n\\t\\t\\t\\t\\treturn `${tableName}.*`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.BinaryOperatorExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst operator = e.operator;\\r\\n\\r\\n\\t\\t\\t\\t\\tconst left = this.expressionToSql(e.left, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\tconst right = this.expressionToSql(e.right, context, e.precedenceLevel);\\r\\n\\r\\n\\t\\t\\t\\t\\treturn `${left} ${operator} ${right}`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.KnownFunctionInvocation, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst functionName = e.functionName.toUpperCase();\\r\\n\\t\\t\\t\\t\\tconst args = e.args.map(arg => this.expressionToSql(arg, context)).join(\\\", \\\");\\r\\n\\t\\t\\t\\t\\treturn `${functionName}(${args})`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.RetrievalQueryAsExpression, (e, context) => `(${this.transformToSql(e.query, context.context)})`)\\r\\n\\t\\t\\t\\t.register(Exprs.IsInValuesExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tif (e.values.length === 0)\\r\\n\\t\\t\\t\\t\\t\\treturn this.expressionToSql(Exprs.val(false, true), context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} IN (${e.values.map(v => this.expressionToSql(v, context)).join(\\\", \\\")})`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.IsInQueryExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} IN (${this.transformToSql(e.query, context.context)})`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.LikeExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} LIKE ${this.expressionToSql(e.like, context, e.precedenceLevel)}`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.NotExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `NOT ${arg}`\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.IsNullExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} IS NULL`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.IsNotNullExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} IS NOT NULL`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.JsonPropertyAccess, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.expression, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg}->${this.escapeValue(Exprs.val(e.key, true), context)}`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.CastExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\treturn this.expressionToSql(e.expression, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.expressionDispatcher.dispatch(e, context);\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/SqlGenerator.ts\n// module id = 272\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/SqlGenerator.ts?./~/raw-loader");

/***/ }),

/***/ 273:
/***/ (function(module, exports) {

eval("module.exports = \"export * from \\\"./AST/Expressions\\\";\\r\\nexport * from \\\"./AST/Ordering\\\";\\r\\nexport * from \\\"./AST/Table\\\";\\r\\nexport * from \\\"./AST/FromFactor\\\";\\r\\nexport * from \\\"./AST/Types\\\";\\r\\n\\r\\nexport * from \\\"./AST/Queries/Query\\\";\\r\\nexport * from \\\"./AST/Queries/RetrievalQuery\\\";\\r\\nexport * from \\\"./AST/Queries/SelectQuery\\\";\\r\\nexport * from \\\"./AST/Queries/ValuesQuery\\\";\\r\\nexport * from \\\"./AST/Queries/InsertQuery\\\";\\r\\nexport * from \\\"./AST/Queries/UpdateQuery\\\";\\r\\nexport * from \\\"./AST/Queries/DeleteQuery\\\";\\r\\n\\r\\nexport * from \\\"./DbConnection\\\";\\r\\nexport * from \\\"./SqlGenerator\\\";\\r\\n\\r\\nexport * from \\\"./Adapters/Postgre\\\";\\r\\nexport * from \\\"./Adapters/PostgreSqlGenerator\\\";\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/index.ts\n// module id = 273\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/index.ts?./~/raw-loader");

/***/ }),

/***/ 274:
/***/ (function(module, exports) {

eval("module.exports = \"\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/main.d.ts\n// module id = 274\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/main.d.ts?./~/raw-loader");

/***/ }),

/***/ 275:
/***/ (function(module, exports) {

eval("module.exports = \"import { select, from, val, table, tText, tInteger, tJson, jsonVal, concat, deleteFrom, insertInto, values, update } from \\\"hediet-typed-sql\\\";\\r\\n\\r\\n// table definitions.\\r\\nconst organizations = table(\\\"organizations\\\",\\r\\n\\t{ name: tText, parentOrganizationId: tInteger, },\\r\\n\\t{ id: tInteger }\\r\\n);\\r\\n\\r\\nconst customers = table({ name: \\\"customers\\\", schema: \\\"public\\\" },\\r\\n\\t{ firstname: tText, lastname: tText, country: tText, data: tJson<{ key: string }>() },\\r\\n\\t{ id: tInteger }\\r\\n);\\r\\n\\r\\nconst orders = table({ name: \\\"orders\\\", schema: \\\"public\\\" },\\r\\n\\t{ customerId: tInteger, orderDate: tText },\\r\\n\\t{ id: tInteger }\\r\\n);\\r\\n\\r\\n// Select all columns from customers.\\r\\nfrom(customers).select(customers.$all);\\r\\n\\r\\nfrom(customers).select(concat(customers.firstname, \\\" \\\", customers.lastname).as(\\\"fullname\\\"));\\r\\n\\r\\nfrom(customers).select(\\\"firstname\\\").where({ id: 1 });\\r\\n\\r\\nfrom(customers).select(\\\"id\\\").where(customers.firstname.toLower().isLike(\\\"h%\\\"));\\r\\n\\r\\nfrom(customers).select(customers.$all).where(customers.id.isIn([1, 2]));\\r\\n\\r\\nfrom(customers).select(customers.$all).where(customers.id.isInQuery(\\r\\n\\tfrom(orders).select(orders.customerId)\\r\\n));\\r\\n\\r\\nfrom(orders).leftJoin(customers).on({ id: orders.id })\\r\\n\\t.select(customers.$all)\\r\\n\\t.select(orders.asExpression().toJson().as(\\\"order\\\"))\\r\\n\\r\\n// Simple Join:\\r\\nfrom(orders)\\r\\n\\t.leftJoin(customers).on({ id: orders.customerId })\\r\\n\\t.select(orders.id, customers.lastname);\\r\\n\\r\\n// Self Join:\\r\\nconst parentOrg = organizations.as(\\\"parent\\\");\\r\\nfrom(organizations)\\r\\n\\t.leftJoin(parentOrg).on({ parentOrganizationId: organizations.id })\\r\\n\\t.select(organizations.name.as(\\\"name\\\"), parentOrg.name.as(\\\"parentName\\\"));\\r\\n\\r\\n// Join with group by:\\r\\nfrom(orders).leftJoin(customers).on({ id: orders.customerId }).groupBy(customers.country).select(customers.$all.count().as(\\\"count\\\"));\\r\\n\\r\\n\\r\\n// Update\\r\\nupdate(orders).set({ id: 0 }).where({ id: 10 });\\r\\n\\r\\n// Insert\\r\\ninsertInto(customers).value({ firstname: \\\"John\\\", lastname: \\\"Doe\\\", country: \\\"de\\\", data: { key: \\\"123\\\" } });\\r\\n\\r\\ninsertInto(customers).valuesFrom(from(customers).select(val(\\\"de\\\").as(\\\"country\\\"), jsonVal({ key: \\\"test\\\" }).as(\\\"data\\\")).select(\\\"firstname\\\", \\\"lastname\\\"));\\r\\n\\r\\n// Delete\\r\\ndeleteFrom(orders).where({ id: 0 });\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./src/content.ts\n// module id = 275\n// module chunks = 1\n\n//# sourceURL=webpack:///./src/content.ts?./~/raw-loader");

/***/ }),

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FromFactor_1 = __webpack_require__(18);\r\nvar Expressions_1 = __webpack_require__(13);\r\nvar Helpers_1 = __webpack_require__(15);\r\nvar Query = (function () {\r\n    function Query() {\r\n        this.returningColumns = {};\r\n        this.selectedExpressions = [];\r\n        this._isWithRecursive = false;\r\n        this._withItems = [];\r\n    }\r\n    Object.defineProperty(Query.prototype, \"singleColumn\", {\r\n        /**\r\n         * Returns `NoColumnsSelected` if no columns are selected,\r\n         * `MoreThanOneColumnSelected` if more than one columns are selected or\r\n         * the name of the column if exactly one column is selected.\r\n         */\r\n        get: function () {\r\n            var first = this.selectedExpressions[0];\r\n            if (this.selectedExpressions.length === 1 && !(first instanceof Expressions_1.AllExpression))\r\n                return first.name;\r\n            return undefined;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Query.prototype.getState = function () {\r\n        return {\r\n            isWithRecursive: this._isWithRecursive,\r\n            withItems: this._withItems,\r\n            selected: this.selectedExpressions,\r\n            returningColumns: this.returningColumns\r\n        };\r\n    };\r\n    Query.prototype.as = function (name, columns) {\r\n        var newColumns = {};\r\n        var setters = [];\r\n        var castToColumns;\r\n        if (!columns) {\r\n            castToColumns = false;\r\n            for (var _i = 0, _a = Helpers_1.objectValues(this.returningColumns); _i < _a.length; _i++) {\r\n                var nmdExpr = _a[_i];\r\n                newColumns[nmdExpr.name] = new Expressions_1.ColumnBoundToExpression(nmdExpr, function (setter) { return setters.push(setter); });\r\n            }\r\n        }\r\n        else {\r\n            castToColumns = true;\r\n            for (var _b = 0, _c = Helpers_1.objectEntries(columns); _b < _c.length; _b++) {\r\n                var _d = _c[_b], name_1 = _d[0], type = _d[1];\r\n                newColumns[name_1] = new Expressions_1.AsColumn(name_1, type, function (setter) { return setters.push(setter); });\r\n            }\r\n        }\r\n        var fromItem = new FromFactor_1.QueryFromItem(name, newColumns, this, castToColumns);\r\n        for (var _e = 0, setters_1 = setters; _e < setters_1.length; _e++) {\r\n            var setter = setters_1[_e];\r\n            setter(fromItem);\r\n        }\r\n        return fromItem; // fields are set in constructor\r\n    };\r\n    return Query;\r\n}());\r\nexports.Query = Query;\r\n//# sourceMappingURL=Query.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/Query.js\n// module id = 34\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/Query.js?");

/***/ }),

/***/ 35:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Types_1 = __webpack_require__(63);\r\nvar Query_1 = __webpack_require__(34);\r\nvar Expressions_1 = __webpack_require__(13);\r\nvar RetrievalQuery = (function (_super) {\r\n    __extends(RetrievalQuery, _super);\r\n    function RetrievalQuery() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    RetrievalQuery.prototype.getState = function () {\r\n        return Object.assign({\r\n            limit: this._limit,\r\n            offset: this._offset\r\n        }, _super.prototype.getState.call(this));\r\n    };\r\n    /**\r\n     * Sets an limit on how many rows are returned.\r\n     * Overwrites any limit that was set before.\r\n     *\r\n     * @param count The limit.\r\n     */\r\n    RetrievalQuery.prototype.limit = function (count) {\r\n        this._limit = Expressions_1.normalize(Types_1.tInteger, count);\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets how many rows are skipped.\r\n     * Overwrites any offset that was set before.\r\n     *\r\n     * @param count The offset.\r\n     */\r\n    RetrievalQuery.prototype.offset = function (count) {\r\n        this._offset = Expressions_1.normalize(Types_1.tInteger, count);\r\n        return this;\r\n    };\r\n    /**\r\n     * Wraps this query as expression. The query must return exactly one row with exactly one column.\r\n     */\r\n    RetrievalQuery.prototype.asExpression = function () {\r\n        var column = this.returningColumns[this.singleColumn];\r\n        return new Expressions_1.RetrievalQueryAsExpression(this, column.type);\r\n    };\r\n    return RetrievalQuery;\r\n}(Query_1.Query));\r\nexports.RetrievalQuery = RetrievalQuery;\r\nvar UnionQuery = (function (_super) {\r\n    __extends(UnionQuery, _super);\r\n    function UnionQuery(query1, query2) {\r\n        var _this = _super.call(this) || this;\r\n        _this.query1 = query1;\r\n        _this.query2 = query2;\r\n        var s = query1.getState();\r\n        _this.returningColumns = s.returningColumns;\r\n        _this.selectedExpressions = s.selected;\r\n        return _this;\r\n    }\r\n    return UnionQuery;\r\n}(RetrievalQuery));\r\nexports.UnionQuery = UnionQuery;\r\nfunction unionAll(query1) {\r\n    var queries = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        queries[_i - 1] = arguments[_i];\r\n    }\r\n    return queries.reduce(function (p, c) { return new UnionQuery(p, c); }, query1);\r\n}\r\nexports.unionAll = unionAll;\r\n//# sourceMappingURL=RetrievalQuery.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/RetrievalQuery.js\n// module id = 35\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/RetrievalQuery.js?");

/***/ }),

/***/ 374:
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(195);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(373)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./style.scss\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/style.scss\n// module id = 374\n// module chunks = 1\n\n//# sourceURL=webpack:///./src/style.scss?");

/***/ }),

/***/ 380:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// crypto (ignored)\n// module id = 380\n// module chunks = 1\n\n//# sourceURL=webpack:///crypto_(ignored)?");

/***/ }),

/***/ 381:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// util (ignored)\n// module id = 381\n// module chunks = 1\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 382:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// fs (ignored)\n// module id = 382\n// module chunks = 1\n\n//# sourceURL=webpack:///fs_(ignored)?");

/***/ }),

/***/ 383:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// os (ignored)\n// module id = 383\n// module chunks = 1\n\n//# sourceURL=webpack:///os_(ignored)?");

/***/ }),

/***/ 384:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// path (ignored)\n// module id = 384\n// module chunks = 1\n\n//# sourceURL=webpack:///path_(ignored)?");

/***/ }),

/***/ 385:
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(164);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi ./src/index.tsx\n// module id = 385\n// module chunks = 1\n\n//# sourceURL=webpack:///multi_./src/index.tsx?");

/***/ }),

/***/ 46:
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Expressions_1 = __webpack_require__(13);\r\nvar Helpers_1 = __webpack_require__(15);\r\n/**\r\n * If `expression` is a string, it returns the column from `fromItem` that has the name `expression` (or throws an exception).\r\n * Otherwise, it ensures that `expression` is an `Expression` and returns it.\r\n * @private\r\n */\r\nfunction resolveColumnReference(fromItem, expression) {\r\n    if (expression instanceof Expressions_1.Expression)\r\n        return expression;\r\n    if (typeof expression !== \"string\")\r\n        throw new Error(\"Expression must be either of type string or of type Expression, but was '\" + expression + \"'.\");\r\n    if (!fromItem) {\r\n        throw new Error(\"Columns cannot be referenced by string if no table is specified to select from. \"\r\n            + \"Use method 'from' before.\");\r\n    }\r\n    var column = fromItem.$columns[expression];\r\n    if (!column)\r\n        throw new Error(\"Column with name '\" + expression + \"' does not exist on last table that has been specified in from.\");\r\n    return column;\r\n}\r\nexports.resolveColumnReference = resolveColumnReference;\r\n/**\r\n * An helper method for select or returning.\r\n * @private\r\n */\r\nfunction handleSelect(fromItem, selectedExpressions, allReturningColumns, allSelectedExpressions) {\r\n    var normalizedExpressions = selectedExpressions.map(function (arg) { return resolveColumnReference(fromItem, arg); });\r\n    for (var _i = 0, normalizedExpressions_1 = normalizedExpressions; _i < normalizedExpressions_1.length; _i++) {\r\n        var expr = normalizedExpressions_1[_i];\r\n        if (!(expr instanceof Expressions_1.NamedExpression || expr instanceof Expressions_1.AllExpression))\r\n            throw new Error(\"Given argument '\" + expr + \"' must be a named or an all expression.\");\r\n    }\r\n    for (var _a = 0, normalizedExpressions_2 = normalizedExpressions; _a < normalizedExpressions_2.length; _a++) {\r\n        var expr = normalizedExpressions_2[_a];\r\n        for (var _b = 0, _c = (expr instanceof Expressions_1.AllExpression) ? Helpers_1.objectValues(expr.fromItem.$columns) : [expr]; _b < _c.length; _b++) {\r\n            var col = _c[_b];\r\n            allReturningColumns[col.name] = col;\r\n        }\r\n        allSelectedExpressions.push(expr);\r\n    }\r\n}\r\nexports.handleSelect = handleSelect;\r\n//# sourceMappingURL=Common.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/Common.js\n// module id = 46\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/Common.js?");

/***/ }),

/***/ 60:
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction isOrderingAsc(obj) {\r\n    var keys = Object.keys(obj);\r\n    return keys.length === 1 && keys[0] === \"asc\";\r\n}\r\nexports.isOrderingAsc = isOrderingAsc;\r\nfunction isOrderingDesc(obj) {\r\n    var keys = Object.keys(obj);\r\n    return keys.length === 1 && keys[0] === \"desc\";\r\n}\r\nexports.isOrderingDesc = isOrderingDesc;\r\n//# sourceMappingURL=Ordering.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Ordering.js\n// module id = 60\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Ordering.js?");

/***/ }),

/***/ 61:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Expressions_1 = __webpack_require__(13);\r\nvar FromFactor_1 = __webpack_require__(18);\r\nfunction JoinMixin(Base) {\r\n    return (function (_super) {\r\n        __extends(class_1, _super);\r\n        function class_1() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this._from = undefined;\r\n            return _this;\r\n        }\r\n        class_1.prototype.curriedOnJoin = function (ctor) {\r\n            var _this = this;\r\n            return function (joined, condition) {\r\n                if (!_this._from)\r\n                    throw new Error(\"A primary table must be selected before other tables can be joined.\");\r\n                _this._from = new ctor(_this._from, joined, condition);\r\n                return _this;\r\n            };\r\n        };\r\n        class_1.prototype.fullJoin = function (fromItem) {\r\n            return new JoinConditionBuilder(fromItem, this.curriedOnJoin(FromFactor_1.FromFactorFullJoin));\r\n        };\r\n        class_1.prototype.leftJoin = function (fromItem) {\r\n            return new JoinConditionBuilder(fromItem, this.curriedOnJoin(FromFactor_1.FromFactorLeftJoin));\r\n        };\r\n        class_1.prototype.innerJoin = function (fromItem) {\r\n            return new JoinConditionBuilder(fromItem, this.curriedOnJoin(FromFactor_1.FromFactorInnerJoin));\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.JoinMixin = JoinMixin;\r\nvar JoinConditionBuilder = (function () {\r\n    function JoinConditionBuilder(fromItem, onJoin) {\r\n        this.fromItem = fromItem;\r\n        this.onJoin = onJoin;\r\n    }\r\n    JoinConditionBuilder.prototype.on = function () {\r\n        var conditions = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            conditions[_i] = arguments[_i];\r\n        }\r\n        var condition = Expressions_1.toCondition(this.fromItem, conditions);\r\n        if (!condition)\r\n            throw new Error(\"No condition for joined was given.\");\r\n        return this.onJoin(this.fromItem, condition);\r\n    };\r\n    return JoinConditionBuilder;\r\n}());\r\nexports.JoinConditionBuilder = JoinConditionBuilder;\r\n//# sourceMappingURL=JoinMixin.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/JoinMixin.js\n// module id = 61\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/JoinMixin.js?");

/***/ }),

/***/ 62:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Expressions_1 = __webpack_require__(13);\r\nfunction WhereMixin(Base) {\r\n    return (function (_super) {\r\n        __extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.where = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            var expression = Expressions_1.toCondition(this.lastFromItem, args);\r\n            this._whereCondition = Expressions_1.and(this._whereCondition, expression);\r\n            return this;\r\n        };\r\n        class_1.prototype.whereNot = function (condition) {\r\n            var conditions = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                conditions[_i - 1] = arguments[_i];\r\n            }\r\n            this._whereCondition = Expressions_1.and.apply(void 0, [condition.not()].concat(conditions.map(function (c) { return c.not(); })));\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.WhereMixin = WhereMixin;\r\n//# sourceMappingURL=WhereMixin.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/WhereMixin.js\n// module id = 62\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/WhereMixin.js?");

/***/ }),

/***/ 63:
/***/ (function(module, exports) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Type = (function () {\r\n    function Type() {\r\n    }\r\n    Type.prototype.orNull = function () {\r\n        return new NullType(this);\r\n    };\r\n    return Type;\r\n}());\r\nexports.Type = Type;\r\nvar NullType = (function (_super) {\r\n    __extends(NullType, _super);\r\n    function NullType(type) {\r\n        var _this = _super.call(this) || this;\r\n        _this.type = type;\r\n        return _this;\r\n    }\r\n    NullType.prototype.serialize = function (arg) {\r\n        if (arg === null)\r\n            return null;\r\n        return this.type.serialize(arg);\r\n    };\r\n    NullType.prototype.deserialize = function (arg) {\r\n        if (arg === null)\r\n            return null;\r\n        return this.type.deserialize(arg);\r\n    };\r\n    return NullType;\r\n}(Type));\r\nexports.NullType = NullType;\r\nvar VoidType = (function (_super) {\r\n    __extends(VoidType, _super);\r\n    function VoidType() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    VoidType.prototype.serialize = function (arg) { throw new Error(\"Void type does not support serialization\"); };\r\n    VoidType.prototype.deserialize = function (arg) { throw new Error(\"Void type does not support deserialization\"); };\r\n    return VoidType;\r\n}(Type));\r\nexports.VoidType = VoidType;\r\nexports.tVoid = new VoidType();\r\n// let test: RecordTypeToJson2<{ _brand: \"record\", _recordType: { p2: { _brand: \"record\", _recordType: { fooa: { _brand: \"record\", _recordType: { bla: IntegerType } } } } } }> = null!;\r\nfunction tJson() {\r\n    return new Json();\r\n}\r\nexports.tJson = tJson;\r\nvar Json = (function (_super) {\r\n    __extends(Json, _super);\r\n    function Json() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Json.prototype.serialize = function (arg) {\r\n        return JSON.stringify(arg);\r\n    };\r\n    Json.prototype.deserialize = function (arg) {\r\n        if (typeof arg !== \"string\")\r\n            throw new Error(\"Arg must be of type string.\");\r\n        return JSON.parse(arg);\r\n    };\r\n    return Json;\r\n}(Type));\r\nexports.Json = Json;\r\nvar Record = (function (_super) {\r\n    __extends(Record, _super);\r\n    function Record() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Record.prototype.serialize = function (arg) {\r\n        throw \"\";\r\n    };\r\n    Record.prototype.deserialize = function (arg) {\r\n        return arg;\r\n    };\r\n    return Record;\r\n}(Type));\r\nexports.Record = Record;\r\nfunction tRecord() {\r\n    return new Record();\r\n}\r\nexports.tRecord = tRecord;\r\nvar BooleanType = (function (_super) {\r\n    __extends(BooleanType, _super);\r\n    function BooleanType() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    BooleanType.prototype.serialize = function (arg) {\r\n        return arg;\r\n    };\r\n    BooleanType.prototype.deserialize = function (arg) {\r\n        return !!arg;\r\n    };\r\n    return BooleanType;\r\n}(Type));\r\nexports.BooleanType = BooleanType;\r\nexports.tBoolean = new BooleanType();\r\nvar TextType = (function (_super) {\r\n    __extends(TextType, _super);\r\n    function TextType() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    TextType.prototype.serialize = function (arg) {\r\n        return arg;\r\n    };\r\n    TextType.prototype.deserialize = function (arg) {\r\n        return \"\" + arg;\r\n    };\r\n    return TextType;\r\n}(Type));\r\nexports.TextType = TextType;\r\nexports.tText = new TextType();\r\nvar IntegerType = (function (_super) {\r\n    __extends(IntegerType, _super);\r\n    function IntegerType() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    IntegerType.prototype.serialize = function (arg) {\r\n        return arg;\r\n    };\r\n    IntegerType.prototype.deserialize = function (arg) {\r\n        return +arg;\r\n    };\r\n    return IntegerType;\r\n}(Type));\r\nexports.IntegerType = IntegerType;\r\nexports.tInteger = new IntegerType();\r\nvar DateType = (function (_super) {\r\n    __extends(DateType, _super);\r\n    function DateType() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    DateType.prototype.serialize = function (arg) {\r\n        return arg.toString();\r\n    };\r\n    DateType.prototype.deserialize = function (arg) {\r\n        return new Date(\"\" + arg);\r\n    };\r\n    return DateType;\r\n}(Type));\r\nexports.DateType = DateType;\r\nexports.tDate = new DateType();\r\n//# sourceMappingURL=Types.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Types.js\n// module id = 63\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Types.js?");

/***/ }),

/***/ 94:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FromFactor_1 = __webpack_require__(18);\r\nvar Query_1 = __webpack_require__(34);\r\nvar Common_1 = __webpack_require__(46);\r\nvar JoinMixin_1 = __webpack_require__(61);\r\nvar WhereMixin_1 = __webpack_require__(62);\r\nvar Helpers_1 = __webpack_require__(15);\r\n/**\r\n * Creates a DELETE FROM statement.\r\n *\r\n * @param table The table to delete from.\r\n */\r\nfunction deleteFrom(table) {\r\n    return new DeleteQuery(table);\r\n}\r\nexports.deleteFrom = deleteFrom;\r\n/**\r\n * Represents a DELETE FROM query.\r\n */\r\nvar DeleteQuery = (function (_super) {\r\n    __extends(DeleteQuery, _super);\r\n    function DeleteQuery(table) {\r\n        var _this = _super.call(this) || this;\r\n        _this.table = table;\r\n        _this._from = undefined;\r\n        _this.lastFromItem = table;\r\n        return _this;\r\n    }\r\n    DeleteQuery.prototype.getState = function () {\r\n        return Helpers_1.combine(_super.prototype.getState.call(this), {\r\n            table: this.table,\r\n            using: this._from,\r\n            whereCondition: this._whereCondition\r\n        });\r\n    };\r\n    /**\r\n     * Brings an additional query into scope that can be used to specify more complex delete conditions.\r\n     *\r\n     * @param fromItem The query to use.\r\n     */\r\n    DeleteQuery.prototype.using = function (fromItem) {\r\n        this._from = FromFactor_1.FromFactor.crossJoin(this._from, fromItem);\r\n        this.lastFromItem = fromItem;\r\n        return this;\r\n    };\r\n    DeleteQuery.prototype.returning = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        Common_1.handleSelect(this.lastFromItem, args, this.returningColumns, this.selectedExpressions);\r\n        return this;\r\n    };\r\n    return DeleteQuery;\r\n}(JoinMixin_1.JoinMixin(WhereMixin_1.WhereMixin(Query_1.Query))));\r\nexports.DeleteQuery = DeleteQuery;\r\n//# sourceMappingURL=DeleteQuery.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/DeleteQuery.js\n// module id = 94\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/DeleteQuery.js?");

/***/ }),

/***/ 95:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Query_1 = __webpack_require__(34);\r\nvar Common_1 = __webpack_require__(46);\r\nvar Helpers_1 = __webpack_require__(15);\r\n/**\r\n * Creates an INSERT INTO statement.\r\n *\r\n * @param table The table to insert into.\r\n */\r\nfunction insertInto(table) {\r\n    return new InsertQueryBuilder(table);\r\n}\r\nexports.insertInto = insertInto;\r\n/**\r\n * Represents an INSERT INTO statement that needs values.\r\n */\r\nvar InsertQueryBuilder = (function () {\r\n    function InsertQueryBuilder(table) {\r\n        this.table = table;\r\n    }\r\n    /**\r\n     * Inserts one or more items.\r\n     * @param items The items to be inserted.\r\n     */\r\n    InsertQueryBuilder.prototype.value = function () {\r\n        var items = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            items[_i] = arguments[_i];\r\n        }\r\n        return this.values(items);\r\n    };\r\n    /**\r\n     * Inserts an array of items.\r\n     * @param items The items to be inserted.\r\n     */\r\n    InsertQueryBuilder.prototype.values = function (items) {\r\n        return new InsertQuery(this.table, items);\r\n    };\r\n    /**\r\n     * Uses a subquery to retrieve the items to be inserted.\r\n     * @param query A query that returns the items to be inserted.\r\n     */\r\n    InsertQueryBuilder.prototype.valuesFrom = function (query) {\r\n        return new InsertQuery(this.table, query);\r\n    };\r\n    return InsertQueryBuilder;\r\n}());\r\nexports.InsertQueryBuilder = InsertQueryBuilder;\r\n/**\r\n * Represents an INSERT INTO statement.\r\n */\r\nvar InsertQuery = (function (_super) {\r\n    __extends(InsertQuery, _super);\r\n    function InsertQuery(table, values) {\r\n        var _this = _super.call(this) || this;\r\n        _this.table = table;\r\n        _this.values = values;\r\n        return _this;\r\n    }\r\n    InsertQuery.prototype.getState = function () {\r\n        return Helpers_1.combine(_super.prototype.getState.call(this), {\r\n            table: this.table,\r\n            values: this.values\r\n        });\r\n    };\r\n    InsertQuery.prototype.returning = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        Common_1.handleSelect(this.table, args, this.returningColumns, this.selectedExpressions);\r\n        return this;\r\n    };\r\n    return InsertQuery;\r\n}(Query_1.Query));\r\nexports.InsertQuery = InsertQuery;\r\n//# sourceMappingURL=InsertQuery.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/InsertQuery.js\n// module id = 95\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/InsertQuery.js?");

/***/ }),

/***/ 96:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Expressions_1 = __webpack_require__(13);\r\nvar FromFactor_1 = __webpack_require__(18);\r\nvar RetrievalQuery_1 = __webpack_require__(35);\r\nvar Ordering_1 = __webpack_require__(60);\r\nvar Common_1 = __webpack_require__(46);\r\nvar JoinMixin_1 = __webpack_require__(61);\r\nvar WhereMixin_1 = __webpack_require__(62);\r\nvar Helpers_1 = __webpack_require__(15);\r\nvar SelectQuery = (function (_super) {\r\n    __extends(SelectQuery, _super);\r\n    function SelectQuery() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this._from = undefined;\r\n        _this._orderBys = [];\r\n        _this._groupBys = [];\r\n        return _this;\r\n    }\r\n    SelectQuery.prototype.getState = function () {\r\n        return Object.assign({\r\n            orderBys: this._orderBys,\r\n            whereCondition: this._whereCondition,\r\n            havingCondition: this._havingCondition,\r\n            groupBys: this._groupBys,\r\n            from: this._from\r\n        }, _super.prototype.getState.call(this));\r\n    };\r\n    /**\r\n     * Selects from a table. If previous tables are already specified, they are cross joined.\r\n     * @param table The table to select from.\r\n     */\r\n    SelectQuery.prototype.from = function (table) {\r\n        this._from = FromFactor_1.FromFactor.crossJoin(this._from, table);\r\n        this.lastFromItem = table;\r\n        return this;\r\n    };\r\n    SelectQuery.prototype.select = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        Common_1.handleSelect(this.lastFromItem, args, this.returningColumns, this.selectedExpressions);\r\n        return this;\r\n    };\r\n    SelectQuery.prototype.orderBy = function () {\r\n        var _this = this;\r\n        var expressions = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            expressions[_i] = arguments[_i];\r\n        }\r\n        var expressions2 = (function () {\r\n            var firstExpr = expressions[0];\r\n            if (firstExpr && (typeof firstExpr) === \"function\") {\r\n                var expr = firstExpr(_this.returningColumns);\r\n                if (Array.isArray(expr))\r\n                    return expr;\r\n                return [expr];\r\n            }\r\n            return expressions;\r\n        })();\r\n        var exprs = expressions2.map(function (e) {\r\n            if (typeof e === \"string\")\r\n                return Common_1.resolveColumnReference(_this.lastFromItem, e).asc();\r\n            if (e instanceof Expressions_1.Expression)\r\n                return e.asc();\r\n            if (Ordering_1.isOrderingAsc(e))\r\n                return Common_1.resolveColumnReference(_this.lastFromItem, e.asc).asc();\r\n            if (Ordering_1.isOrderingDesc(e))\r\n                return Common_1.resolveColumnReference(_this.lastFromItem, e.desc).desc();\r\n            throw new Error(\"Unexpected value in orderBy: '\" + e + \"'.\");\r\n        });\r\n        (_a = this._orderBys).push.apply(_a, exprs);\r\n        return this;\r\n        var _a;\r\n    };\r\n    SelectQuery.prototype.having = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var expression = undefined;\r\n        if ((typeof args[0]) === \"function\") {\r\n            var func = args[0];\r\n            expression = func(this.returningColumns);\r\n        }\r\n        else\r\n            expression = Expressions_1.toCondition(this.lastFromItem, args);\r\n        this._havingCondition = Expressions_1.and(this._havingCondition, expression);\r\n        return this;\r\n    };\r\n    SelectQuery.prototype.groupBy = function () {\r\n        var _this = this;\r\n        var expressions = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            expressions[_i] = arguments[_i];\r\n        }\r\n        var exprs = (function () {\r\n            var firstExpr = expressions[0];\r\n            if ((typeof firstExpr) === \"function\") {\r\n                var result = firstExpr(_this.returningColumns);\r\n                if (Array.isArray(result))\r\n                    return result;\r\n                return [result];\r\n            }\r\n            else\r\n                return expressions.map(function (e) { return Common_1.resolveColumnReference(_this.lastFromItem, e); });\r\n        })();\r\n        (_a = this._groupBys).push.apply(_a, exprs);\r\n        return this;\r\n        var _a;\r\n    };\r\n    return SelectQuery;\r\n}(JoinMixin_1.JoinMixin(WhereMixin_1.WhereMixin(RetrievalQuery_1.RetrievalQuery))));\r\nexports.SelectQuery = SelectQuery;\r\n/**\r\n * Creates a SELECT query that selects from the given table.\r\n * @param table The table to select from.\r\n */\r\nfunction from(table) {\r\n    var result = new SelectQuery();\r\n    return result.from(table);\r\n}\r\nexports.from = from;\r\nexports.select = Helpers_1.secondWithTypeOfFirst(new SelectQuery().select, function () {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var result = new SelectQuery();\r\n    return (_a = result.select).call.apply(_a, [result].concat(args));\r\n    var _a;\r\n});\r\n//# sourceMappingURL=SelectQuery.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/SelectQuery.js\n// module id = 96\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/SelectQuery.js?");

/***/ }),

/***/ 97:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FromFactor_1 = __webpack_require__(18);\r\nvar Expressions_1 = __webpack_require__(13);\r\nvar Query_1 = __webpack_require__(34);\r\nvar Common_1 = __webpack_require__(46);\r\nvar JoinMixin_1 = __webpack_require__(61);\r\nvar WhereMixin_1 = __webpack_require__(62);\r\nvar Helpers_1 = __webpack_require__(15);\r\nfunction update(table) {\r\n    return new UpdateQuery(table);\r\n}\r\nexports.update = update;\r\nvar UpdateQuery = (function (_super) {\r\n    __extends(UpdateQuery, _super);\r\n    function UpdateQuery(table) {\r\n        var _this = _super.call(this) || this;\r\n        _this._from = undefined;\r\n        _this._updatedColumns = {};\r\n        _this.lastFromItem = table;\r\n        _this._table = table;\r\n        return _this;\r\n    }\r\n    UpdateQuery.prototype.getState = function () {\r\n        return Object.assign({\r\n            whereCondition: this._whereCondition,\r\n            updatedColumns: this._updatedColumns,\r\n            table: this._table,\r\n            from: this._from\r\n        }, _super.prototype.getState.call(this));\r\n    };\r\n    /**\r\n     * Selects from a table. If previous tables are already specified, they are cross joined.\r\n     * These tables can be used to for condition or value expressions.\r\n     * @param table The table to select from.\r\n     */\r\n    UpdateQuery.prototype.from = function (table) {\r\n        this._from = FromFactor_1.FromFactor.crossJoin(this._from, table);\r\n        this.lastFromItem = table;\r\n        return this;\r\n    };\r\n    UpdateQuery.prototype.set = function (columnOrObject, value) {\r\n        if (typeof columnOrObject === \"string\") {\r\n            var column = FromFactor_1.getColumn(this._table, columnOrObject);\r\n            var expr = Expressions_1.normalize(column.type, value);\r\n            this._updatedColumns[columnOrObject] = expr;\r\n        }\r\n        else {\r\n            for (var _i = 0, _a = Helpers_1.objectEntries(columnOrObject); _i < _a.length; _i++) {\r\n                var _b = _a[_i], name_1 = _b[0], value_1 = _b[1];\r\n                var column = FromFactor_1.getColumn(this._table, name_1);\r\n                var expr = Expressions_1.normalize(column.type, value_1);\r\n                this._updatedColumns[name_1] = expr;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    UpdateQuery.prototype.returning = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        Common_1.handleSelect(this.lastFromItem, args, this.returningColumns, this.selectedExpressions);\r\n        return this;\r\n    };\r\n    return UpdateQuery;\r\n}(JoinMixin_1.JoinMixin(WhereMixin_1.WhereMixin(Query_1.Query))));\r\nexports.UpdateQuery = UpdateQuery;\r\n//# sourceMappingURL=UpdateQuery.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/UpdateQuery.js\n// module id = 97\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/UpdateQuery.js?");

/***/ }),

/***/ 98:
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar RetrievalQuery_1 = __webpack_require__(35);\r\nvar Helpers_1 = __webpack_require__(15);\r\nfunction values(columns, items) {\r\n    var values = new ValuesQuery(columns);\r\n    if (items)\r\n        values.withValues(items);\r\n    return values;\r\n}\r\nexports.values = values;\r\nvar ValuesQuery = (function (_super) {\r\n    __extends(ValuesQuery, _super);\r\n    function ValuesQuery(columns) {\r\n        var _this = _super.call(this) || this;\r\n        _this.columns = columns;\r\n        _this.values = [];\r\n        return _this;\r\n    }\r\n    ValuesQuery.prototype.withValues = function (items) {\r\n        (_a = this.values).push.apply(_a, items);\r\n        return this;\r\n        var _a;\r\n    };\r\n    ValuesQuery.prototype.as = function (name) {\r\n        var setters = [];\r\n        var first = this.values[0];\r\n        var columns = Helpers_1.toObject(Helpers_1.objectEntries(this.columns), function (_a) {\r\n            var name = _a[0];\r\n            return name;\r\n        }, function (_a) {\r\n            var name = _a[0], type = _a[1];\r\n            return type;\r\n        });\r\n        return _super.prototype.as.call(this, name, columns);\r\n    };\r\n    return ValuesQuery;\r\n}(RetrievalQuery_1.RetrievalQuery));\r\nexports.ValuesQuery = ValuesQuery;\r\n//# sourceMappingURL=ValuesQuery.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/Queries/ValuesQuery.js\n// module id = 98\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/Queries/ValuesQuery.js?");

/***/ }),

/***/ 99:
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar StartTransactionStatement = (function () {\r\n    function StartTransactionStatement() {\r\n    }\r\n    StartTransactionStatement.prototype.toString = function () { return \"START TRANSACTION\"; };\r\n    return StartTransactionStatement;\r\n}());\r\nexports.StartTransactionStatement = StartTransactionStatement;\r\nvar CommitTransactionStatement = (function () {\r\n    function CommitTransactionStatement() {\r\n    }\r\n    CommitTransactionStatement.prototype.toString = function () { return \"COMMIT\"; };\r\n    return CommitTransactionStatement;\r\n}());\r\nexports.CommitTransactionStatement = CommitTransactionStatement;\r\nvar RollbackTransactionStatement = (function () {\r\n    function RollbackTransactionStatement() {\r\n    }\r\n    RollbackTransactionStatement.prototype.toString = function () { return \"ROLLBACK\"; };\r\n    return RollbackTransactionStatement;\r\n}());\r\nexports.RollbackTransactionStatement = RollbackTransactionStatement;\r\n//# sourceMappingURL=SqlStatement.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../dist/src/AST/SqlStatement.js\n// module id = 99\n// module chunks = 1\n\n//# sourceURL=webpack:///../dist/src/AST/SqlStatement.js?");

/***/ })

},[385]);