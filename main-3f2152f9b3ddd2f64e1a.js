webpackJsonp([1],{

/***/ 145:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar React = __webpack_require__(79);\r\nvar ReactDOM = __webpack_require__(114);\r\nvar mobx_1 = __webpack_require__(107);\r\nvar mobx_react_1 = __webpack_require__(216);\r\n__webpack_require__(349);\r\nvar react_monaco_editor_1 = __webpack_require__(321);\r\nvar ts = __webpack_require__(351);\r\nvar sql = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"../../\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nvar containers_1 = __webpack_require__(146);\r\nvar content = __webpack_require__(250);\r\nvar context = __webpack_require__(147);\r\nvar declarationFiles = {};\r\ncontext.keys().forEach(function (filename) {\r\n    declarationFiles[filename] = context(filename);\r\n});\r\nvar Model = (function () {\r\n    function Model() {\r\n    }\r\n    return Model;\r\n}());\r\n__decorate([\r\n    mobx_1.observable\r\n], Model.prototype, \"windowWidth\", void 0);\r\n__decorate([\r\n    mobx_1.observable\r\n], Model.prototype, \"windowHeight\", void 0);\r\nvar model = new Model();\r\nmodel.windowWidth = window.innerWidth;\r\nmodel.windowHeight = window.innerHeight;\r\nwindow.onresize = function () {\r\n    model.windowWidth = window.innerWidth;\r\n    model.windowHeight = window.innerHeight;\r\n};\r\nvar View = (function (_super) {\r\n    __extends(View, _super);\r\n    function View() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    View.prototype.componentDidMount = function () {\r\n        if (this.props.onHeightUpdate)\r\n            this.props.onHeightUpdate();\r\n    };\r\n    View.prototype.componentDidUpdate = function () {\r\n        if (this.props.onHeightUpdate)\r\n            this.props.onHeightUpdate();\r\n    };\r\n    View.prototype.render = function () {\r\n        var statement = this.props.sqlStatement;\r\n        if (containers_1.isError(statement)) {\r\n            return (React.createElement(\"div\", { className: \"sqlView\" },\r\n                React.createElement(\"span\", { className: \"error\" }, statement.value.error)));\r\n        }\r\n        return (React.createElement(\"div\", { className: \"sqlView\" },\r\n            React.createElement(\"span\", { className: \"sql\" }, statement.value.sql),\r\n            React.createElement(\"span\", { className: \"args\" }, JSON.stringify(statement.value.args))));\r\n    };\r\n    return View;\r\n}(React.Component));\r\nvar SqlViewerZone = (function () {\r\n    function SqlViewerZone(editor, lineNumber, sqlStatement) {\r\n        var _this = this;\r\n        this.editor = editor;\r\n        var d = document.createElement(\"div\");\r\n        var zone = {\r\n            afterLineNumber: lineNumber,\r\n            domNode: d,\r\n            heightInPx: SqlViewerZone.lastHeight,\r\n            suppressMouseDown: false\r\n        };\r\n        console.log(SqlViewerZone.lastHeight);\r\n        editor.changeViewZones(function (accessor) {\r\n            _this.zoneId = accessor.addZone(zone);\r\n        });\r\n        ReactDOM.render(React.createElement(View, { sqlStatement: sqlStatement, onHeightUpdate: function () {\r\n                setTimeout(function () {\r\n                    return;\r\n                    if (!d.childNodes[0] || d.childNodes[0].offsetHeight === 0)\r\n                        return;\r\n                    zone.heightInPx = d.childNodes[0].offsetHeight;\r\n                    SqlViewerZone.lastHeight = zone.heightInPx;\r\n                    editor.changeViewZones(function (accessor) {\r\n                        if (_this.zoneId === -1)\r\n                            throw \"\";\r\n                        accessor.layoutZone(_this.zoneId);\r\n                    });\r\n                }, 50);\r\n            } }), d);\r\n        d.style.zIndex = \"1\";\r\n    }\r\n    SqlViewerZone.prototype.destroy = function () {\r\n        var _this = this;\r\n        this.editor.changeViewZones(function (accessor) {\r\n            accessor.removeZone(_this.zoneId);\r\n        });\r\n    };\r\n    return SqlViewerZone;\r\n}());\r\nSqlViewerZone.lastHeight = 20;\r\nvar GUI = (function (_super) {\r\n    __extends(GUI, _super);\r\n    function GUI() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.zones = [];\r\n        _this.sqlGenerator = new sql.PostgreSqlGenerator({ shortenColumnNameIfUnambigous: true, skipQuotingIfNotRequired: true });\r\n        return _this;\r\n    }\r\n    GUI.prototype.editorDidMount = function (editor) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var m, _i, _a, fileName;\r\n            return __generator(this, function (_b) {\r\n                this.editor = editor;\r\n                editor.setModel(monaco.editor.createModel(content, \"typescript\", monaco.Uri.parse(\"file:///main.ts\")));\r\n                m = editor.getModel();\r\n                monaco.languages.typescript.typescriptDefaults.setCompilerOptions({ moduleResolution: 2 }); // ModuleResolutionKind.NodeJs\r\n                for (_i = 0, _a = Object.keys(declarationFiles); _i < _a.length; _i++) {\r\n                    fileName = _a[_i];\r\n                    monaco.languages.typescript.typescriptDefaults.addExtraLib(declarationFiles[fileName], \"file:///node_modules/hediet-typed-sql/\" + fileName);\r\n                }\r\n                mobx_1.autorun(function () {\r\n                    model.windowWidth + model.windowHeight;\r\n                    console.log(\"layout\");\r\n                    editor.layout();\r\n                });\r\n                this.onChange();\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    GUI.prototype.findSqlQueryExpressions = function (sf) {\r\n        function findSelectExpressions(node, result) {\r\n            for (var _i = 0, _a = node.getChildren(); _i < _a.length; _i++) {\r\n                var n = _a[_i];\r\n                if (n.kind === ts.SyntaxKind.CallExpression) {\r\n                    var n2 = n;\r\n                    var keywords = [\"select\", \"from\", \"values\", \"insertInto\", \"deleteFrom\", \"update\"];\r\n                    if (n2.expression && n2.expression.kind === ts.SyntaxKind.Identifier &&\r\n                        keywords.indexOf(n2.expression.text) !== -1) {\r\n                        var lastParent = n2;\r\n                        var parent = lastParent.parent;\r\n                        console.log(ts.SyntaxKind[parent.kind]);\r\n                        while (parent && ((parent.kind === ts.SyntaxKind.CallExpression && parent.expression === lastParent) ||\r\n                            (parent.kind === ts.SyntaxKind.PropertyAccessExpression) && parent.expression === lastParent)) {\r\n                            lastParent = parent;\r\n                            parent = lastParent.parent;\r\n                        }\r\n                        result.push(lastParent);\r\n                    }\r\n                }\r\n                findSelectExpressions(n, result);\r\n            }\r\n        }\r\n        var result = [];\r\n        findSelectExpressions(sf, result);\r\n        return result;\r\n    };\r\n    GUI.prototype.onChange = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            function define(args, func) {\r\n                func(undefined, {}, sql);\r\n            }\r\n            function log(id, query) {\r\n                try {\r\n                    var q = query();\r\n                    if (!(q instanceof sql.Query))\r\n                        return;\r\n                    var s = self.sqlGenerator.toSql(q);\r\n                    sqlStatements[id] = containers_1.result({ sql: s.sql, args: s.parameters });\r\n                }\r\n                catch (err) {\r\n                    sqlStatements[id] = containers_1.error({ error: err.toString() });\r\n                }\r\n            }\r\n            var m, editor, worker, svc, diags1, diags2, sf, i, exprs, lastStart, src, id, _i, exprs_1, expr, start, self, sqlStatements, scrollTop, _a, _b, zone, _c, exprs_2, expr, endPos, p;\r\n            return __generator(this, function (_d) {\r\n                switch (_d.label) {\r\n                    case 0:\r\n                        m = this.editor.getModel();\r\n                        editor = this.editor;\r\n                        return [4 /*yield*/, monaco.languages.typescript.getTypeScriptWorker()];\r\n                    case 1:\r\n                        worker = _d.sent();\r\n                        return [4 /*yield*/, worker(m.uri.toString())];\r\n                    case 2:\r\n                        svc = _d.sent();\r\n                        return [4 /*yield*/, svc.getSyntacticDiagnostics(m.uri.toString())];\r\n                    case 3:\r\n                        diags1 = _d.sent();\r\n                        return [4 /*yield*/, svc.getSemanticDiagnostics(m.uri.toString())];\r\n                    case 4:\r\n                        diags2 = _d.sent();\r\n                        console.log(svc);\r\n                        if (diags1.length + diags2.length > 0)\r\n                            return [2 /*return*/];\r\n                        sf = ts.createSourceFile(\"main.ts\", m.getValue(), ts.ScriptTarget.ESNext, true, ts.ScriptKind.TS);\r\n                        i = 0;\r\n                        exprs = this.findSqlQueryExpressions(sf);\r\n                        exprs.sort(function (a, b) { return b.end - a.end; }); // descending\r\n                        lastStart = sf.end;\r\n                        src = sf.getText();\r\n                        id = 0;\r\n                        for (_i = 0, exprs_1 = exprs; _i < exprs_1.length; _i++) {\r\n                            expr = exprs_1[_i];\r\n                            id++;\r\n                            start = expr.getStart(sf, false);\r\n                            if (start <= lastStart) {\r\n                                src = src.substring(0, start) + (\"log(\" + id + \", () => (\" + expr.getText(sf) + \"))\") + src.substr(expr.end);\r\n                            }\r\n                            lastStart = start;\r\n                        }\r\n                        src = ts.transpile(src, { module: ts.ModuleKind.AMD });\r\n                        self = this;\r\n                        sqlStatements = {};\r\n                        eval(src);\r\n                        scrollTop = editor.getScrollTop();\r\n                        for (_a = 0, _b = this.zones; _a < _b.length; _a++) {\r\n                            zone = _b[_a];\r\n                            zone.destroy();\r\n                        }\r\n                        this.zones = [];\r\n                        id = 0;\r\n                        for (_c = 0, exprs_2 = exprs; _c < exprs_2.length; _c++) {\r\n                            expr = exprs_2[_c];\r\n                            id++;\r\n                            endPos = expr.getEnd();\r\n                            p = m.getPositionAt(endPos);\r\n                            if (sqlStatements[id])\r\n                                this.zones.push(new SqlViewerZone(editor, p.lineNumber, sqlStatements[id]));\r\n                        }\r\n                        this.editor.setScrollTop(scrollTop);\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GUI.prototype.render = function () {\r\n        return (React.createElement(\"div\", { className: \"page\" },\r\n            React.createElement(\"div\", { className: \"header\" },\r\n                React.createElement(\"h1\", null, \"@hediet/typed-sql - Playground\")),\r\n            React.createElement(\"div\", { className: \"editor\" },\r\n                React.createElement(react_monaco_editor_1.default, { options: { scrollBeyondLastLine: false }, defaultValue: \"\", width: \"100%\", height: \"100%\", language: \"typescript\", editorDidMount: this.editorDidMount.bind(this), onChange: this.onChange.bind(this) }))));\r\n    };\r\n    return GUI;\r\n}(React.Component));\r\nGUI = __decorate([\r\n    mobx_react_1.observer\r\n], GUI);\r\nvar target = document.createElement(\"div\");\r\ntarget.className = \"container\";\r\nReactDOM.render(React.createElement(\"div\", { className: \"container\" },\r\n    React.createElement(GUI, null)), target); //<DevTools />\r\ndocument.body.appendChild(target);\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.tsx\n// module id = 145\n// module chunks = 1\n\n//# sourceURL=webpack:///./src/index.tsx?");

/***/ }),

/***/ 146:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Wrapper {\r\n}\r\nexports.Wrapper = Wrapper;\r\nclass ResultWrapper extends Wrapper {\r\n    constructor(value) {\r\n        super();\r\n        this.value = value;\r\n    }\r\n}\r\nexports.ResultWrapper = ResultWrapper;\r\nclass ErrorWrapper extends Wrapper {\r\n    constructor(value) {\r\n        super();\r\n        this.value = value;\r\n    }\r\n}\r\nexports.ErrorWrapper = ErrorWrapper;\r\nfunction isResult(maybe) {\r\n    return maybe instanceof ResultWrapper;\r\n}\r\nexports.isResult = isResult;\r\nfunction isError(maybe) {\r\n    return maybe instanceof ErrorWrapper;\r\n}\r\nexports.isError = isError;\r\nfunction result(value) {\r\n    return new ResultWrapper(value);\r\n}\r\nexports.result = result;\r\nfunction error(value) {\r\n    return new ErrorWrapper(value);\r\n}\r\nexports.error = error;\r\n//# sourceMappingURL=containers.js.map\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/hediet-framework/api/containers.js\n// module id = 146\n// module chunks = 1\n\n//# sourceURL=webpack:///../~/hediet-framework/api/containers.js?");

/***/ }),

/***/ 147:
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./AST/Expressions.ts\": 227,\n\t\"./AST/FromFactor.ts\": 228,\n\t\"./AST/Ordering.ts\": 229,\n\t\"./AST/Queries/Common.ts\": 230,\n\t\"./AST/Queries/DeleteQuery.ts\": 231,\n\t\"./AST/Queries/InsertQuery.ts\": 232,\n\t\"./AST/Queries/JoinMixin.ts\": 233,\n\t\"./AST/Queries/Query.ts\": 234,\n\t\"./AST/Queries/RetrievalQuery.ts\": 235,\n\t\"./AST/Queries/SelectQuery.ts\": 236,\n\t\"./AST/Queries/UpdateQuery.ts\": 237,\n\t\"./AST/Queries/ValuesQuery.ts\": 238,\n\t\"./AST/Queries/WhereMixin.ts\": 239,\n\t\"./AST/SqlStatement.ts\": 240,\n\t\"./AST/Table.ts\": 241,\n\t\"./AST/Types.ts\": 242,\n\t\"./Adapters/Postgre.ts\": 243,\n\t\"./Adapters/PostgreSqlGenerator.ts\": 244,\n\t\"./DbConnection.ts\": 245,\n\t\"./Helpers.ts\": 246,\n\t\"./SqlGenerator.ts\": 247,\n\t\"./index.ts\": 248,\n\t\"./main.d.ts\": 249\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 147;\n\n//////////////////\n// WEBPACK FOOTER\n// ../src ./~/raw-loader! \\.(ts)$\n// module id = 147\n// module chunks = 1\n\n//# sourceURL=webpack:///_\\.(ts)$?../src_./~/raw-loader");

/***/ }),

/***/ 170:
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(171)();\n// imports\n\n\n// module\nexports.push([module.i, \"html {\\n  height: 100%;\\n  margin: 0; }\\n\\nbody {\\n  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\\n  height: 100%;\\n  margin: 0px;\\n  padding: 10px;\\n  padding-bottom: 25px;\\n  box-sizing: border-box; }\\n\\n.container {\\n  height: 100%;\\n  margin: 0px;\\n  padding: 0px; }\\n\\n.page {\\n  display: flex;\\n  flex-direction: column;\\n  width: 100%;\\n  height: 100%; }\\n\\n.header {\\n  flex-shrink: 1; }\\n\\n.editor {\\n  flex: 1;\\n  overflow: hidden;\\n  padding: 0;\\n  border: 1px solid black; }\\n\\n.sqlView .sql {\\n  font-family: Consolas; }\\n\\n.sqlView .args {\\n  font-family: Consolas;\\n  margin-left: 30px; }\\n\\n.sqlView {\\n  border: black solid 1px;\\n  padding-left: 5px;\\n  background-color: #f2f2f2;\\n  font-size: 14px; }\\n\", \"\"]);\n\n// exports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/sass-loader/lib/loader.js!./src/style.scss\n// module id = 170\n// module chunks = 1\n\n//# sourceURL=webpack:///./src/style.scss?./~/css-loader!./~/sass-loader/lib/loader.js");

/***/ }),

/***/ 227:
/***/ (function(module, exports) {

eval("module.exports = \"import { Ordering } from \\\"./Ordering\\\";\\r\\nimport { FromItem, Row, getColumn } from \\\"./FromFactor\\\";\\r\\nimport { RetrievalQuery } from \\\"./Queries/RetrievalQuery\\\";\\r\\nimport { Table } from \\\"./Table\\\";\\r\\nimport {\\r\\n\\tAnyType,\\r\\n\\tBooleanType,\\r\\n\\tGetInType,\\r\\n\\tIntegerType,\\r\\n\\tJson,\\r\\n\\tRecord,\\r\\n\\tRecordTypeToJson,\\r\\n\\ttBoolean,\\r\\n\\tTextType,\\r\\n\\ttInteger,\\r\\n\\ttJson,\\r\\n\\ttText,\\r\\n\\ttVoid,\\r\\n\\tVoidType,\\r\\n\\tType,\\r\\n\\ttRecord\\r\\n} from './Types';\\r\\n\\r\\nexport type ExpressionTypeOf<T extends Expression<any>> = T[\\\"type\\\"];\\r\\n\\r\\nexport abstract class Expression<T extends AnyType> {\\r\\n\\tpublic readonly type: T;\\r\\n\\r\\n\\tconstructor(type: T) {\\r\\n\\t\\tif (!type || !type.serialize) throw new Error(`No type given: ${type}.`);\\r\\n\\t\\tthis.type = type;\\r\\n\\t}\\r\\n\\r\\n\\tpublic get precedenceLevel(): number { return 0; }\\r\\n\\r\\n\\tpublic cast<T2 extends AnyType>(type: T2): Expression<T2> { return new CastExpression(this, type); }\\r\\n\\tpublic narrow<T2 extends T>(): Expression<T2> { return this as any; }\\r\\n\\r\\n\\tpublic as<TName extends string>(name: TName): NamedExpression<TName, T> {\\r\\n\\t\\treturn new NamedExpressionWrapper<TName, T>(name, this); }\\r\\n\\r\\n\\tpublic isEqualTo(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new EqualsExpression(this, normalize(this.type, other)); }\\r\\n\\tpublic isNotEqualTo(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new UnequalsExpression(this, normalize(this.type, other)); }\\r\\n\\r\\n\\tpublic isLessThan(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new LessExpression(this, normalize(this.type, other)); }\\r\\n\\tpublic isAtMost(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new LessOrEqualExpression(this, normalize(this.type, other)); }\\r\\n\\tpublic isGreaterThan(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new GreaterExpression(this, normalize(this.type, other)); }\\r\\n\\tpublic isAtLeast(other: ExpressionOrInputValue<T>): Expression<BooleanType> {\\r\\n\\t\\treturn new GreaterOrEqualExpression(this, normalize(this.type, other)); }\\r\\n\\r\\n\\tpublic isNull(): Expression<BooleanType> { return new IsNullExpression(this); }\\r\\n\\tpublic isNotNull(): Expression<BooleanType> { return new IsNotNullExpression(this); }\\r\\n\\r\\n\\tpublic and(this: Expression<BooleanType>, other: Expression<BooleanType>): Expression<BooleanType> {\\r\\n\\t\\treturn new AndExpression(this, other); }\\r\\n\\tpublic or(this: Expression<BooleanType>, other: Expression<BooleanType>): Expression<BooleanType> {\\r\\n\\t\\treturn new OrExpression(this, other); }\\r\\n\\r\\n\\tpublic not(this: Expression<BooleanType>): Expression<BooleanType> { return new NotExpression(this); }\\r\\n\\r\\n\\tpublic isIn(values: ExpressionOrInputValue<T>[]): Expression<BooleanType> { return new IsInValuesExpression(this, values.map(v => normalize(this.type, v))); }\\r\\n\\tpublic isInQuery<TRow extends { [name: string]: AnyType }, TSingleColumn extends keyof TRow>(this: Expression<TRow[TSingleColumn]>,\\r\\n\\t\\tvalues: RetrievalQuery<TRow, TSingleColumn>): Expression<BooleanType> { return new IsInQueryExpression(this, values); }\\r\\n\\t\\r\\n\\tpublic minus(this: Expression<IntegerType>, other: ExpressionOrInputValue<IntegerType>): Expression<IntegerType> {\\r\\n\\t\\treturn new SubtractionExpression(this, normalize(tInteger, other)); }\\r\\n\\tpublic plus(this: Expression<IntegerType>, other: ExpressionOrInputValue<IntegerType>): Expression<IntegerType> {\\r\\n\\t\\treturn new AdditionExpression(this, normalize(tInteger, other)); }\\r\\n\\tpublic mult(this: Expression<IntegerType>, other: ExpressionOrInputValue<IntegerType>): Expression<IntegerType> {\\r\\n\\t\\treturn new MultiplicationExpression(this, normalize(tInteger, other)); }\\r\\n\\tpublic div(this: Expression<IntegerType>, other: ExpressionOrInputValue<IntegerType>): Expression<IntegerType> {\\r\\n\\t\\treturn new DivisionExpression(this, normalize(tInteger, other)); }\\r\\n\\r\\n\\tpublic toUpper(this: Expression<TextType>): Expression<TextType> { return new KnownFunctionInvocation(\\\"upper\\\", [this], tText); }\\r\\n\\tpublic toLower(this: Expression<TextType>): Expression<TextType> { return new KnownFunctionInvocation(\\\"lower\\\", [this], tText); }\\r\\n\\r\\n\\tpublic sum(this: Expression<IntegerType>): Expression<IntegerType> { return new KnownFunctionInvocation(\\\"sum\\\", [this], tInteger); }\\r\\n\\tpublic count(this: Expression<any>): Expression<IntegerType> { return new KnownFunctionInvocation(\\\"count\\\", [this], tInteger); }\\r\\n\\r\\n\\tpublic isLike(this: Expression<TextType>, other: ExpressionOrInputValue<TextType>): Expression<BooleanType> { return new LikeExpression(this, normalize(this.type, other)); }\\r\\n\\r\\n\\tpublic asc(): Ordering<Expression<T>> { return { asc: this } };\\r\\n\\tpublic desc(): Ordering<Expression<T>> { return { desc: this } };\\r\\n\\r\\n\\tpublic toJson<TColumns>(this: Expression<Record<TColumns>>): Expression<Json<RecordTypeToJson<Record<TColumns>>>> {\\r\\n\\t\\treturn new KnownFunctionInvocation(\\\"row_to_json\\\", [this], tJson<RecordTypeToJson<Record<TColumns>>>());\\r\\n\\t}\\r\\n\\r\\n\\tpublic prop<TKey extends keyof GetInType<ExpressionTypeOf<this>>>(this: Expression<Json<any>>, key: TKey): Expression<Json<GetInType<ExpressionTypeOf<this>>[TKey]>> {\\r\\n\\t\\treturn new JsonPropertyAccess(this, key);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class CastExpression<T extends AnyType> extends Expression<T> {\\r\\n\\tget precedenceLevel() { return this.expression.precedenceLevel; }\\r\\n\\r\\n\\tconstructor(public readonly expression: Expression<AnyType>, newType: T) {\\r\\n\\t\\tsuper(newType);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class JsonPropertyAccess extends Expression<Json<any>> {\\r\\n\\tconstructor(public readonly expression: Expression<Json<any>>, public readonly key: string) {\\r\\n\\t\\tsuper(tJson());\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class FromItemExpression<T extends Row> extends Expression<Record<T>> {\\r\\n\\tconstructor(public readonly fromItem: FromItem<T>) {\\r\\n\\t\\tsuper(tRecord<T>());\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport function normalize<T extends AnyType>(type: T, expr: ExpressionOrInputValue<T>): Expression<T> {\\r\\n\\tif (expr instanceof Expression) return expr;\\r\\n\\treturn new ValueExpression<T>(type, expr);\\r\\n}\\r\\n\\r\\nexport function not(expression: Expression<BooleanType>): Expression<BooleanType> {\\r\\n\\treturn new NotExpression(expression);\\r\\n}\\r\\n\\r\\nexport function and(expression1: Expression<BooleanType>, ...expressions: Expression<BooleanType>[]): Expression<BooleanType>;\\r\\nexport function and(...expressions: (Expression<BooleanType> | undefined)[]): Expression<BooleanType>|undefined;\\r\\nexport function and(...expressions: (Expression<BooleanType> | undefined)[]): Expression<BooleanType>|undefined {\\r\\n\\treturn expressions\\r\\n\\t\\t.filter(expr => !!expr)\\r\\n\\t\\t.reduce((prev, cur) => prev ? prev.and(cur!) : cur, undefined);\\r\\n}\\r\\n\\r\\nexport function concat(...expressions: ExpressionOrInputValue<TextType>[]): Expression<TextType> {\\r\\n\\treturn new KnownFunctionInvocation(\\\"concat\\\", expressions.map(e => normalize(tText, e)), tText);\\r\\n}\\r\\n\\r\\nexport function coalesce<T extends AnyType>(...expressions: Expression<T>[]): Expression<T> {\\r\\n\\treturn new KnownFunctionInvocation(\\\"coalesce\\\", expressions, expressions[expressions.length - 1].type);\\r\\n}\\r\\n\\r\\nexport function val(value: string, preferEscaping?: boolean): ValueExpression<TextType>;\\r\\nexport function val(value: boolean, preferEscaping?: boolean): ValueExpression<BooleanType>;\\r\\nexport function val(value: number, preferEscaping?: boolean): ValueExpression<IntegerType>;\\r\\nexport function val<T extends AnyType>(value: GetInType<T>, type: T, preferEscaping?: boolean): ValueExpression<T>;\\r\\nexport function val(value: string|boolean|number, ...other: any[]) {\\r\\n\\tlet preferEscaping: boolean;\\r\\n\\tif (other[0] instanceof Type) {\\r\\n\\t\\tpreferEscaping = !!other[1];\\r\\n\\t\\treturn new ValueExpression(other[0], value, preferEscaping);\\r\\n\\t}\\r\\n\\tpreferEscaping = !!other[0];\\r\\n\\r\\n\\tlet t: AnyType;\\r\\n\\tif (typeof value === \\\"string\\\") t = tText;\\r\\n\\telse if (typeof value === \\\"boolean\\\") t = tBoolean;\\r\\n\\telse if (typeof value === \\\"number\\\") t = tInteger;\\r\\n\\telse throw new Error(`Unsupported value: '${value}'.`);\\r\\n\\r\\n\\treturn new ValueExpression(t, value, preferEscaping);\\r\\n}\\r\\n\\r\\nexport function jsonVal<T>(value: T) {\\r\\n\\treturn val(value, tJson<T>());\\r\\n}\\r\\n\\r\\nexport function defaultValue(): DefaultExpression { return new DefaultExpression(); }\\r\\n\\r\\nexport function toCondition<TColumns>(fromItem: FromItem<TColumns>|undefined, args: (Expression<BooleanType>[]) | [ Partial<MapExpressionOrInputValue<TColumns>> ])\\r\\n\\t\\t: Expression<BooleanType>|undefined {\\r\\n\\r\\n\\tconst firstArg = args[0];\\r\\n\\tif (firstArg && !(firstArg instanceof Expression)) {\\r\\n\\t\\tif (typeof firstArg !== \\\"object\\\" || Array.isArray(firstArg)) throw new Error(`Where argument must be an object, but was '${firstArg}'.`);\\r\\n\\r\\n\\t\\treturn and(...Object.keys(firstArg).map(columnName => {\\r\\n\\t\\t\\tconst expression = firstArg[columnName as keyof TColumns];\\r\\n\\t\\t\\tif (!fromItem) throw new Error(\\\"No table to select from specified.\\\");\\r\\n\\t\\t\\tconst column = getColumn(fromItem, columnName);\\r\\n\\t\\t\\treturn column.isEqualTo(expression);\\r\\n\\t\\t}));\\r\\n\\t}\\r\\n\\telse {\\r\\n\\t\\treturn and(...(args as Expression<BooleanType>[]).map((arg, argIdx) => {\\r\\n\\t\\t\\tif (!(arg instanceof Expression))\\r\\n\\t\\t\\t\\tthrow new Error(`Argument at position '${argIdx}' is not of type expression.`);\\r\\n\\t\\t\\treturn arg;\\r\\n\\t\\t}));\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport type NamedExpressionNameOf<T extends NamedExpression<any, any>> = T[\\\"name\\\"];\\r\\n\\r\\nexport class NamedExpression<TColumnName extends string, T extends AnyType> extends Expression<T> {\\r\\n\\tconstructor(public readonly name: TColumnName, type: T) { super(type); }\\r\\n}\\r\\n\\r\\nexport class Column<TColumnName extends string, T extends AnyType> extends NamedExpression<TColumnName, T> {\\r\\n\\tprivate _fromItem: FromItem<any>;\\r\\n\\tpublic get fromItem() { return this._fromItem; }\\r\\n\\r\\n\\tconstructor(name: TColumnName, type: T, fromItemSetterProvider: (setter: (fromItem: FromItem<any>) => void) => void) {\\r\\n\\t\\tsuper(name, type);\\r\\n\\r\\n\\t\\tfromItemSetterProvider(fromItem => this._fromItem = fromItem);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class TableColumn<TColumnName extends string, T extends AnyType> extends Column<TColumnName, T> {\\r\\n\\tconstructor(name: TColumnName, type: T, fromItemSetterProvider: (setter: (fromItem: Table<any, any>) => void) => void) {\\r\\n\\t\\tsuper(name, type, fromItemSetterProvider);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class AsColumn<TColumnName extends string, T extends AnyType> extends Column<TColumnName, T> {\\r\\n\\tconstructor(name: TColumnName, type: T, fromItemSetterProvider: (setter: (fromItem: Table<any, any>) => void) => void) {\\r\\n\\t\\tsuper(name, type, fromItemSetterProvider);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class ColumnBoundToExpression<TColumnName extends string, T extends AnyType> extends Column<TColumnName, T> {\\r\\n\\tconstructor(private readonly expression: NamedExpression<TColumnName, T>, fromItemSetterProvider: (setter: (fromItem: FromItem<any>) => void) => void) {\\r\\n\\t\\tsuper(expression.name, expression.type, fromItemSetterProvider);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class AllExpression<TColumns extends Row> extends Expression<VoidType> {\\r\\n\\tconstructor(public readonly fromItem: FromItem<TColumns>) {\\r\\n\\t\\tsuper(tVoid);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class NamedExpressionWrapper<TColumnName extends string, T extends AnyType> extends NamedExpression<TColumnName, T> {\\r\\n\\tconstructor(name: TColumnName, public readonly expression: Expression<T>) { super(name, expression.type); }\\r\\n}\\r\\n\\r\\n\\r\\nexport class RetrievalQueryAsExpression<T extends AnyType> extends Expression<T> {\\r\\n\\tconstructor(public readonly query: RetrievalQuery<any, any>, type: T) { super(type); }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nexport class ValueExpression<T extends AnyType> extends Expression<T> {\\r\\n\\tconstructor(type: T, public readonly value: GetInType<T>, public readonly preferEscaping: boolean = false) { super(type); }\\r\\n}\\r\\n\\r\\n\\r\\nexport type ExpressionOrInputValue<T extends AnyType> = GetInType<T>|Expression<T>;\\r\\nexport type MapExpressionOrInputValue<T extends { [key: string]: any }> = { [TKey in keyof T]: ExpressionOrInputValue<T[TKey]> };\\r\\n\\r\\nexport class Variable<T extends AnyType> extends Expression<T> {\\r\\n\\tconstructor(public readonly name: string, type: T) { super(type); }\\r\\n}\\r\\n\\r\\nexport abstract class BinaryOperatorExpression<TLeft extends AnyType, TRight extends AnyType, TResult extends AnyType> extends Expression<TResult> {\\r\\n\\tconstructor(\\r\\n\\t\\t\\tpublic readonly left: Expression<TLeft>,\\r\\n\\t\\t\\tpublic readonly right: Expression<TRight>, \\r\\n\\t\\t\\ttype: TResult) {\\r\\n\\r\\n\\t\\tsuper(type);\\r\\n\\t}\\r\\n\\r\\n\\tpublic abstract get operator(): string;\\r\\n}\\r\\n\\r\\nexport interface ConcreteBinaryExpression<TLeft extends AnyType, TRight extends AnyType, TResult extends AnyType> extends BinaryOperatorExpression<TLeft, TRight, TResult> {\\r\\n\\toperator: string;\\r\\n\\tprecedenceLevel: number;\\r\\n}\\r\\nexport interface ConcreteBinaryExpressionStatic<TLeft extends AnyType, TRight extends AnyType, TResult extends AnyType> {\\r\\n\\tnew (...args: any[]): ConcreteBinaryExpression<TLeft, TRight, TResult>;\\r\\n}\\r\\n\\r\\nexport function ConcreteBinaryExpression<TLeft extends AnyType, TRight extends AnyType, TResult extends AnyType>(\\r\\n\\t\\tsymbol: string, resultType: TResult, precedenceLevel: number): ConcreteBinaryExpressionStatic<TLeft, TRight, TResult> {\\r\\n\\treturn class extends BinaryOperatorExpression<TLeft, TRight, TResult> {\\r\\n\\t\\tconstructor(left: Expression<TLeft>, right: Expression<TRight>) { super(left, right, resultType); }\\r\\n\\t\\tpublic get operator(): string { return symbol; }\\r\\n\\t\\tpublic get precedenceLevel(): number { return precedenceLevel; }\\r\\n\\t};\\r\\n}\\r\\n\\r\\nexport class AdditionExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"+\\\", tInteger, 3) {}\\r\\nexport class SubtractionExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"-\\\", tInteger, 3) {}\\r\\nexport class MultiplicationExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"*\\\", tInteger, 2) {}\\r\\nexport class DivisionExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"/\\\", tInteger, 2) {}\\r\\nexport class ModulusExpression extends ConcreteBinaryExpression<IntegerType, IntegerType, IntegerType>(\\\"%\\\", tInteger, 2) {}\\r\\n\\r\\n\\r\\nexport class EqualsExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"=\\\", tBoolean, 4) {}\\r\\nexport class UnequalsExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"!=\\\", tBoolean, 4) {}\\r\\nexport class GreaterExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\">\\\", tBoolean, 4) {}\\r\\nexport class LessExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"<\\\", tBoolean, 4) {}\\r\\nexport class GreaterOrEqualExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\">=\\\", tBoolean, 4) {}\\r\\nexport class LessOrEqualExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"<=\\\", tBoolean, 4) {}\\r\\nexport class NotLessExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"!<\\\", tBoolean, 4) {}\\r\\nexport class NotGreaterExpression<T extends AnyType> extends ConcreteBinaryExpression<T, T, BooleanType>(\\\"!>\\\", tBoolean, 4) {}\\r\\n\\r\\nexport class OrExpression extends ConcreteBinaryExpression<BooleanType, BooleanType, BooleanType>(\\\"OR\\\", tBoolean, 7) {}\\r\\nexport class AndExpression extends ConcreteBinaryExpression<BooleanType, BooleanType, BooleanType>(\\\"AND\\\", tBoolean, 6) {}\\r\\n\\r\\nexport class LikeExpression extends Expression<BooleanType> {\\r\\n\\tpublic get precedenceLevel() { return 7; }\\r\\n\\tconstructor(public readonly argument: Expression<TextType>, public readonly like: Expression<TextType>) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class IsInValuesExpression<T extends AnyType> extends Expression<BooleanType> {\\r\\n\\tpublic get precedenceLevel() { return 7; }\\r\\n\\r\\n\\tconstructor(public readonly argument: Expression<T>, public readonly values: Expression<T>[]) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class IsInQueryExpression<T extends AnyType> extends Expression<BooleanType> {\\r\\n\\tpublic get precedenceLevel() { return 7; }\\r\\n\\r\\n\\tconstructor(public readonly argument: Expression<T>, public readonly query: RetrievalQuery<any, any>) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class IsNullExpression extends Expression<BooleanType> {\\r\\n\\tconstructor(public readonly argument: Expression<any>) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class IsNotNullExpression extends Expression<BooleanType> {\\r\\n\\tconstructor(public readonly argument: Expression<any>) { super(tBoolean); }\\r\\n}\\r\\n\\r\\nexport class NotExpression extends Expression<BooleanType> {\\r\\n\\tpublic get precedenceLevel() { return 5; }\\r\\n\\r\\n\\tconstructor(public readonly argument: Expression<BooleanType>) { super(argument.type); }\\r\\n}\\r\\n\\r\\nexport class KnownFunctionInvocation<TResultType extends AnyType> extends Expression<TResultType> {\\r\\n\\tconstructor(public readonly functionName: string, public readonly args: Expression<any>[], resultType: TResultType) { super(resultType); }\\r\\n}\\r\\n\\r\\nexport class DefaultExpression extends Expression<AnyType> { constructor() { super(tVoid); } }\\r\\n\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Expressions.ts\n// module id = 227\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Expressions.ts?./~/raw-loader");

/***/ }),

/***/ 228:
/***/ (function(module, exports) {

eval("module.exports = \"import { Expression, Column, ColumnBoundToExpression, AllExpression, ExpressionTypeOf, FromItemExpression } from \\\"./Expressions\\\";\\r\\nimport { toObject, objectEntries, objectValues } from \\\"../Helpers\\\";\\r\\nimport { Query } from \\\"./Queries/Query\\\";\\r\\nimport { AnyType, Record, BooleanType } from \\\"./Types\\\";\\r\\n\\r\\nexport interface Row {\\r\\n\\t[name: string]: any;//AnyType;\\r\\n}\\r\\n\\r\\nexport interface Columns {\\r\\n\\t[name: string]: any;//Column<string, AnyType>;\\r\\n}\\r\\n\\r\\nexport type RowToColumns<TColumns extends Row> =\\r\\n\\t{[TName in keyof TColumns]: Column<TName, TColumns[TName]> };\\r\\n\\r\\nexport type ColumnsToRow<TColumns extends Columns>\\r\\n\\t= {[TName in keyof TColumns]: ExpressionTypeOf<TColumns[TName]> };\\r\\n\\r\\nexport class FromFactor {\\r\\n\\t_brand: \\\"FromFactor\\\";\\r\\n\\r\\n\\tpublic static getAllFromFactors(factor: FromFactor): FromItem<any>[] {\\r\\n\\t\\tif (factor instanceof FromItem) return [factor];\\r\\n\\t\\telse if (factor instanceof FromFactorAbstractJoin) {\\r\\n\\t\\t\\treturn FromFactor.getAllFromFactors(factor.leftArg).concat(\\r\\n\\t\\t\\t\\tFromFactor.getAllFromFactors(factor.rightArg)\\r\\n\\t\\t\\t);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthrow new Error(\\\"Unsupported from factor\\\");\\r\\n\\t}\\r\\n\\r\\n\\tpublic static crossJoin(factor1: FromFactor | undefined, factor2: FromFactor | undefined): FromFactor | undefined {\\r\\n\\t\\tif (!factor1) return factor2;\\r\\n\\t\\tif (!factor2) return factor1;\\r\\n\\t\\treturn new FromFactorCrossJoin(factor1, factor2);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport abstract class FromFactorAbstractJoin extends FromFactor {\\r\\n\\tconstructor(public readonly leftArg: FromFactor,\\r\\n\\t\\tpublic readonly rightArg: FromFactor) {\\r\\n\\r\\n\\t\\tsuper();\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport abstract class FromFactorAbstractConditionalJoin extends FromFactorAbstractJoin {\\r\\n\\tconstructor(leftArg: FromFactor, rightArg: FromFactor,\\r\\n\\t\\tpublic readonly joinCondition: Expression<BooleanType>) {\\r\\n\\r\\n\\t\\tsuper(leftArg, rightArg);\\r\\n\\t}\\r\\n\\r\\n\\tpublic abstract getType(): string;\\r\\n}\\r\\n\\r\\nexport class FromFactorLeftJoin extends FromFactorAbstractConditionalJoin { public getType() { return \\\"left\\\"; } };\\r\\nexport class FromFactorFullJoin extends FromFactorAbstractConditionalJoin { public getType() { return \\\"full\\\"; } };\\r\\nexport class FromFactorInnerJoin extends FromFactorAbstractConditionalJoin { public getType() { return \\\"inner\\\"; } };\\r\\nexport class FromFactorCrossJoin extends FromFactorAbstractJoin { public getType() { return \\\"cross\\\"; } };\\r\\n\\r\\nexport type FromItemToRow<TFromItem extends FromItem<any>> =\\r\\n\\t{[TName in keyof TFromItem[\\\"$columns\\\"]]: ExpressionTypeOf<TFromItem[\\\"$columns\\\"][TName]> };\\r\\n\\r\\nexport abstract class FromItem<TColumns extends Row> extends FromFactor {\\r\\n\\tpublic readonly $columns: RowToColumns<TColumns>;\\r\\n\\tpublic readonly $all: AllExpression<TColumns> = new AllExpression(this);\\r\\n\\r\\n\\tconstructor(columns: RowToColumns<TColumns>, private readonly castToColumns: boolean) {\\r\\n\\t\\tsuper();\\r\\n\\t\\tthis.$columns = columns;\\r\\n\\r\\n\\t\\tfor (const [name, col] of objectEntries(columns)) {\\r\\n\\t\\t\\tif (!(name in this))\\r\\n\\t\\t\\t\\t(this as any)[name] = col;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tpublic as(name: string): FromItemCtor<TColumns> {\\r\\n\\t\\tconst setters: ((fromItem: FromItem<any>) => void)[] = [];\\r\\n\\t\\tconst columns = objectValues(this.$columns)\\r\\n\\t\\t\\t.map((col: Column<any, any>) => new ColumnBoundToExpression(col, s => setters.push(s)));\\r\\n\\t\\tconst result = new NamedFromItem<TColumns>(name, toObject(columns, c => c.name), this, false) as any;\\r\\n\\t\\tfor (const s of setters) s(result);\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n\\tpublic asNullable(): FromItemCtor<{[TKey in keyof TColumns]: TColumns[TKey] | null }> {\\r\\n\\t\\treturn this as any;\\r\\n\\t}\\r\\n\\r\\n\\tpublic asExpression(): Expression<Record<TColumns>> {\\r\\n\\t\\treturn new FromItemExpression<TColumns>(this);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport function isCastToColumns(fromItem: FromItem<any>): boolean {\\r\\n\\treturn fromItem[\\\"castToColumns\\\"];\\r\\n}\\r\\n\\r\\nexport function getColumn(fromItem: FromItem<any>, column: string): Column<string, AnyType> {\\r\\n\\tconst result = fromItem.$columns[column];\\r\\n\\tif (!result) throw new Error(`Column '${column}' does not exist on table '${fromItem}'.`);\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nexport class NamedFromItem<TColumns extends Row> extends FromItem<TColumns> {\\r\\n\\tconstructor(public readonly $name: string, columns: RowToColumns<TColumns>, public readonly fromItem: FromItem<TColumns>, castToColumns: boolean) {\\r\\n\\t\\tsuper(columns, castToColumns);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class QueryFromItem<TColumns> extends FromItem<TColumns> {\\r\\n\\tconstructor(public readonly $name: string, columns: RowToColumns<TColumns>, public readonly query: Query<TColumns, any>, castToColumns: boolean) {\\r\\n\\t\\tsuper(columns, castToColumns);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport type FromItemCtor<TColumns extends Row> = FromItem<TColumns> & RowToColumns<TColumns>;\\r\\n\\r\\n\\r\\n/* TODO, for recursion\\r\\nexport class BindableFromItem<TColumns extends ImplicitColumns> extends FromItem<TColumns> {\\r\\n\\tpublic bind(fromItem: FromItem<TColumns>): void;\\r\\n\\tpublic bindAndOverrideColumnNames(view: FromItem<any>): void;\\r\\n}\\r\\n\\r\\ntype BindableViewCtor<TColumns extends ImplicitColumns> = BindableFromItem<TColumns> & ImplicitColumnsToColumns<TColumns>;\\r\\n\\r\\nexport function view<TColumnsWithTypes extends { [columnName: string]: Columns.ColumnDescription<any> }>(\\r\\n\\t\\ttableName: string, columns: TColumnsWithTypes):\\r\\n\\tBindableViewCtor<ColumnsWithTypesToImplicit<TColumnsWithTypes>> {\\r\\n\\t\\r\\n\\treturn null!;\\r\\n}\\r\\n*/\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/FromFactor.ts\n// module id = 228\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/FromFactor.ts?./~/raw-loader");

/***/ }),

/***/ 229:
/***/ (function(module, exports) {

eval("module.exports = \"export type Ordering<T> = { asc: T } | { desc: T };\\r\\n\\r\\nexport function isOrderingAsc(obj: any): obj is { asc: any } {\\r\\n\\tconst keys = Object.keys(obj);\\r\\n\\treturn keys.length === 1 && keys[0] === \\\"asc\\\";\\r\\n}\\r\\n\\r\\nexport function isOrderingDesc(obj: any): obj is { desc: any } {\\r\\n\\tconst keys = Object.keys(obj);\\r\\n\\treturn keys.length === 1 && keys[0] === \\\"desc\\\";\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Ordering.ts\n// module id = 229\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Ordering.ts?./~/raw-loader");

/***/ }),

/***/ 230:
/***/ (function(module, exports) {

eval("module.exports = \"import { Expression, Column, NamedExpression, NamedExpressionNameOf, ExpressionTypeOf, AllExpression } from \\\"../Expressions\\\";\\r\\nimport { FromItem } from \\\"../FromFactor\\\";\\r\\nimport { objectValues } from \\\"../../Helpers\\\";\\r\\nimport { AnyType } from \\\"../Types\\\";\\r\\n\\r\\n/**\\r\\n * An helper for mixins.\\r\\n * @private\\r\\n */\\r\\nexport type Constructable<T> = new (...args: any[]) => T;\\r\\n\\r\\n/**\\r\\n * If `expression` is a string, it returns the column from `fromItem` that has the name `expression` (or throws an exception).\\r\\n * Otherwise, it ensures that `expression` is an `Expression` and returns it.\\r\\n * @private\\r\\n */\\r\\nexport function resolveColumnReference<TExpr extends Expression<any>, TFromTblCols>(\\r\\n\\tfromItem: FromItem<TFromTblCols> | undefined, expression: TExpr | keyof TFromTblCols): TExpr | Column<string, AnyType> {\\r\\n\\r\\n\\tif (expression instanceof Expression) return expression;\\r\\n\\r\\n\\tif (typeof expression !== \\\"string\\\") throw new Error(`Expression must be either of type string or of type Expression, but was '${expression}'.`);\\r\\n\\r\\n\\tif (!fromItem) {\\r\\n\\t\\tthrow new Error(`Columns cannot be referenced by string if no table is specified to select from. `\\r\\n\\t\\t\\t+ `Use method 'from' before.`);\\r\\n\\t}\\r\\n\\r\\n\\tconst column = fromItem.$columns[expression] as Column<string, any>;\\r\\n\\tif (!column) throw new Error(`Column with name '${expression}' does not exist on last table that has been specified in from.`);\\r\\n\\treturn column;\\r\\n}\\r\\n\\r\\n/**\\r\\n * An helper method for select or returning.\\r\\n * @private\\r\\n */\\r\\nexport function handleSelect<TFromTblCols>(\\r\\n\\tfromItem: FromItem<TFromTblCols> | undefined,\\r\\n\\tselectedExpressions: ((keyof TFromTblCols) | NmdExpr | AllExpression<object>)[],\\r\\n\\tallReturningColumns: { [exprName: string]: NamedExpression<string, AnyType> },\\r\\n\\tallSelectedExpressions: (NamedExpression<string, AnyType> | AllExpression<object>)[]) {\\r\\n\\r\\n\\tconst normalizedExpressions = selectedExpressions.map(arg => resolveColumnReference<NmdExpr | AllExpression<object>, TFromTblCols>(fromItem, arg));\\r\\n\\r\\n\\tfor (const expr of normalizedExpressions) {\\r\\n\\t\\tif (!(expr instanceof NamedExpression || expr instanceof AllExpression))\\r\\n\\t\\t\\tthrow new Error(`Given argument '${expr}' must be a named or an all expression.`);\\r\\n\\t}\\r\\n\\r\\n\\tfor (const expr of normalizedExpressions) {\\r\\n\\t\\tfor (const col of (expr instanceof AllExpression) ? objectValues(expr.fromItem.$columns) as Column<string, AnyType>[] : [expr])\\r\\n\\t\\t\\tallReturningColumns[col.name] = col;\\r\\n\\r\\n\\t\\tallSelectedExpressions.push(expr);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * A functor that forces typescript to resolve `|` and `&` operators.\\r\\n * @private\\r\\n */\\r\\nexport type Simplify<T> = {[TKey in keyof T]: T[TKey]};\\r\\n\\r\\n/**\\r\\n * A short form for `NamedExpression<any, any>`.\\r\\n * @private\\r\\n */\\r\\nexport type NmdExpr = NamedExpression<string, AnyType>;\\r\\n\\r\\n/**\\r\\n * \\r\\n * @private\\r\\n */\\r\\nexport type NmdExprToRow<TCol extends NmdExpr> =\\r\\n\\t{[TKey in NamedExpressionNameOf<TCol>]: ExpressionTypeOf<TCol> };\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/Common.ts\n// module id = 230\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/Common.ts?./~/raw-loader");

/***/ }),

/***/ 231:
/***/ (function(module, exports) {

eval("module.exports = \"import { FromItem, Row, FromFactor } from \\\"../FromFactor\\\";\\r\\nimport { Table } from \\\"../Table\\\";\\r\\nimport { ExpressionOrInputValue, AllExpression, NamedExpression, Expression, NamedExpressionNameOf } from \\\"../Expressions\\\";\\r\\nimport { Query, NoColumnsSelected, MoreThanOneColumnSelected, SingleColumn } from \\\"./Query\\\";\\r\\nimport { NmdExpr, Simplify, NmdExprToRow, resolveColumnReference, handleSelect, Constructable } from \\\"./Common\\\";\\r\\nimport { JoinMixin, JoinMixinInstance } from \\\"./JoinMixin\\\";\\r\\nimport { WhereMixin, WhereMixinInstance } from \\\"./WhereMixin\\\";\\r\\nimport { combine } from \\\"../../Helpers\\\";\\r\\nimport { BooleanType } from \\\"../Types\\\";\\r\\n\\r\\n/**\\r\\n * Creates a DELETE FROM statement.\\r\\n * \\r\\n * @param table The table to delete from.\\r\\n */\\r\\nexport function deleteFrom<T extends Row>(table: FromItem<T> & Table<any, any>): DeleteQuery<T, {}, NoColumnsSelected> {\\r\\n\\treturn new DeleteQuery<T, {}, NoColumnsSelected>(table);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Represents a DELETE FROM query.\\r\\n */\\r\\nexport class DeleteQuery<TLastFromRow extends Row, TReturningRow extends Row, TSingleColumn extends SingleColumn<TReturningRow>>\\r\\n\\textends JoinMixin(WhereMixin<Constructable<Query<TReturningRow, TSingleColumn>>, TLastFromRow>(Query)) {\\r\\n\\r\\n\\tprotected _from: FromFactor | undefined = undefined;\\r\\n\\tprotected _whereCondition: Expression<BooleanType> | undefined;\\r\\n\\tprotected lastFromItem: FromItem<TLastFromRow> | undefined;\\r\\n\\r\\n\\tconstructor(private readonly table: FromItem<any> & Table<any, any>) {\\r\\n\\t\\tsuper();\\r\\n\\t\\tthis.lastFromItem = table;\\r\\n\\t}\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn combine(super.getState(), {\\r\\n\\t\\t\\ttable: this.table,\\r\\n\\t\\t\\tusing: this._from,\\r\\n\\t\\t\\twhereCondition: this._whereCondition\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Brings an additional query into scope that can be used to specify more complex delete conditions.\\r\\n\\t * \\r\\n\\t * @param fromItem The query to use.\\r\\n\\t */\\r\\n\\tpublic using<TFromRow extends Row>(fromItem: FromItem<TFromRow>): DeleteQuery<TFromRow, TReturningRow, TSingleColumn> {\\r\\n\\t\\tthis._from = FromFactor.crossJoin(this._from, fromItem);\\r\\n\\t\\tthis.lastFromItem = fromItem as any;\\r\\n\\t\\treturn this as any;\\r\\n\\t}\\r\\n\\r\\n\\t/** Selects all columns from the given table. */\\r\\n\\tpublic returning<T extends Row>(table: AllExpression<T>): DeleteQuery<TLastFromRow, TReturningRow & {[TName in keyof T]: T[TName]}, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single named expression. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(this: DeleteQuery<TLastFromRow, TReturningRow, NoColumnsSelected> | void, expr1: T1): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1>, NamedExpressionNameOf<T1>>;\\r\\n\\r\\n\\t/** Selects 1 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(expr1: T1): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 2 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr>(expr1: T1, expr2: T2): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 3 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 4 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 5 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 6 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 7 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 8 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr, T8 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7, expr8: T8): DeleteQuery<TLastFromRow, TReturningRow & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7> & NmdExprToRow<T8>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single column that is currently in scope. */\\r\\n\\tpublic returning<TColumnName extends keyof TLastFromRow>(this: DeleteQuery<TLastFromRow, TReturningRow, NoColumnsSelected>, column1: TColumnName): DeleteQuery<TLastFromRow, TReturningRow & {[TName in TColumnName]: TLastFromRow[TName]}, TColumnName>;\\r\\n\\r\\n\\t/** Selects columns that are currently in scope. */\\r\\n\\tpublic returning<TColumnNames extends keyof TLastFromRow>(...columns: TColumnNames[]): DeleteQuery<TLastFromRow, TReturningRow & {[TName in TColumnNames]: TLastFromRow[TName]}, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\tpublic returning(...args: ((keyof TLastFromRow) | NmdExpr | AllExpression<any>)[]): any {\\r\\n\\t\\thandleSelect(this.lastFromItem, args, this.returningColumns as any, this.selectedExpressions);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/DeleteQuery.ts\n// module id = 231\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/DeleteQuery.ts?./~/raw-loader");

/***/ }),

/***/ 232:
/***/ (function(module, exports) {

eval("module.exports = \"import { MapExpressionOrInputValue, AllExpression, NamedExpression, NamedExpressionNameOf } from '../Expressions';\\r\\nimport { RetrievalQuery } from './RetrievalQuery';\\r\\nimport { Table, TableRequiredColumns, TableOptionalColumns } from \\\"../Table\\\";\\r\\nimport { Row, FromItem } from \\\"../FromFactor\\\";\\r\\nimport { Query, MoreThanOneColumnSelected, NoColumnsSelected, SingleColumn } from \\\"./Query\\\";\\r\\nimport { Simplify, NmdExprToRow, NmdExpr, handleSelect } from \\\"./Common\\\";\\r\\nimport { combine } from \\\"../../Helpers\\\";\\r\\n\\r\\n/**\\r\\n * Creates an INSERT INTO statement.\\r\\n * \\r\\n * @param table The table to insert into.\\r\\n */\\r\\nexport function insertInto<TTable extends Table<any, any>>(table: TTable):\\r\\n\\tInsertQueryBuilder<TableRequiredColumns<TTable>, TableOptionalColumns<TTable>> {\\r\\n\\r\\n\\treturn new InsertQueryBuilder<TableRequiredColumns<TTable>, TableOptionalColumns<TTable>>(table);\\r\\n}\\r\\n\\r\\nexport type InsertRows<TRequiredColumns, TOptionalColumns> = (MapExpressionOrInputValue<TRequiredColumns> & Partial<MapExpressionOrInputValue<TOptionalColumns>>)[];\\r\\nexport type InsertRowQuery<TRequiredColumns, TOptionalColumns> = RetrievalQuery<TRequiredColumns & Partial<TOptionalColumns>, any>;\\r\\n\\r\\n/**\\r\\n * Represents an INSERT INTO statement that needs values.\\r\\n */\\r\\nexport class InsertQueryBuilder<TRequiredColumns extends Row, TOptionalColumns extends Row> {\\r\\n\\tconstructor(private readonly table: Table<TRequiredColumns, TOptionalColumns>) { }\\r\\n\\r\\n\\t/**\\r\\n\\t * Inserts one or more items.\\r\\n\\t * @param items The items to be inserted.\\r\\n\\t */\\r\\n\\tpublic value(...items: InsertRows<TRequiredColumns, TOptionalColumns>) {\\r\\n\\t\\treturn this.values(items);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Inserts an array of items.\\r\\n\\t * @param items The items to be inserted.\\r\\n\\t */\\r\\n\\tpublic values(items: InsertRows<TRequiredColumns, TOptionalColumns>): InsertQuery<TRequiredColumns & TOptionalColumns, {}, NoColumnsSelected> {\\r\\n\\t\\treturn new InsertQuery<TRequiredColumns & TOptionalColumns, {}, NoColumnsSelected>(this.table, items);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Uses a subquery to retrieve the items to be inserted.\\r\\n\\t * @param query A query that returns the items to be inserted.\\r\\n\\t */\\r\\n\\tpublic valuesFrom(query: InsertRowQuery<TRequiredColumns, TOptionalColumns>): InsertQuery<TRequiredColumns & TOptionalColumns, {}, NoColumnsSelected> {\\r\\n\\t\\treturn new InsertQuery<TRequiredColumns & TOptionalColumns, {}, NoColumnsSelected>(this.table, query);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n/**\\r\\n * Represents an INSERT INTO statement.\\r\\n */\\r\\nexport class InsertQuery<TTableColumns extends Row, TReturningColumns extends Row, TSingleColumn extends SingleColumn<TTableColumns>>\\r\\n\\textends Query<TReturningColumns, TSingleColumn> {\\r\\n\\r\\n\\tconstructor(private readonly table: Table<any, any>, private readonly values: InsertRows<any, any> | InsertRowQuery<any, any>) {\\r\\n\\t\\tsuper();\\r\\n\\t}\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn combine(super.getState(), {\\r\\n\\t\\t\\ttable: this.table,\\r\\n\\t\\t\\tvalues: this.values\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\t/** Selects all columns from the given table. */\\r\\n\\tpublic returning<T extends Row>(table: AllExpression<T>): InsertQuery<TTableColumns, Simplify<TReturningColumns & {[TName in keyof T]: T[TName]}>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single named expression. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(this: InsertQuery<TTableColumns, TReturningColumns, NoColumnsSelected> | void, expr1: T1): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1>>, NamedExpressionNameOf<T1>>;\\r\\n\\r\\n\\t/** Selects 1 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(expr1: T1): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 2 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr>(expr1: T1, expr2: T2): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 3 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 4 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 5 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 6 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 7 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 8 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr, T8 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7, expr8: T8): InsertQuery<TTableColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7> & NmdExprToRow<T8>>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single column that is currently in scope. */\\r\\n\\tpublic returning<TColumnName extends keyof TTableColumns>(this: InsertQuery<TTableColumns, TReturningColumns, NoColumnsSelected>, column1: TColumnName): InsertQuery<TTableColumns, Simplify<TReturningColumns & {[TName in TColumnName]: TTableColumns[TName]}>, TColumnName>;\\r\\n\\r\\n\\t/** Selects columns that are currently in scope. */\\r\\n\\tpublic returning<TColumnNames extends keyof TTableColumns>(...columns: TColumnNames[]): InsertQuery<TTableColumns, Simplify<TReturningColumns & {[TName in TColumnNames]: TTableColumns[TName]}>, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\tpublic returning(...args: ((keyof TTableColumns) | NmdExpr | AllExpression<any>)[]): any {\\r\\n\\t\\thandleSelect(this.table, args, this.returningColumns as any, this.selectedExpressions);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/InsertQuery.ts\n// module id = 232\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/InsertQuery.ts?./~/raw-loader");

/***/ }),

/***/ 233:
/***/ (function(module, exports) {

eval("module.exports = \"import { BooleanType } from '../Types';\\r\\nimport { Expression, ExpressionOrInputValue, ExpressionTypeOf, toCondition, MapExpressionOrInputValue } from \\\"../Expressions\\\";\\r\\nimport { FromItem, FromFactor, FromFactorFullJoin, FromFactorInnerJoin, FromFactorLeftJoin } from \\\"../FromFactor\\\";\\r\\nimport { Constructable } from \\\"./Common\\\";\\r\\n\\r\\nexport interface JoinMixinInstance {\\r\\n\\t/**\\r\\n\\t * Performs a full join on the current query (`cur`) and a specified table (`joined`).\\r\\n\\t * These rows are returned:\\r\\n\\t * ```\\r\\n\\t * for (row r in cur): for (row j in joined that matches r)\\r\\n\\t * \\tyield row(r, j)\\r\\n\\t * for (row r in cur): if (joined has no row that matches r)\\r\\n\\t * \\tyield row(r, null)\\r\\n\\t * for (row j in joined): if (cur has no row that matches j)\\r\\n\\t * \\tyield row(null, j)\\r\\n\\t * ```\\r\\n\\t */\\r\\n\\tfullJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this>;\\r\\n\\r\\n\\t/**\\r\\n\\t * Performs a left join on the current query (`cur`) and a specified table (`joined`).\\r\\n\\t * These rows are returned:\\r\\n\\t * ```\\r\\n\\t * for (row r in cur): for (row j in joined that matches r)\\r\\n\\t * \\tyield row(r, j)\\r\\n\\t * for (row r in cur): if (joined has no row that matches r)\\r\\n\\t * \\tyield row(r, null)\\r\\n\\t * ```\\r\\n\\t */\\r\\n\\tleftJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this>;\\r\\n\\r\\n\\t/**\\r\\n\\t * Performs an inner join on the current query (`cur`) and a specified table (`joined`).\\r\\n\\t * These rows are returned:\\r\\n\\t * ```\\r\\n\\t * for (row r in cur): for (row j in joined that matches r)\\r\\n\\t * \\tyield row(r, j)\\r\\n\\t * ```\\r\\n\\t */\\r\\n\\tinnerJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this>;\\r\\n}\\r\\n\\r\\nexport function JoinMixin<BC extends Constructable<object>>(Base: BC): Constructable<JoinMixinInstance> & BC {\\r\\n\\treturn class extends Base {\\r\\n\\t\\tprotected _from: FromFactor | undefined = undefined;\\r\\n\\r\\n\\t\\tprivate curriedOnJoin(ctor: new (fromFactor: FromFactor, joined: FromFactor, condition: Expression<BooleanType>) => FromFactor) {\\r\\n\\t\\t\\treturn (joined: FromItem<any>, condition: Expression<BooleanType>): this => {\\r\\n\\t\\t\\t\\tif (!this._from) throw new Error(\\\"A primary table must be selected before other tables can be joined.\\\");\\r\\n\\t\\t\\t\\tthis._from = new ctor(this._from, joined, condition);\\r\\n\\t\\t\\t\\treturn this;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic fullJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this> {\\r\\n\\t\\t\\treturn new JoinConditionBuilder(fromItem, this.curriedOnJoin(FromFactorFullJoin));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic leftJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this> {\\r\\n\\t\\t\\treturn new JoinConditionBuilder(fromItem, this.curriedOnJoin(FromFactorLeftJoin));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic innerJoin<TFromItemColumns>(fromItem: FromItem<TFromItemColumns>): JoinConditionBuilder<TFromItemColumns, this> {\\r\\n\\t\\t\\treturn new JoinConditionBuilder(fromItem, this.curriedOnJoin(FromFactorInnerJoin));\\r\\n\\t\\t}\\r\\n\\t};\\r\\n}\\r\\n\\r\\nexport class JoinConditionBuilder<TFromItemColumns, TReturn> {\\r\\n\\tconstructor(private readonly fromItem: FromItem<any>, private readonly onJoin: (joined: FromItem<any>, condition: Expression<BooleanType>) => TReturn) { }\\r\\n\\r\\n\\t/**\\r\\n\\t * Specifies the condition of the join.\\r\\n\\t * At least one condition must be set.\\r\\n\\t * \\r\\n\\t * @param condition The condition.\\r\\n\\t * @param furtherConditions More conditions.\\r\\n\\t */\\r\\n\\tpublic on(condition: Expression<BooleanType>, ...furtherConditions: Expression<BooleanType>[]): TReturn;\\r\\n\\t/**\\r\\n\\t * Specifies the condition of the join.\\r\\n\\t * At least one property must be set.\\r\\n\\t * \\r\\n\\t * @param condition An object that represents multiple equals conditions.\\r\\n\\t *\\tEach property refers to a column of the joined table, its value to the expression the column must be equal to.\\r\\n\\t */\\r\\n\\tpublic on(condition: Partial<MapExpressionOrInputValue<TFromItemColumns>>): TReturn;\\r\\n\\tpublic on(...conditions: any[]): TReturn {\\r\\n\\t\\tconst condition = toCondition(this.fromItem, conditions);\\r\\n\\t\\tif (!condition) throw new Error(\\\"No condition for joined was given.\\\");\\r\\n\\t\\treturn this.onJoin(this.fromItem, condition);\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/JoinMixin.ts\n// module id = 233\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/JoinMixin.ts?./~/raw-loader");

/***/ }),

/***/ 234:
/***/ (function(module, exports) {

eval("module.exports = \"import { AnyType } from '../Types';\\r\\nimport { FromItem, QueryFromItem, FromItemCtor, RowToColumns, Row } from \\\"../FromFactor\\\";\\r\\nimport { NamedExpression, ColumnBoundToExpression, NamedExpressionNameOf, ExpressionTypeOf, AllExpression, AsColumn } from \\\"../Expressions\\\";\\r\\nimport { RowDescriptionToRow } from \\\"../Table\\\";\\r\\nimport { objectValues, objectEntries } from \\\"../../Helpers\\\";\\r\\n\\r\\nexport type RowToNmdExprs<TRow extends Row> =\\r\\n\\t{ [TName in keyof TRow]: NamedExpression<TName, TRow[TName]> };\\r\\n\\r\\nexport interface NoColumnsSelected { _brand: \\\"NoColumnSelected\\\" }\\r\\nexport interface MoreThanOneColumnSelected { _brand: \\\"MoreThanOneColumnSelected\\\" }\\r\\nexport type SingleColumn<TSelectedCols> = NoColumnsSelected|(keyof TSelectedCols)|MoreThanOneColumnSelected;\\r\\n\\r\\nexport class Query<TReturningRow extends Row, TSingleColumn extends SingleColumn<TReturningRow>> {\\r\\n\\tprotected returningColumns: RowToNmdExprs<TReturningRow> = {} as any;\\r\\n\\tprotected selectedExpressions: (NamedExpression<any, any>|AllExpression<any>)[] = [];\\r\\n\\r\\n\\t/**\\r\\n\\t * Returns `NoColumnsSelected` if no columns are selected,\\r\\n\\t * `MoreThanOneColumnSelected` if more than one columns are selected or \\r\\n\\t * the name of the column if exactly one column is selected.\\r\\n\\t */\\r\\n\\tpublic get singleColumn(): TSingleColumn {\\r\\n\\t\\tconst first = this.selectedExpressions[0];\\r\\n\\t\\tif (this.selectedExpressions.length === 1 && !(first instanceof AllExpression))\\r\\n\\t\\t\\treturn first.name;\\r\\n\\t\\treturn undefined as any;\\r\\n\\t}\\r\\n\\r\\n\\tprivate _isWithRecursive: boolean = false;\\r\\n\\tprivate _withItems: FromItem<any>[] = [];\\r\\n\\t\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tisWithRecursive: this._isWithRecursive,\\r\\n\\t\\t\\twithItems: this._withItems,\\r\\n\\t\\t\\tselected: this.selectedExpressions,\\r\\n\\t\\t\\treturningColumns: this.returningColumns\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n/* Not supported yet.\\r\\n\\tpublic withRecursive(view: FromItem<any>): this {\\r\\n\\t\\tthis._isWithRecursive = true;\\r\\n\\t\\treturn this.with(view);\\r\\n\\t}\\r\\n\\r\\n\\tpublic with(view: FromItem<any>): this {\\r\\n\\t\\tthis._withItems.push(view);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\t*/\\r\\n\\r\\n\\t/**\\r\\n\\t * Names this query and returns it as `FromItem`.\\r\\n\\t * @param name The name of the query that will be used in the SQL statement.\\r\\n\\t */\\r\\n\\tpublic as(name: string): FromItemCtor<TReturningRow>;\\r\\n\\r\\n\\t/**\\r\\n\\t * Names this query and renames its columns and returns it as `FromItem`.\\r\\n\\t * @param name The name of the query that will be used in the SQL statement.\\r\\n\\t * @param columns The columns to cast to.\\r\\n\\t */\\r\\n\\tpublic as<TColumnsWithTypes extends { [columnName: string]: AnyType }>(name: string, columns: TColumnsWithTypes): FromItemCtor<RowDescriptionToRow<TColumnsWithTypes>>;\\r\\n\\tpublic as(name: string, columns?: { [columnName: string]: AnyType }): FromItemCtor<TReturningRow> {\\r\\n\\t\\tconst newColumns = {} as any;\\r\\n\\t\\tconst setters: ((fromItem: FromItem<any>) => void)[] = [];\\r\\n\\r\\n\\t\\tlet castToColumns: boolean;\\r\\n\\r\\n\\t\\tif (!columns) {\\r\\n\\t\\t\\tcastToColumns = false;\\r\\n\\t\\t\\tfor (const nmdExpr of objectValues(this.returningColumns) as NamedExpression<any, any>[]) {\\r\\n\\t\\t\\t\\tnewColumns[nmdExpr.name] = new ColumnBoundToExpression(nmdExpr, setter => setters.push(setter));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tcastToColumns = true;\\r\\n\\t\\t\\tfor (const [name, type] of objectEntries(columns)) {\\r\\n\\t\\t\\t\\tnewColumns[name] = new AsColumn(name, type, setter => setters.push(setter));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tconst fromItem = new QueryFromItem(name, newColumns, this, castToColumns);\\r\\n\\t\\tfor (const setter of setters) setter(fromItem);\\r\\n\\r\\n\\t\\treturn fromItem as any; // fields are set in constructor\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/Query.ts\n// module id = 234\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/Query.ts?./~/raw-loader");

/***/ }),

/***/ 235:
/***/ (function(module, exports) {

eval("module.exports = \"import { IntegerType, tInteger } from '../Types';\\r\\nimport { Query, SingleColumn } from \\\"./Query\\\";\\r\\nimport { Expression, ExpressionOrInputValue, RetrievalQueryAsExpression, Variable, normalize, AllExpression, NamedExpression } from \\\"../Expressions\\\";\\r\\nimport { FromItem, Row, getColumn } from \\\"../FromFactor\\\";\\r\\n\\r\\nexport class RetrievalQuery<TRow extends Row, TSingleColumn extends SingleColumn<TRow>> extends Query<TRow, TSingleColumn> {\\r\\n\\tprivate _limit: Expression<IntegerType> | undefined;\\r\\n\\tprivate _offset: Expression<IntegerType> | undefined;\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn Object.assign({\\r\\n\\t\\t\\tlimit: this._limit,\\r\\n\\t\\t\\toffset: this._offset\\r\\n\\t\\t}, super.getState());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets an limit on how many rows are returned.\\r\\n\\t * Overwrites any limit that was set before.\\r\\n\\t * \\r\\n\\t * @param count The limit.\\r\\n\\t */\\r\\n\\tpublic limit(count: ExpressionOrInputValue<IntegerType>): this {\\r\\n\\t\\tthis._limit = normalize(tInteger, count);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets how many rows are skipped.\\r\\n\\t * Overwrites any offset that was set before.\\r\\n\\t * \\r\\n\\t * @param count The offset.\\r\\n\\t */\\r\\n\\tpublic offset(count: ExpressionOrInputValue<IntegerType>): this {\\r\\n\\t\\tthis._offset = normalize(tInteger, count);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Wraps this query as expression. The query must return exactly one row with exactly one column.\\r\\n\\t */\\r\\n\\tpublic asExpression<TSingleColumn2 extends keyof TRow>\\r\\n\\t\\t(this: RetrievalQuery<TRow, TSingleColumn2>): Expression<TRow[TSingleColumn2]> {\\r\\n\\t\\tconst column = this.returningColumns[this.singleColumn];\\r\\n\\t\\treturn new RetrievalQueryAsExpression<TRow[TSingleColumn2]>(this, column.type);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nexport class UnionQuery<TColumns, TSingleColumn extends SingleColumn<TColumns>> extends RetrievalQuery<TColumns, TSingleColumn> {\\r\\n\\tconstructor(public readonly query1: RetrievalQuery<TColumns, TSingleColumn>, public readonly query2: RetrievalQuery<TColumns, any>) {\\r\\n\\t\\tsuper();\\r\\n\\r\\n\\t\\tconst s = query1.getState();\\r\\n\\t\\tthis.returningColumns = s.returningColumns;\\r\\n\\t\\tthis.selectedExpressions = s.selected;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport function unionAll<TColumns, TSingleColumn extends SingleColumn<TColumns>>(query1: RetrievalQuery<TColumns, TSingleColumn>, ...queries: RetrievalQuery<any, any>[])\\r\\n\\t: RetrievalQuery<TColumns, TSingleColumn> {\\r\\n\\r\\n\\treturn queries.reduce((p, c) => new UnionQuery(p, c), query1);\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/RetrievalQuery.ts\n// module id = 235\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/RetrievalQuery.ts?./~/raw-loader");

/***/ }),

/***/ 236:
/***/ (function(module, exports) {

eval("module.exports = \"import { BooleanType, AnyType } from '../Types';\\r\\nimport {\\r\\n\\tExpression, NamedExpression, ExpressionOrInputValue, MapExpressionOrInputValue,\\r\\n\\tExpressionTypeOf, AllExpression, and, toCondition, Column, NamedExpressionNameOf\\r\\n} from \\\"../Expressions\\\";\\r\\nimport {\\r\\n\\tFromItem, FromFactor, Row, RowToColumns,\\r\\n\\tFromFactorFullJoin, FromFactorInnerJoin, FromFactorLeftJoin, FromFactorCrossJoin\\r\\n} from \\\"../FromFactor\\\";\\r\\nimport { RetrievalQuery } from \\\"./RetrievalQuery\\\";\\r\\nimport { NoColumnsSelected, MoreThanOneColumnSelected, SingleColumn } from \\\"./Query\\\";\\r\\nimport { Ordering, isOrderingAsc, isOrderingDesc } from \\\"../Ordering\\\";\\r\\nimport { Simplify, NmdExpr, NmdExprToRow, handleSelect, resolveColumnReference, Constructable } from \\\"./Common\\\";\\r\\nimport { JoinMixin, JoinMixinInstance } from \\\"./JoinMixin\\\";\\r\\nimport { WhereMixin, WhereMixinInstance } from \\\"./WhereMixin\\\";\\r\\nimport { secondWithTypeOfFirst } from \\\"../../Helpers\\\";\\r\\n\\r\\nexport class SelectQuery<TSelectedCols extends Row, TFromTblCols extends Row, TSingleColumn extends SingleColumn<TSelectedCols>>\\r\\n\\textends JoinMixin(\\r\\n\\t\\tWhereMixin<Constructable<RetrievalQuery<TSelectedCols, TSingleColumn>>, TFromTblCols>(\\r\\n\\t\\t\\tRetrievalQuery))\\r\\n{\\r\\n\\tprotected _from: FromFactor | undefined = undefined;\\r\\n\\tprotected _whereCondition: Expression<BooleanType> | undefined;\\r\\n\\tprotected lastFromItem: FromItem<TFromTblCols> | undefined;\\r\\n\\r\\n\\tprivate _orderBys: Ordering<Expression<AnyType>>[] = [];\\r\\n\\tprivate _havingCondition: Expression<BooleanType> | undefined;\\r\\n\\tprivate _groupBys: Expression<AnyType>[] = [];\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn Object.assign({\\r\\n\\t\\t\\torderBys: this._orderBys,\\r\\n\\t\\t\\twhereCondition: this._whereCondition,\\r\\n\\t\\t\\thavingCondition: this._havingCondition,\\r\\n\\t\\t\\tgroupBys: this._groupBys,\\r\\n\\t\\t\\tfrom: this._from\\r\\n\\t\\t}, super.getState());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Selects from a table. If previous tables are already specified, they are cross joined.\\r\\n\\t * @param table The table to select from.\\r\\n\\t */\\r\\n\\tpublic from<TTableColumns>(table: FromItem<TTableColumns>):\\r\\n\\t\\tSelectQuery<TSelectedCols, TTableColumns, TSingleColumn> {\\r\\n\\t\\tthis._from = FromFactor.crossJoin(this._from, table);\\r\\n\\t\\tthis.lastFromItem = table as any;\\r\\n\\t\\treturn this as any;\\r\\n\\t}\\r\\n\\r\\n\\t/** Selects all columns from the given table. */\\r\\n\\tpublic select<T extends Row>(table: AllExpression<T>): SelectQuery<Simplify<TSelectedCols & {[TName in keyof T]: T[TName]}>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single named expression. */\\r\\n\\tpublic select<T1 extends NmdExpr>(this: SelectQuery<TSelectedCols, TFromTblCols, NoColumnsSelected> | void, expr1: T1): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1>>, TFromTblCols, NamedExpressionNameOf<T1>>;\\r\\n\\r\\n\\t/** Selects 1 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr>(expr1: T1): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 2 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr>(expr1: T1, expr2: T2): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 3 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 4 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 5 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 6 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 7 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 8 named expressions. */\\r\\n\\tpublic select<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr, T8 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7, expr8: T8): SelectQuery<Simplify<TSelectedCols & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7> & NmdExprToRow<T8>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single column that is currently in scope. */\\r\\n\\tpublic select<TColumnName extends keyof TFromTblCols>(this: SelectQuery<TSelectedCols, TFromTblCols, NoColumnsSelected>, column1: TColumnName): SelectQuery<Simplify<TSelectedCols & {[TName in TColumnName]: TFromTblCols[TName]}>, TFromTblCols, TColumnName>;\\r\\n\\r\\n\\t/** Selects columns that are currently in scope. */\\r\\n\\tpublic select<TColumnNames extends keyof TFromTblCols>(...columns: TColumnNames[]): SelectQuery<Simplify<TSelectedCols & {[TName in TColumnNames]: TFromTblCols[TName]}>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\tpublic select(...args: ((keyof TFromTblCols) | NmdExpr | AllExpression<any>)[]): any {\\r\\n\\t\\thandleSelect(this.lastFromItem, args, this.returningColumns as any, this.selectedExpressions);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds expressions to the order-by list of this query.\\r\\n\\t * Use `expression.desc()` or `{ desc: \\\"columnName\\\" }` for descending order.\\r\\n\\t * @param expressions The expressions to add to the order-by list.\\r\\n\\t */\\r\\n\\tpublic orderBy(...expressions: (\\r\\n\\t\\tOrdering<(Expression<any> | keyof TFromTblCols)> | Expression<any> | keyof TFromTblCols\\r\\n\\t)[]): this;\\r\\n\\t/**\\r\\n\\t * Adds expressions to the order-by list of this query. The `expressionSelector` can be used to refer to already selected expressions.\\r\\n\\t * @param expressionSelector A selector that must return the expressions to add to the order-by list.\\r\\n\\t */\\r\\n\\tpublic orderBy(expressionSelector: (selectedColumns: RowToColumns<TSelectedCols>)\\r\\n\\t\\t=> (Ordering<Expression<any>> | Expression<any>)[] | (Ordering<Expression<any>> | Expression<any>)): this;\\r\\n\\tpublic orderBy(...expressions: any[]): this {\\r\\n\\r\\n\\t\\tconst expressions2 = ((): (Ordering<(Expression<any> | keyof TFromTblCols)> | Expression<any> | keyof TFromTblCols)[] => {\\r\\n\\t\\t\\tconst firstExpr = expressions[0];\\r\\n\\t\\t\\tif (firstExpr && (typeof firstExpr) === \\\"function\\\") {\\r\\n\\t\\t\\t\\tconst expr = firstExpr(this.returningColumns);\\r\\n\\t\\t\\t\\tif (Array.isArray(expr)) return expr;\\r\\n\\t\\t\\t\\treturn [ expr ];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn expressions;\\r\\n\\t\\t})();\\r\\n\\r\\n\\t\\tconst exprs = expressions2.map(e => {\\r\\n\\t\\t\\tif (typeof e === \\\"string\\\") return resolveColumnReference(this.lastFromItem, e).asc();\\r\\n\\t\\t\\tif (e instanceof Expression) return e.asc();\\r\\n\\t\\t\\tif (isOrderingAsc(e)) return resolveColumnReference(this.lastFromItem, e.asc).asc();\\r\\n\\t\\t\\tif (isOrderingDesc(e)) return resolveColumnReference(this.lastFromItem, e.desc).desc();\\r\\n\\t\\t\\tthrow new Error(`Unexpected value in orderBy: '${e}'.`);\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\tthis._orderBys.push(...exprs);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds having-conditions.\\r\\n\\t * In contrast to where-conditions, having-conditions are evaluated after grouping is done.\\r\\n\\t * @param conditionSelector \\r\\n\\t */\\r\\n\\tpublic having(condition: Expression<BooleanType>, ...conditions: Expression<BooleanType>[]): this;\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds having-conditions.\\r\\n\\t * In contrast to where-conditions, having-conditions are evaluated after grouping is done.\\r\\n\\t * @param conditionSelector \\r\\n\\t */\\r\\n\\tpublic having(conditionSelector: (selectedColumns: RowToColumns<TSelectedCols>) => Expression<BooleanType>): this;\\r\\n\\tpublic having(...args: any[]): this {\\r\\n\\t\\tlet expression: Expression<BooleanType> | undefined = undefined;\\r\\n\\t\\tif ((typeof args[0]) === \\\"function\\\") {\\r\\n\\t\\t\\tconst func = args[0];\\r\\n\\t\\t\\texpression = func(this.returningColumns);\\r\\n\\t\\t}\\r\\n\\t\\telse\\r\\n\\t\\t\\texpression = toCondition(this.lastFromItem, args);\\r\\n\\r\\n\\t\\tthis._havingCondition = and(this._havingCondition, expression);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds expressions to the group-by list of this query.\\r\\n\\t * @param expressions The expressions to add.\\r\\n\\t */\\r\\n\\tpublic groupBy(...expressions: (Expression<AnyType> | keyof TFromTblCols)[]): this;\\r\\n\\r\\n\\t/**\\r\\n\\t * Adds expressions to the group-by list of this query. The `expressionSelector` can be used to refer to already selected expressions.\\r\\n\\t * @param expressionSelector A selector that must return the expressions to add to the group-by list.\\r\\n\\t */\\r\\n\\tpublic groupBy(expressionSelector: (selectedColumns: RowToColumns<TSelectedCols>) => Expression<AnyType> | Expression<AnyType>[]): this;\\r\\n\\tpublic groupBy(...expressions: any[]): this {\\r\\n\\t\\tconst exprs = (() => {\\r\\n\\t\\t\\tconst firstExpr = expressions[0];\\r\\n\\t\\t\\tif ((typeof firstExpr) === \\\"function\\\") {\\r\\n\\t\\t\\t\\tlet result = firstExpr(this.returningColumns);\\r\\n\\t\\t\\t\\tif (Array.isArray(result)) return result;\\r\\n\\t\\t\\t\\treturn [result];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse return expressions.map(e => resolveColumnReference(this.lastFromItem, e));\\r\\n\\t\\t})();\\r\\n\\r\\n\\t\\tthis._groupBys.push(...exprs);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a SELECT query that selects from the given table.\\r\\n * @param table The table to select from.\\r\\n */\\r\\nexport function from<TTableColumns>(table: FromItem<TTableColumns>) {\\r\\n\\tconst result = new SelectQuery<{}, {}, NoColumnsSelected>();\\r\\n\\treturn result.from(table);\\r\\n}\\r\\n\\r\\nexport const select = secondWithTypeOfFirst(new SelectQuery<{}, {}, NoColumnsSelected>().select, function (...args: any[]): any {\\r\\n\\tconst result = new SelectQuery<{}, {}, NoColumnsSelected>();\\r\\n\\treturn result.select.call(result, ...args);\\r\\n});\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/SelectQuery.ts\n// module id = 236\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/SelectQuery.ts?./~/raw-loader");

/***/ }),

/***/ 237:
/***/ (function(module, exports) {

eval("module.exports = \"import {\\r\\n\\tFromItem, Row, FromFactor,\\r\\n\\tFromFactorFullJoin, FromFactorInnerJoin, FromFactorLeftJoin, FromFactorCrossJoin, getColumn\\r\\n} from \\\"../FromFactor\\\";\\r\\nimport { Table } from \\\"../Table\\\";\\r\\nimport { Expression, ExpressionOrInputValue, AllExpression, toCondition, and, normalize, NamedExpression, NamedExpressionNameOf, Column } from \\\"../Expressions\\\";\\r\\nimport { Query, SingleColumn, MoreThanOneColumnSelected, NoColumnsSelected } from './Query';\\r\\nimport { NmdExpr, Simplify, NmdExprToRow, resolveColumnReference, handleSelect, Constructable } from \\\"./Common\\\";\\r\\nimport { JoinMixin, JoinMixinInstance } from \\\"./JoinMixin\\\";\\r\\nimport { WhereMixin, WhereMixinInstance } from \\\"./WhereMixin\\\";\\r\\nimport { BooleanType, AnyType } from \\\"../Types\\\";\\r\\nimport { objectEntries } from \\\"../../Helpers\\\";\\r\\n\\r\\nexport function update<T extends Row>(table: FromItem<T> & Table<any, any>): UpdateQuery<T, {}, T, NoColumnsSelected> {\\r\\n\\treturn new UpdateQuery<T, {}, T, NoColumnsSelected>(table);\\r\\n}\\r\\nexport class UpdateQuery<TUpdatedColumns extends Row, TReturningColumns extends Row, TFromTblCols extends Row, TSingleColumn extends SingleColumn<TReturningColumns>>\\r\\n\\textends JoinMixin(WhereMixin<Constructable<Query<TReturningColumns, TSingleColumn>>, TFromTblCols>(Query)) {\\r\\n\\r\\n\\tprotected _from: FromFactor | undefined = undefined;\\r\\n\\tprotected _whereCondition: Expression<BooleanType> | undefined;\\r\\n\\tprotected lastFromItem: FromItem<TFromTblCols> | undefined;\\r\\n\\r\\n\\tprivate readonly _table: FromItem<TUpdatedColumns> & Table<any, any>;\\r\\n\\r\\n\\tprivate _updatedColumns: {[TColumnName in keyof TFromTblCols]?: Expression<TFromTblCols[TColumnName]>} = {};\\r\\n\\r\\n\\tconstructor(table: FromItem<TUpdatedColumns> & Table<any, any>) {\\r\\n\\t\\tsuper();\\r\\n\\t\\tthis.lastFromItem = table;\\r\\n\\t\\tthis._table = table;\\r\\n\\t}\\r\\n\\r\\n\\tpublic getState() {\\r\\n\\t\\treturn Object.assign({\\r\\n\\t\\t\\twhereCondition: this._whereCondition,\\r\\n\\t\\t\\tupdatedColumns: this._updatedColumns,\\r\\n\\t\\t\\ttable: this._table,\\r\\n\\t\\t\\tfrom: this._from\\r\\n\\t\\t}, super.getState());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Selects from a table. If previous tables are already specified, they are cross joined.\\r\\n\\t * These tables can be used to for condition or value expressions.\\r\\n\\t * @param table The table to select from.\\r\\n\\t */\\r\\n\\tpublic from<TTableColumns>(table: FromItem<TTableColumns>): UpdateQuery<TUpdatedColumns, TReturningColumns, TTableColumns, TSingleColumn> {\\r\\n\\t\\tthis._from = FromFactor.crossJoin(this._from, table);\\r\\n\\t\\tthis.lastFromItem = table as any;\\r\\n\\t\\treturn this as any;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets a new value for a column.\\r\\n\\t * Use `defaultValue()` to reset a column to its default value.\\r\\n\\t * \\r\\n\\t * @param column The column to update.\\r\\n\\t * @param value The new value for the column.\\r\\n\\t */\\r\\n\\tpublic set<TColumn extends keyof TUpdatedColumns>(column: TColumn, value: ExpressionOrInputValue<TUpdatedColumns[TColumn]>): this;\\r\\n\\t/**\\r\\n\\t * Sets new values for specified columns.\\r\\n\\t * @param obj The columns to update and their new values.\\r\\n\\t */\\r\\n\\tpublic set(obj: {[TColumnName in keyof TUpdatedColumns]?: ExpressionOrInputValue<TUpdatedColumns[TColumnName]>}): this;\\r\\n\\tpublic set(columnOrObject: string | object, value?: ExpressionOrInputValue<any>): this {\\r\\n\\t\\tif (typeof columnOrObject === \\\"string\\\") {\\r\\n\\t\\t\\tconst column = getColumn(this._table, columnOrObject);\\r\\n\\t\\t\\tconst expr = normalize(column.type, value);\\r\\n\\t\\t\\tthis._updatedColumns[columnOrObject] = expr;\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tfor (const [name, value] of objectEntries(columnOrObject)) {\\r\\n\\t\\t\\t\\tconst column = getColumn(this._table, name);\\r\\n\\t\\t\\t\\tconst expr = normalize(column.type, value);\\r\\n\\t\\t\\t\\tthis._updatedColumns[name as string] = expr;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\t/** Selects all columns from the given table. */\\r\\n\\tpublic returning<T extends Row>(table: AllExpression<T>): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & {[TName in keyof T]: T[TName]}>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single named expression. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(this: UpdateQuery<TUpdatedColumns, TReturningColumns, TFromTblCols, NoColumnsSelected> | void, expr1: T1): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1>>, TFromTblCols, NamedExpressionNameOf<T1>>;\\r\\n\\r\\n\\t/** Selects 1 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr>(expr1: T1): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 2 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr>(expr1: T1, expr2: T2): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 3 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 4 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 5 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 6 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 7 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects 8 named expressions. */\\r\\n\\tpublic returning<T1 extends NmdExpr, T2 extends NmdExpr, T3 extends NmdExpr, T4 extends NmdExpr, T5 extends NmdExpr, T6 extends NmdExpr, T7 extends NmdExpr, T8 extends NmdExpr>(expr1: T1, expr2: T2, expr3: T3, expr4: T4, expr5: T5, expr6: T6, expr7: T7, expr8: T8): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & NmdExprToRow<T1> & NmdExprToRow<T2> & NmdExprToRow<T3> & NmdExprToRow<T4> & NmdExprToRow<T5> & NmdExprToRow<T6> & NmdExprToRow<T7> & NmdExprToRow<T8>>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\t/** Selects a single column that is currently in scope. */\\r\\n\\tpublic returning<TColumnName extends keyof TFromTblCols>(this: UpdateQuery<TUpdatedColumns, TReturningColumns, TFromTblCols, NoColumnsSelected>, column1: TColumnName): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & {[TName in TColumnName]: TFromTblCols[TName]}>, TFromTblCols, TColumnName>;\\r\\n\\r\\n\\t/** Selects columns that are currently in scope. */\\r\\n\\tpublic returning<TColumnNames extends keyof TFromTblCols>(...columns: TColumnNames[]): UpdateQuery<TUpdatedColumns, Simplify<TReturningColumns & {[TName in TColumnNames]: TFromTblCols[TName]}>, TFromTblCols, MoreThanOneColumnSelected>;\\r\\n\\r\\n\\tpublic returning(...args: ((keyof TFromTblCols) | NmdExpr | AllExpression<object>)[]): any {\\r\\n\\t\\thandleSelect(this.lastFromItem, args, this.returningColumns as any, this.selectedExpressions);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/UpdateQuery.ts\n// module id = 237\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/UpdateQuery.ts?./~/raw-loader");

/***/ }),

/***/ 238:
/***/ (function(module, exports) {

eval("module.exports = \"import { AnyType, tVoid, GetInType } from '../Types';\\r\\nimport { MoreThanOneColumnSelected } from './Query';\\r\\nimport { RowDescriptionToRow } from \\\"../Table\\\";\\r\\nimport { FromItemCtor, QueryFromItem, FromItem } from \\\"../FromFactor\\\";\\r\\nimport { RetrievalQuery } from \\\"./RetrievalQuery\\\";\\r\\nimport { AsColumn } from \\\"../Expressions\\\";\\r\\nimport { toObject, objectEntries } from \\\"../../Helpers\\\";\\r\\n\\r\\nexport function values<T extends { [columnName: string]: AnyType }>(columns: T, items?: { [TName in keyof T]: GetInType<T[TName]> }[]): ValuesQuery<T> {\\r\\n\\tconst values = new ValuesQuery<T>(columns);\\r\\n\\tif (items)\\r\\n\\t\\tvalues.withValues(items);\\r\\n\\treturn values;\\r\\n}\\r\\n\\r\\nexport class ValuesQuery<TAsColumns extends { [columnName: string]: AnyType }> extends RetrievalQuery<{}, MoreThanOneColumnSelected> {\\r\\n\\tpublic readonly values: { [TName in keyof TAsColumns]: GetInType<TAsColumns[TName]> }[] = [];\\r\\n\\r\\n\\tconstructor(public readonly columns: TAsColumns) {\\r\\n\\t\\tsuper();\\r\\n\\t}\\r\\n\\r\\n\\tpublic withValues(items: { [TName in keyof TAsColumns]: GetInType<TAsColumns[TName]> }[]): this {\\r\\n\\t\\tthis.values.push(...items);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\tpublic as(name: string): FromItemCtor<TAsColumns> {\\r\\n\\t\\tconst setters: ((fromItem: FromItem<any>) => void)[] = [];\\r\\n\\t\\tconst first = this.values[0];\\r\\n\\t\\tconst columns = toObject(objectEntries(this.columns), ([name]) => name, ([name, type]) => type);\\r\\n\\r\\n\\t\\treturn super.as(name, columns);\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/ValuesQuery.ts\n// module id = 238\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/ValuesQuery.ts?./~/raw-loader");

/***/ }),

/***/ 239:
/***/ (function(module, exports) {

eval("module.exports = \"import { FromItem } from \\\"../FromFactor\\\";\\r\\nimport { Query } from \\\"./Query\\\";\\r\\nimport { MapExpressionOrInputValue, Expression, and, toCondition } from \\\"../Expressions\\\";\\r\\nimport { Constructable } from \\\"./Common\\\";\\r\\nimport { BooleanType } from \\\"../Types\\\";\\r\\n\\r\\nexport interface WhereMixinInstance<TFromTblCols> {\\r\\n\\t/**\\r\\n\\t * Sets where conditions.\\r\\n\\t * @param obj The object that defines equals expressions.\\r\\n\\t */\\r\\n\\twhere(obj: Partial<MapExpressionOrInputValue<TFromTblCols>>): this;\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets where conditions.\\r\\n\\t * @param conditions The condition expressions.\\r\\n\\t */\\r\\n\\twhere(...conditions: Expression<BooleanType>[]): this;\\r\\n\\r\\n\\t/**\\r\\n\\t * Sets negated where conditions.\\r\\n\\t */\\r\\n\\twhereNot(condition: Expression<BooleanType>, ...conditions: Expression<BooleanType>[]): this;\\r\\n}\\r\\n\\r\\nexport function WhereMixin<BC extends Constructable<object>, TFromTblCols>(Base: BC): Constructable<WhereMixinInstance<TFromTblCols>> & BC {\\r\\n\\treturn class extends Base {\\r\\n\\t\\tprotected _whereCondition: Expression<BooleanType> | undefined;\\r\\n\\t\\tprotected lastFromItem: FromItem<TFromTblCols> | undefined;\\r\\n\\r\\n\\t\\tpublic where(obj: Partial<MapExpressionOrInputValue<TFromTblCols>>): this;\\r\\n\\t\\tpublic where(...conditions: Expression<BooleanType>[]): this;\\r\\n\\t\\tpublic where(...args: any[]): this {\\r\\n\\t\\t\\tconst expression = toCondition(this.lastFromItem, args);\\r\\n\\t\\t\\tthis._whereCondition = and(this._whereCondition, expression);\\r\\n\\t\\t\\treturn this;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic whereNot(condition: Expression<BooleanType>, ...conditions: Expression<BooleanType>[]): this {\\r\\n\\t\\t\\tthis._whereCondition = and(condition.not(), ...conditions.map(c => c.not()));\\r\\n\\t\\t\\treturn this;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Queries/WhereMixin.ts\n// module id = 239\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Queries/WhereMixin.ts?./~/raw-loader");

/***/ }),

/***/ 240:
/***/ (function(module, exports) {

eval("module.exports = \"import { DeleteQuery } from \\\"./Queries/DeleteQuery\\\";\\r\\nimport { InsertQuery } from \\\"./Queries/InsertQuery\\\";\\r\\nimport { SelectQuery } from \\\"./Queries/SelectQuery\\\";\\r\\nimport { UpdateQuery } from \\\"./Queries/UpdateQuery\\\";\\r\\nimport { ValuesQuery } from \\\"./Queries/ValuesQuery\\\";\\r\\n\\r\\nexport type SqlStatement = DeleteQuery<any, any, any> | InsertQuery<any, any, any> | SelectQuery<any, any, any> | UpdateQuery<any, any, any, any> | ValuesQuery<any> | StartTransactionStatement | CommitTransactionStatement;\\r\\n\\r\\nexport class StartTransactionStatement {\\r\\n\\tpublic toString() { return \\\"START TRANSACTION\\\"; }\\r\\n}\\r\\n\\r\\nexport class CommitTransactionStatement {\\r\\n\\tpublic toString() { return \\\"COMMIT\\\"; }\\r\\n}\\r\\n\\r\\nexport class RollbackTransactionStatement {\\r\\n\\tpublic toString() { return \\\"ROLLBACK\\\"; }\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/SqlStatement.ts\n// module id = 240\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/SqlStatement.ts?./~/raw-loader");

/***/ }),

/***/ 241:
/***/ (function(module, exports) {

eval("module.exports = \"import { Row, FromItem, RowToColumns, ColumnsToRow } from \\\"./FromFactor\\\";\\r\\nimport { TableColumn } from \\\"./Expressions\\\";\\r\\nimport { toObject, combine, objectEntries } from \\\"../Helpers\\\";\\r\\nimport { AnyType } from \\\"./Types\\\";\\r\\n\\r\\nexport interface TableName {\\r\\n\\tschema?: string,\\r\\n\\tname: string\\r\\n}\\r\\n\\r\\nexport class Table<TRequiredColumns extends Row, TOptionalColumns extends Row>\\r\\n\\t\\t\\textends FromItem<TRequiredColumns & TOptionalColumns> {\\r\\n\\tpublic $requiredColumns: RowToColumns<TRequiredColumns>;\\r\\n\\tpublic $optionalColumns: RowToColumns<TOptionalColumns>;\\r\\n\\r\\n\\tconstructor(public readonly $name: TableName, requiredColumns: RowToColumns<TRequiredColumns>, \\r\\n\\t\\t\\toptionalColumns: RowToColumns<TOptionalColumns>) {\\r\\n\\t\\tsuper(combine(requiredColumns, optionalColumns), false);\\r\\n\\r\\n\\t\\tthis.$requiredColumns = requiredColumns;\\r\\n\\t\\tthis.$optionalColumns = optionalColumns;\\r\\n\\t}\\r\\n\\r\\n\\tpublic toString() {\\r\\n\\t\\tlet str = \\\"\\\";\\r\\n\\t\\tif (this.$name.schema)\\r\\n\\t\\t\\tstr = `${this.$name.schema}.`\\r\\n\\t\\tstr += this.$name.name;\\r\\n\\t\\treturn str;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport type TableRequiredColumns<TTable extends Table<any, any>> = ColumnsToRow<TTable[\\\"$requiredColumns\\\"]>;\\r\\nexport type TableOptionalColumns<TTable extends Table<any, any>> = ColumnsToRow<TTable[\\\"$optionalColumns\\\"]>;\\r\\n\\r\\nexport type TableCtor<TRequiredColumns extends Row, TOptionalColumns extends Row> \\r\\n\\t= Table<TRequiredColumns, TOptionalColumns> & RowToColumns<TRequiredColumns & TOptionalColumns>;\\r\\n\\r\\nexport interface RowDescription { [columnName: string]: AnyType };\\r\\n\\r\\nexport type RowDescriptionToRow<TColumns extends RowDescription> = TColumns;\\r\\n\\r\\n/**\\r\\n * Declares a table.\\r\\n * @param tableName The name of the table.\\r\\n * @param requiredColumns Columns that need a value when inserting new rows.\\r\\n */\\r\\nexport function table<\\r\\n\\t\\tTColumnsWithTypes1 extends RowDescription>(\\r\\n\\t\\t\\ttableName: string | TableName,\\r\\n\\t\\t\\trequiredColumns: TColumnsWithTypes1,\\r\\n\\t\\t): TableCtor<RowDescriptionToRow<TColumnsWithTypes1>, {}>;\\r\\n/**\\r\\n * Declares a table.\\r\\n * @param tableName The name of the table.\\r\\n * @param requiredColumns Columns that need a value when inserting new rows.\\r\\n * @param optionalColumns Columns that don't need a value when inserting new rows.\\r\\n */\\r\\nexport function table<\\r\\n\\t\\tTColumnsWithTypes1 extends RowDescription,\\r\\n\\t\\tTColumnsWithTypes2 extends RowDescription>(\\r\\n\\t\\t\\ttableName: string | TableName,\\r\\n\\t\\t\\trequiredColumns: TColumnsWithTypes1,\\r\\n\\t\\t\\toptionalColumns: TColumnsWithTypes2\\r\\n\\t\\t):\\r\\n\\tTableCtor<RowDescriptionToRow<TColumnsWithTypes1>, RowDescriptionToRow<TColumnsWithTypes2>>;\\r\\nexport function table(tableName: string | TableName, requiredColumns: RowDescription, optionalColumns: RowDescription = {}) {\\r\\n\\t\\r\\n\\tconst setters: ((fromItem: FromItem<any>) => void)[] = [];\\r\\n\\tconst toTableColumn = (name: string, columnType: AnyType) => {\\r\\n\\t\\tif (!columnType) throw new Error(`Column '${name}' has no type.`);\\r\\n\\t\\treturn new TableColumn(name, columnType, setter => setters.push(setter));\\r\\n\\t};\\r\\n\\r\\n\\tconst reqColumns = toObject(objectEntries(requiredColumns)\\r\\n\\t\\t.map(([name, columnType]) => toTableColumn(name, columnType)), i => i.name);\\r\\n\\t\\t\\r\\n\\tconst optColumns = toObject(objectEntries(optionalColumns)\\r\\n\\t\\t.map(([name, columnType]) => toTableColumn(name, columnType)), i => i.name);\\r\\n\\t\\r\\n\\tconst tblName = (typeof tableName === \\\"string\\\") ? { name: tableName, schema: undefined } : tableName;\\r\\n\\r\\n\\tconst table = new Table(tblName, reqColumns, optColumns);\\r\\n\\tfor (const setter of setters)\\r\\n\\t\\tsetter(table);\\r\\n\\r\\n\\treturn table;\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Table.ts\n// module id = 241\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Table.ts?./~/raw-loader");

/***/ }),

/***/ 242:
/***/ (function(module, exports) {

eval("module.exports = \"import { Row } from \\\"./FromFactor\\\";\\r\\n\\r\\nexport type AnyType = Type<any, any, string>;\\r\\n\\r\\n\\r\\nexport type MapOutType<TRow extends Row> = { [TName in keyof TRow]: GetOutType<TRow[TName]> };\\r\\n\\r\\nexport type GetInType<TType extends any> = TType[\\\"_inType\\\"];\\r\\nexport type GetOutType<TType extends any> = TType[\\\"_outType\\\"];\\r\\n\\r\\nexport abstract class Type<TInType, TOutType, TBrand extends string> {\\r\\n\\tpublic readonly _brand: TBrand;\\r\\n\\tprivate _inType: TInType;\\r\\n\\tprivate _outType: TOutType;\\r\\n\\r\\n\\tpublic abstract serialize(arg: TInType): string|number|boolean|null;\\r\\n\\tpublic abstract deserialize(arg: string|number|boolean): TOutType;\\r\\n\\r\\n\\tpublic orNull(): Type<TInType|null, TOutType|null, TBrand|\\\"null\\\"> {\\r\\n\\t\\treturn new NullType(this);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class NullType<TInType, TOutType, TBrand extends string> extends Type<TInType|null, TOutType|null, TBrand|\\\"null\\\"> {\\r\\n\\tconstructor(private readonly type: Type<TInType, TOutType, TBrand>) {\\r\\n\\t\\tsuper();\\r\\n\\t}\\r\\n\\r\\n\\tpublic serialize(arg: TInType|null): string|number|boolean|null {\\r\\n\\t\\tif (arg === null) return null;\\r\\n\\t\\treturn this.type.serialize(arg);\\r\\n\\t}\\r\\n\\r\\n\\tpublic deserialize(arg: string|number|boolean|null): TOutType|null {\\r\\n\\t\\tif (arg === null) return null;\\r\\n\\t\\treturn this.type.deserialize(arg);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class VoidType extends Type<void, void, \\\"void\\\"> {\\r\\n\\tpublic serialize(arg: void): string|number|boolean|null { throw new Error(\\\"Void type does not support serialization\\\"); }\\r\\n\\tpublic deserialize(arg: string|number|boolean): void { throw new Error(\\\"Void type does not support deserialization\\\"); }\\r\\n}\\r\\nexport const tVoid = new VoidType();\\r\\n\\r\\nexport type RecordTypeToJson<T extends { _brand: string }> = RecordTypeToJson2<T>[\\\"result\\\"];\\r\\nexport type RecordTypeToJson1<T extends { result: any }> = { [TName in keyof T]: T[TName][\\\"result\\\"] };\\r\\nexport type RecordTypeToJson2<T extends { _brand: string }> =\\r\\n{\\r\\n\\tresult: // result is required for TypeScript to accept recursion\\r\\n\\t\\t(\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\trecord: RecordTypeToJson1<{ [TName in keyof T[\\\"_recordType\\\"]]: RecordTypeToJson2<T[\\\"_recordType\\\"][TName]> }>\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t&\\r\\n\\t\\t\\t{ [other: string]: GetInType<T> }\\r\\n\\t\\t)[T[\\\"_brand\\\"]]\\r\\n};\\r\\n\\r\\n// let test: RecordTypeToJson2<{ _brand: \\\"record\\\", _recordType: { p2: { _brand: \\\"record\\\", _recordType: { fooa: { _brand: \\\"record\\\", _recordType: { bla: IntegerType } } } } } }> = null!;\\r\\n\\r\\n\\r\\nexport function tJson<T>(): Json<T> {\\r\\n\\treturn new Json<T>();\\r\\n}\\r\\n\\r\\nexport class Json<T extends any> extends Type<T, T, \\\"json\\\"> {\\r\\n\\r\\n\\tserialize(arg: T): string|number|boolean {\\r\\n\\t\\treturn JSON.stringify(arg);\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): T {\\r\\n\\t\\tif (typeof arg !== \\\"string\\\") throw new Error(\\\"Arg must be of type string.\\\");\\r\\n\\r\\n\\t\\treturn JSON.parse(arg);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class Record<T> extends Type<never, string, \\\"record\\\"> {\\r\\n\\t_recordType: T;\\r\\n\\r\\n\\tserialize(arg: never): string|number|boolean {\\r\\n\\t\\tthrow \\\"\\\";\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string): string {\\r\\n\\t\\treturn arg;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport function tRecord<T>() {\\r\\n\\treturn new Record<T>();\\r\\n}\\r\\n\\r\\nexport class BooleanType extends Type<boolean, boolean, \\\"boolean\\\"> {\\r\\n\\r\\n\\tserialize(arg: boolean): string|number|boolean {\\r\\n\\t\\treturn arg;\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): boolean {\\r\\n\\t\\treturn !!arg;\\r\\n\\t}\\r\\n}\\r\\nexport const tBoolean = new BooleanType();\\r\\n\\r\\nexport class TextType extends Type<string, string, \\\"text\\\"> {\\r\\n\\r\\n\\tserialize(arg: string): string|number|boolean {\\r\\n\\t\\treturn arg;\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): string {\\r\\n\\t\\treturn \\\"\\\" + arg;\\r\\n\\t}\\r\\n}\\r\\nexport const tText = new TextType();\\r\\n\\r\\n\\r\\nexport class IntegerType extends Type<number, number, \\\"integer\\\"> {\\r\\n\\r\\n\\tserialize(arg: number): string|number|boolean {\\r\\n\\t\\treturn arg;\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): number {\\r\\n\\t\\treturn +arg;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport const tInteger = new IntegerType();\\r\\n\\r\\n\\r\\nexport class DateType extends Type<Date, Date, \\\"date\\\"> {\\r\\n\\tserialize(arg: Date): string|number|boolean {\\r\\n\\t\\treturn arg.toString();\\r\\n\\t}\\r\\n\\r\\n\\tdeserialize(arg: string|number|boolean): Date {\\r\\n\\t\\treturn new Date(\\\"\\\"+ arg);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport const tDate = new DateType();\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/AST/Types.ts\n// module id = 242\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/AST/Types.ts?./~/raw-loader");

/***/ }),

/***/ 243:
/***/ (function(module, exports) {

eval("module.exports = \"import { toObject } from '../Helpers';\\r\\nimport { RetrievalQuery } from '../AST/Queries/RetrievalQuery';\\r\\nimport { AnyType, MapOutType } from '../AST/Types';\\r\\nimport { SqlStatement } from '../AST/SqlStatement';\\r\\nimport pg = require('pg');\\r\\nimport { PostgreSqlGenerator } from \\\"./PostgreSqlGenerator\\\";\\r\\nimport { SqlGeneratorOptions } from \\\"../SqlGenerator\\\";\\r\\nimport { Query } from \\\"../AST/Queries/Query\\\";\\r\\nimport { DbQueryService, SimpleDbQueryService } from \\\"../DbConnection\\\";\\r\\nimport { EventEmitter, ISubscribable } from \\\"hediet-framework/api/events\\\";\\r\\nimport { Deferred } from \\\"hediet-framework/api/synchronization\\\";\\r\\n\\r\\n/* TODO\\r\\nexport class PostgreQueryServiceFactory {\\r\\n\\tconstructor(private readonly pgModule: typeof pg) {\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\r\\n\\tpublic createQueryService(connectionData: any) {\\r\\n\\r\\n\\t}\\r\\n}*/\\r\\n\\r\\nexport class PostgreQueryService implements DbQueryService {\\r\\n\\tpublic readonly sqlGenerator: PostgreSqlGenerator;\\r\\n\\tprivate readonly onSqlStatementEmitter = new EventEmitter<this, { sql: string, parameters: any[], query: SqlStatement, resultRows: Promise<any[]> }>();\\r\\n\\tpublic readonly onSqlStatement = this.onSqlStatementEmitter.asEvent();\\r\\n\\r\\n\\tconstructor(private readonly pool: pg.Pool, sqlGeneratorOptions: SqlGeneratorOptions = {}) {\\r\\n\\t\\tthis.sqlGenerator = new PostgreSqlGenerator(sqlGeneratorOptions);\\r\\n\\t}\\r\\n\\r\\n\\tpublic exec<TRow>(query: Query<TRow, any>): Promise<MapOutType<TRow>[]>;\\r\\n\\tpublic exec<TRow>(statement: SqlStatement): Promise<void>;\\r\\n\\tpublic exec(query: SqlStatement): Promise<any> {\\r\\n\\t\\treturn this.execClient(query);\\r\\n\\t}\\r\\n\\r\\n\\tprivate async execClient(query: SqlStatement, client?: pg.Client): Promise<any> {\\r\\n\\t\\tconst { sql:queryText, parameters } = this.sqlGenerator.toSql(query);\\r\\n\\t\\tconst resultRows = new Deferred<any[]>();\\r\\n\\t\\tthis.onSqlStatementEmitter.emit(this, { sql: queryText, parameters: parameters, query: query, resultRows: resultRows.value });\\r\\n\\r\\n\\t\\tconst result = await (client ? client.query(queryText, parameters) : this.pool.query(queryText, parameters));\\r\\n\\r\\n\\t\\tlet updatedRows = result.rows;\\r\\n\\r\\n/*\\r\\n\\t\\tif (query instanceof RetrievalQuery) {\\r\\n\\t\\t\\tconst cols = query.getState().returningColumns;\\r\\n\\t\\t\\tupdatedRows = updatedRows.map(row => {\\r\\n\\t\\t\\t\\tconst result = {} as any;\\r\\n\\t\\t\\t\\tfor (const prop of row) {\\r\\n\\t\\t\\t\\t\\tconst val = row[prop];\\r\\n\\t\\t\\t\\t\\tconst type = cols[prop] as AnyType;\\r\\n\\t\\t\\t\\t\\tresult[prop] = type.deserialize(val);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n*/\\r\\n\\r\\n\\t\\tresultRows.setValue(updatedRows);\\r\\n\\t\\treturn updatedRows;\\r\\n\\t}\\r\\n\\r\\n\\tpublic getExclusiveQueryService<T>(scope: (service: SimpleDbQueryService) => Promise<T>): Promise<T> {\\r\\n\\t\\treturn new Promise((res, rej) => this.pool.connect((err, client, done) => {\\r\\n\\t\\t\\tif (err) { rej(err); return; }\\r\\n\\r\\n\\t\\t\\tconst service = new this.PostgreExclusiveQueryService(client, this);\\r\\n\\t\\t\\tscope(service)\\r\\n\\t\\t\\t\\t.then(result => {\\r\\n\\t\\t\\t\\t\\tdone();\\r\\n\\t\\t\\t\\t\\tres(result);\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.catch(err => {\\r\\n\\t\\t\\t\\t\\tdone();\\r\\n\\t\\t\\t\\t\\trej(err);\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t}));\\r\\n\\t}\\r\\n\\r\\n\\tprivate readonly PostgreExclusiveQueryService = class PostgreExclusiveQueryService implements SimpleDbQueryService {\\r\\n\\t\\tconstructor(private readonly client: pg.Client, private readonly queryService: PostgreQueryService) {}\\r\\n\\r\\n\\t\\tpublic exec<TColumns>(query: Query<TColumns, any>): Promise<TColumns[]>;\\r\\n\\t\\tpublic exec<TColumns>(statement: SqlStatement): Promise<void>;\\r\\n\\t\\tpublic async exec(query: SqlStatement): Promise<any> {\\r\\n\\t\\t\\treturn this.queryService.execClient(query, this.client);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/Adapters/Postgre.ts\n// module id = 243\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/Adapters/Postgre.ts?./~/raw-loader");

/***/ }),

/***/ 244:
/***/ (function(module, exports) {

eval("module.exports = \"import { SqlGenerator, Context, ExpressionContext } from \\\"../SqlGenerator\\\";\\r\\nimport { ValueExpression } from \\\"../AST/Expressions\\\";\\r\\nimport { AnyType } from \\\"../index\\\";\\r\\n\\r\\nexport class PostgreSqlGenerator extends SqlGenerator {\\r\\n\\tprotected quoteSchemaOrTableOrColumnName(name: string): string {\\r\\n\\t\\tif (this.options.skipQuotingIfNotRequired && /^[a-z_][a-z_0-9]*$/.test(name))\\r\\n\\t\\t\\treturn name;\\r\\n\\t\\treturn this.escapeIdentifier(name);\\r\\n\\t}\\r\\n\\r\\n\\tprotected escapeValue(expr: ValueExpression<AnyType>, context: ExpressionContext): string {\\r\\n\\t\\tconst val = expr.type.serialize(expr.value);\\r\\n\\r\\n\\t\\tif (expr.preferEscaping) {\\r\\n\\t\\t\\tif (val === null) return \\\"null\\\";\\r\\n\\t\\t\\tif (typeof val === \\\"string\\\") return this.escapeLiteral(val);\\r\\n\\t\\t\\tif (typeof val === \\\"number\\\") return val.toString();\\r\\n\\t\\t\\tif (typeof val === \\\"boolean\\\") return val.toString();\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthrow new Error(`Unsupported value: '${val}'.`);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tcontext.context.parameters.push(val);\\r\\n\\t\\t\\tconst id = context.context.parameters.length;\\r\\n\\t\\t\\treturn `$${id}`;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t// https://github.com/brianc/node-postgres/blob/f42924bf057943d5a79ff02c4d35b18777dc5754/lib/client.js#L261\\r\\n\\tprivate escapeIdentifier(str: string) {\\r\\n\\t\\tlet escaped = '\\\"';\\r\\n\\r\\n\\t\\tfor (let i = 0; i < str.length; i++) {\\r\\n\\t\\t\\tconst c = str[i];\\r\\n\\t\\t\\tif (c === '\\\"') {\\r\\n\\t\\t\\t\\tescaped += c + c;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tescaped += c;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tescaped += '\\\"';\\r\\n\\t\\treturn escaped;\\r\\n\\t}\\r\\n\\r\\n\\t// https://github.com/brianc/node-postgres/blob/f42924bf057943d5a79ff02c4d35b18777dc5754/lib/client.js#L280\\r\\n\\tprivate escapeLiteral(str: string) {\\r\\n\\t\\tlet hasBackslash = false;\\r\\n\\t\\tlet escaped = '\\\\'';\\r\\n\\r\\n\\t\\tfor(let i = 0; i < str.length; i++) {\\r\\n\\t\\t\\tconst c = str[i];\\r\\n\\t\\t\\tif(c === '\\\\'') {\\r\\n\\t\\t\\t\\tescaped += c + c;\\r\\n\\t\\t\\t} else if (c === '\\\\\\\\') {\\r\\n\\t\\t\\t\\tescaped += c + c;\\r\\n\\t\\t\\t\\thasBackslash = true;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tescaped += c;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tescaped += '\\\\'';\\r\\n\\r\\n\\t\\tif(hasBackslash === true) {\\r\\n\\t\\t\\tescaped = ' E' + escaped;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn escaped;\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/Adapters/PostgreSqlGenerator.ts\n// module id = 244\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/Adapters/PostgreSqlGenerator.ts?./~/raw-loader");

/***/ }),

/***/ 245:
/***/ (function(module, exports) {

eval("module.exports = \"import { CommitTransactionStatement, RollbackTransactionStatement, SqlStatement, StartTransactionStatement } from './AST/SqlStatement';\\r\\nimport { Query } from \\\"./AST/Queries/Query\\\";\\r\\nimport { RetrievalQuery } from \\\"./AST/Queries/RetrievalQuery\\\";\\r\\nimport { GetOutType, MapOutType } from \\\"./AST/Types\\\";\\r\\nimport { Row } from \\\"./AST/FromFactor\\\";\\r\\n\\r\\nexport interface SimpleDbQueryService {\\r\\n\\texec<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow>[]>;\\r\\n\\texec<TRow extends Row>(statement: SqlStatement): Promise<void>;\\r\\n}\\r\\n\\r\\nexport interface DbQueryService extends SimpleDbQueryService {\\r\\n\\tgetExclusiveQueryService<T>(scope: (service: SimpleDbQueryService) => Promise<T>): Promise<T>;\\r\\n}\\r\\n\\r\\nexport class DbQueryInterface {\\r\\n\\tconstructor(protected readonly queryService: SimpleDbQueryService) { }\\r\\n\\r\\n\\tpublic exec<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow>[]>;\\r\\n\\tpublic exec<TRow extends Row>(statement: SqlStatement): Promise<void>;\\r\\n\\tpublic exec<TRow extends Row>(statement: SqlStatement): Promise<MapOutType<TRow>[]> | Promise<void> {\\r\\n\\t\\treturn this.queryService.exec(statement);\\r\\n\\t}\\r\\n\\r\\n\\tpublic async values<TRow extends Row, TColumn extends keyof TRow>(query: Query<TRow, TColumn>): Promise<GetOutType<TRow[TColumn]>[]> {\\r\\n\\t\\tconst rows = await this.exec(query);\\r\\n\\t\\treturn rows.map(r => r[query.singleColumn]);\\r\\n\\t}\\r\\n\\r\\n\\tpublic async firstOrUndefined<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow> | undefined> {\\r\\n\\t\\tif (query instanceof RetrievalQuery)\\r\\n\\t\\t\\tquery = query.limit(1);\\r\\n\\t\\tconst rows = await this.exec(query);\\r\\n\\t\\treturn rows[0];\\r\\n\\t}\\r\\n\\r\\n\\tpublic async first<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow>> {\\r\\n\\t\\tconst result = await this.firstOrUndefined(query);\\r\\n\\t\\tif (!result) throw new Error(\\\"Expected at least one row.\\\");\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n\\tpublic async single<TRow extends Row>(query: Query<TRow, any>): Promise<MapOutType<TRow>> {\\r\\n\\t\\tif (query instanceof RetrievalQuery)\\r\\n\\t\\t\\tquery = query.limit(2);\\r\\n\\t\\tconst rows = await this.exec(query);\\r\\n\\t\\tif (rows.length === 0) throw new Error(\\\"No row found.\\\");\\r\\n\\t\\tif (rows.length >= 2) throw new Error(\\\"More than one row returned.\\\");\\r\\n\\t\\treturn rows[0];\\r\\n\\t}\\r\\n\\r\\n\\tpublic async firstOrUndefinedValue<TRow extends Row, TColumn extends keyof TRow>(query: Query<TRow, TColumn>): Promise<GetOutType<TRow[TColumn]> | undefined> {\\r\\n\\t\\tconst row = await this.firstOrUndefined(query);\\r\\n\\t\\tif (!row) return undefined;\\r\\n\\t\\treturn row[query.singleColumn];\\r\\n\\t}\\r\\n\\r\\n\\tpublic async firstValue<TRow extends Row, TColumn extends keyof TRow>(query: Query<TRow, TColumn>): Promise<GetOutType<TRow[TColumn]>> {\\r\\n\\t\\tconst row = await this.first(query);\\r\\n\\t\\treturn row[query.singleColumn];\\r\\n\\t}\\r\\n\\r\\n\\tpublic async singleValue<TRow extends Row, TColumn extends keyof TRow>(query: Query<TRow, TColumn>): Promise<GetOutType<TRow[TColumn]>> {\\r\\n\\t\\tconst row = await this.single(query);\\r\\n\\t\\treturn row[query.singleColumn];\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class TransactingQueryService extends DbQueryInterface {\\r\\n\\tprivate _isTransactionOpen: boolean = true;\\r\\n\\r\\n\\tpublic get isTransactionOpen(): boolean { return this._isTransactionOpen; }\\r\\n\\r\\n\\tpublic exec<TColumns>(query: Query<TColumns, any>): Promise<TColumns[]>;\\r\\n\\tpublic exec<TColumns>(statement: SqlStatement): Promise<void>;\\r\\n\\tpublic exec<TColumns>(statement: SqlStatement): Promise<TColumns[]> | Promise<void> {\\r\\n\\t\\tif (!this._isTransactionOpen) throw new Error(`Could not execute statement '${statement}': Transaction already has been either committed or rolled back.`);\\r\\n\\t\\treturn super.exec(statement);\\r\\n\\t}\\r\\n\\r\\n\\tpublic async rollback() {\\r\\n\\t\\tawait this.exec(new RollbackTransactionStatement());\\r\\n\\t\\tthis._isTransactionOpen = false;\\r\\n\\t}\\r\\n\\r\\n\\tpublic async commit() {\\r\\n\\t\\tawait this.exec(new CommitTransactionStatement());\\r\\n\\t\\tthis._isTransactionOpen = false;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexport class DbConnection extends DbQueryInterface {\\r\\n\\tconstructor(protected readonly queryService: DbQueryService) { super(queryService); }\\r\\n\\r\\n\\tpublic async transaction<T>(scope: (queryInterface: TransactingQueryService) => Promise<T>): Promise<T> {\\r\\n\\t\\treturn this.queryService.getExclusiveQueryService(async s => {\\r\\n\\t\\t\\tconst queryInterface = new TransactingQueryService(s);\\r\\n\\t\\t\\tawait queryInterface.exec(new StartTransactionStatement());\\r\\n\\t\\t\\tlet error = undefined;\\r\\n\\t\\t\\tlet result: { success: true, result: T } | { success: false, error: any };\\r\\n\\t\\t\\ttry {\\r\\n\\t\\t\\t\\tresult = { success: true, result: await scope(queryInterface) };\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcatch (err) {\\r\\n\\t\\t\\t\\tresult = { success: false, error: err };\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (result.success) {\\r\\n\\t\\t\\t\\tif (queryInterface.isTransactionOpen)\\r\\n\\t\\t\\t\\t\\tawait queryInterface.commit();\\r\\n\\t\\t\\t\\treturn result.result;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tif (queryInterface.isTransactionOpen)\\r\\n\\t\\t\\t\\t\\tawait queryInterface.rollback();\\r\\n\\t\\t\\t\\tthrow result.error;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/DbConnection.ts\n// module id = 245\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/DbConnection.ts?./~/raw-loader");

/***/ }),

/***/ 246:
/***/ (function(module, exports) {

eval("module.exports = \"\\r\\nexport function toObject<T, K>(item: T[], keySelector: (item: T) => K): any\\r\\nexport function toObject<T, K, V>(item: T[], keySelector: (item: T) => K, valueSelector: (item: T) => V): any\\r\\nexport function toObject<T, K, V>(item: T[], keySelector: (item: T) => K, valueSelector?: (item: T) => V): any {\\r\\n\\tconst o = {} as any;\\r\\n\\tfor (const i of item) {\\r\\n\\t\\to[keySelector(i)] = valueSelector ? valueSelector(i) : i;\\r\\n\\t}\\r\\n\\treturn o;\\r\\n}\\r\\n\\r\\nexport function secondWithTypeOfFirst<T1>(t1: T1, t2: any): T1 {\\r\\n\\treturn t2;\\r\\n}\\r\\n\\r\\nexport function objectValues<T extends {}>(obj: T): T[keyof T][] {\\r\\n\\tconst result: T[keyof T][] = [];\\r\\n\\tfor (const prop of Object.getOwnPropertyNames(obj) as (keyof T)[]) {\\r\\n\\t\\tresult.push(obj[prop]);\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nexport function objectEntries<T extends {}>(obj: T): [keyof T, T[keyof T]][] {\\r\\n\\tconst result: [keyof T, T[keyof T]][] = [];\\r\\n\\tfor (const prop of Object.getOwnPropertyNames(obj) as (keyof T)[]) {\\r\\n\\t\\tresult.push([prop, obj[prop]]);\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nexport function combine<T1, T2>(props: T1, and: T2): T1 & T2 {\\r\\n\\tconst result: any = {};\\r\\n\\tfor (const [prop, val] of objectEntries(props)) {\\r\\n\\t\\tresult[prop] = val;\\r\\n\\t}\\r\\n\\tfor (const [prop, val] of objectEntries(and)) {\\r\\n\\t\\tresult[prop] = val;\\r\\n\\t}\\r\\n\\treturn result;\\r\\n}\\r\\n\\r\\nexport class DynamicDispatcher<TBase, TArgs, TResult> {\\r\\n\\tprivate registeredHandlers = new Map<Function, (subject: TBase, arg: TArgs) => TResult>();\\r\\n\\r\\n\\tpublic register<T extends TBase>(clazz: (new (...args: any[]) => T) | Function, handler: (subject: T, arg: TArgs) => TResult) {\\r\\n\\t\\tthis.registeredHandlers.set(clazz, handler);\\r\\n\\t\\treturn this;\\r\\n\\t}\\r\\n\\r\\n\\tpublic dispatch(obj: TBase, args: TArgs): TResult {\\r\\n\\t\\tlet proto = Object.getPrototypeOf(obj);\\r\\n\\t\\twhile (proto) {\\r\\n\\t\\t\\tconst handler = this.registeredHandlers.get(proto.constructor);\\r\\n\\t\\t\\tif (handler) {\\r\\n\\t\\t\\t\\treturn handler(obj, args);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tproto = Object.getPrototypeOf(proto);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthrow new Error(`No handler was registered for '${obj}'.`);\\r\\n\\t}\\r\\n}\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/Helpers.ts\n// module id = 246\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/Helpers.ts?./~/raw-loader");

/***/ }),

/***/ 247:
/***/ (function(module, exports) {

eval("module.exports = \"import { UnionQuery } from './AST/Queries/RetrievalQuery';\\r\\nimport { ValuesQuery } from './AST/Queries/ValuesQuery';\\r\\nimport { InsertQuery } from './AST/Queries/InsertQuery';\\r\\nimport { UpdateQuery } from './AST/Queries/UpdateQuery';\\r\\nimport { DeleteQuery } from './AST/Queries/DeleteQuery';\\r\\nimport { SqlStatement, CommitTransactionStatement, RollbackTransactionStatement, StartTransactionStatement } from './AST/SqlStatement';\\r\\nimport {\\r\\n\\tFromFactor,\\r\\n\\tFromFactorAbstractConditionalJoin,\\r\\n\\tFromFactorAbstractJoin,\\r\\n\\tFromFactorCrossJoin,\\r\\n\\tFromFactorFullJoin,\\r\\n\\tFromFactorInnerJoin,\\r\\n\\tFromFactorLeftJoin,\\r\\n\\tFromItem,\\r\\n\\tisCastToColumns,\\r\\n\\tNamedFromItem,\\r\\n\\tQueryFromItem\\r\\n} from './AST/FromFactor';\\r\\nimport { Query } from \\\"./AST/Queries/Query\\\";\\r\\nimport { SelectQuery } from \\\"./AST/Queries/SelectQuery\\\";\\r\\nimport * as Exprs from './AST/Expressions';\\r\\nimport { Table, TableName } from \\\"./AST/Table\\\";\\r\\nimport { isOrderingAsc } from \\\"./AST/Ordering\\\";\\r\\nimport { objectValues, objectEntries, DynamicDispatcher } from \\\"./Helpers\\\";\\r\\nimport { AnyType } from \\\"./index\\\";\\r\\n\\r\\nexport interface SqlGeneratorOptions {\\r\\n\\tshortenColumnNameIfUnambigous?: boolean;\\r\\n\\tskipQuotingIfNotRequired?: boolean;\\r\\n}\\r\\n\\r\\n\\r\\nexport interface ExpressionContext {\\r\\n\\tisColumnNameUnambigous(name: string): boolean;\\r\\n\\tresolveNamedExpression: boolean;\\r\\n\\tcontext: Context;\\r\\n}\\r\\n\\r\\nexport interface Context {\\r\\n\\tparameters: any[];\\r\\n}\\r\\n\\r\\n// IMPORTANT IMPLEMENTATION NOTICE: expressions must be generated in the order they appear in the final sql string!\\r\\n// Otherwise prepared statements with parameters get messed up.\\r\\n\\r\\nexport abstract class SqlGenerator {\\r\\n\\tconstructor(protected readonly options: SqlGeneratorOptions = {}) { }\\r\\n\\r\\n\\tpublic toSql(statement: SqlStatement): { sql: string, parameters: any[] } {\\r\\n\\t\\tconst context: Context = { parameters: [] };\\r\\n\\t\\tconst sql = this.transformToSql(statement, context);\\r\\n\\t\\treturn { sql, parameters: context.parameters };\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformToSql(statement: SqlStatement, context: Context): string {\\r\\n\\t\\tif (statement instanceof SelectQuery) return this.transformSelectQueryToSql(statement, context);\\r\\n\\t\\tif (statement instanceof UpdateQuery) return this.transformUpdateQueryToSql(statement, context);\\r\\n\\t\\tif (statement instanceof InsertQuery) return this.transformInsertQueryToSql(statement, context);\\r\\n\\t\\tif (statement instanceof DeleteQuery) return this.transformDeleteQueryToSql(statement, context);\\r\\n\\t\\tif (statement instanceof ValuesQuery) return this.transformValuesQueryToSql(statement, context);\\r\\n\\r\\n\\t\\tif (statement instanceof UnionQuery) return this.transformUnionQueyToSql(statement, context);\\r\\n\\r\\n\\t\\tif (statement instanceof StartTransactionStatement) return \\\"BEGIN\\\";\\r\\n\\t\\tif (statement instanceof CommitTransactionStatement) return \\\"COMMIT\\\";\\r\\n\\t\\tif (statement instanceof RollbackTransactionStatement) return \\\"ROLLBACK\\\";\\r\\n\\r\\n\\t\\tthrow new Error(`Unsupported query: ${statement}`);\\r\\n\\t}\\r\\n\\r\\n\\tprotected createExpressionContext(froms: (FromFactor | undefined)[], context: Context): ExpressionContext {\\r\\n\\t\\tif (!this.options.shortenColumnNameIfUnambigous)\\r\\n\\t\\t\\treturn { isColumnNameUnambigous: name => false, resolveNamedExpression: false, context };\\r\\n\\r\\n\\t\\tlet allColumns: Exprs.Column<any, any>[] = [];\\r\\n\\t\\tfor (const from of froms) {\\r\\n\\t\\t\\tif (!from) continue;\\r\\n\\r\\n\\t\\t\\tconst allFromFactors = FromFactor.getAllFromFactors(from);\\r\\n\\r\\n\\t\\t\\tallColumns = allColumns.concat(\\r\\n\\t\\t\\t\\t...allFromFactors.map(f => objectValues(f.$columns)));\\r\\n\\t\\t}\\r\\n\\t\\tconst set = new Set<string>();\\r\\n\\t\\tconst duplicates = new Set<string>();\\r\\n\\t\\tfor (const col of allColumns) {\\r\\n\\t\\t\\tif (set.has(col.name)) duplicates.add(col.name);\\r\\n\\t\\t\\telse set.add(col.name);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn { isColumnNameUnambigous: name => !duplicates.has(name), resolveNamedExpression: false, context };\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformUnionQueyToSql(query: UnionQuery<any, any>, context: Context): string {\\r\\n\\t\\tconst query1Sql = this.transformToSql(query.query1, context);\\r\\n\\t\\tconst query2Sql = this.transformToSql(query.query2, context);\\r\\n\\r\\n\\t\\treturn `(${query1Sql}) UNION (${query2Sql})`;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformValuesQueryToSql(query: ValuesQuery<any>, context: Context): string {\\r\\n\\t\\tconst columns = query.columns;\\r\\n\\r\\n\\t\\tif (query.values.length === 0) {\\r\\n\\t\\t\\treturn `SELECT ${Object.keys(columns).map(k => \\\"null\\\").join(\\\", \\\")} WHERE false`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tlet sql = \\\"VALUES \\\";\\r\\n\\r\\n\\t\\tconst expressionContext: ExpressionContext = { isColumnNameUnambigous: c => true, resolveNamedExpression: true, context };\\r\\n\\r\\n\\t\\tsql += query.values.map(v =>\\r\\n\\t\\t\\t`(${objectEntries(columns).map(([name, type]) => this.escapeValue(new Exprs.ValueExpression(type, v[name]), expressionContext)).join(\\\", \\\")})`\\r\\n\\t\\t).join(\\\", \\\");\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformInsertQueryToSql(query: InsertQuery<any, any, any>, context: Context): string {\\r\\n\\t\\tconst data = query.getState();\\r\\n\\t\\tlet sql = `INSERT INTO ${this.referToFromItem(data.table)}`;\\r\\n\\r\\n\\t\\tconst expressionContext: ExpressionContext = { isColumnNameUnambigous: c => true, resolveNamedExpression: true, context };\\r\\n\\r\\n\\t\\tif (Array.isArray(data.values)) {\\r\\n\\t\\t\\tif (data.values.length === 0) {\\r\\n\\t\\t\\t\\tsql += ` (SELECT null WHERE false)`;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tconst firstRow = data.values[0];\\r\\n\\t\\t\\t\\tconst columnNames = Object.keys(firstRow);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfor (const selectedCol of columnNames) {\\r\\n\\t\\t\\t\\t\\tif (!(selectedCol in data.table.$columns))\\r\\n\\t\\t\\t\\t\\t\\tthrow new Error(`Column '${selectedCol}' does not exist on table '${data.table}'.`);\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tsql += `(${columnNames.map(c => this.quoteColumnName(c)).join(\\\", \\\")}) VALUES `;\\r\\n\\t\\t\\t\\tsql += data.values.map(v => `(${columnNames.map(colName => \\r\\n\\t\\t\\t\\t\\tthis.escapeValue(Exprs.val(v[colName], data.table.$columns[colName].type), expressionContext)).join(\\\", \\\")})`).join(\\\", \\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tconst s = data.values.getState();\\r\\n\\t\\t\\tconst columnNames = s.selected.map(selectedCol => {\\r\\n\\t\\t\\t\\tif (selectedCol instanceof Exprs.AllExpression)\\r\\n\\t\\t\\t\\t\\tthrow new Error(\\\"AllExpressions in insert into query are not supported.\\\");\\r\\n\\t\\t\\t\\tif (!(selectedCol.name in data.table.$columns))\\r\\n\\t\\t\\t\\t\\tthrow new Error(`Column '${selectedCol.name}' does not exist on table '${data.table}'.`);\\r\\n\\t\\t\\t\\treturn selectedCol.name;\\r\\n\\t\\t\\t});\\r\\n\\r\\n\\t\\t\\tsql += `(${columnNames.map(c => this.quoteColumnName(c)).join(\\\", \\\")}) ${this.transformToSql(data.values, context)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.selected.length > 0) {\\r\\n\\t\\t\\tsql += \\\" RETURNING \\\" + this.toSelectStatementStr(data.selected, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformDeleteQueryToSql(query: DeleteQuery<any, any, any>, context: Context): string {\\r\\n\\t\\tconst data = query.getState();\\r\\n\\t\\tlet sql = `DELETE FROM ${this.referToFromItem(data.table)}`;\\r\\n\\r\\n\\t\\tconst expressionContext = this.createExpressionContext([data.using, data.table], context);\\r\\n\\r\\n\\t\\tif (data.using) {\\r\\n\\t\\t\\tsql += ` USING ${this.fromToSql(data.using, expressionContext)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!data.whereCondition) throw new Error(\\\"Delete Queries must have a where condition.\\\");\\r\\n\\t\\tsql += ` WHERE ${this.expressionToSql(data.whereCondition, expressionContext)}`;\\r\\n\\r\\n\\t\\tif (data.selected.length > 0) {\\r\\n\\t\\t\\tsql += \\\" RETURNING \\\" + this.toSelectStatementStr(data.selected, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformUpdateQueryToSql(query: UpdateQuery<any, any, any, any>, context: Context): string {\\r\\n\\t\\tconst data = query.getState();\\r\\n\\t\\tlet sql = `UPDATE ${this.referToFromItem(data.table)}`;\\r\\n\\r\\n\\t\\tconst expressionContext = this.createExpressionContext([data.from, data.table], context);\\r\\n\\r\\n\\t\\tsql += \\\" SET \\\" + objectEntries(data.updatedColumns).map(([name, value]: [string, Exprs.Expression<any>]) =>\\r\\n\\t\\t\\t`${this.quoteColumnName(name)} = ${this.expressionToSql(value, expressionContext)}`\\r\\n\\t\\t).join(\\\", \\\");\\r\\n\\r\\n\\t\\tif (data.from) {\\r\\n\\t\\t\\tsql += ` FROM ${this.fromToSql(data.from, expressionContext)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!data.whereCondition) throw new Error(\\\"Update Queries must have a where condition.\\\");\\r\\n\\t\\tsql += ` WHERE ${this.expressionToSql(data.whereCondition, expressionContext)}`;\\r\\n\\r\\n\\t\\tif (data.selected.length > 0) {\\r\\n\\t\\t\\tsql += \\\" RETURNING \\\" + this.toSelectStatementStr(data.selected, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected transformSelectQueryToSql(query: SelectQuery<any, any, any>, context: Context): string {\\r\\n\\t\\tconst data = query.getState();\\r\\n\\t\\tlet sql = \\\"SELECT\\\";\\r\\n\\r\\n\\t\\tconst expressionContext = this.createExpressionContext([data.from], context);\\r\\n\\r\\n\\t\\tif (data.selected.length > 0) {\\r\\n\\t\\t\\tsql += \\\" \\\" + this.toSelectStatementStr(data.selected, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.from) {\\r\\n\\t\\t\\tsql += ` FROM ${this.fromToSql(data.from, expressionContext)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.whereCondition) {\\r\\n\\t\\t\\tsql += ` WHERE ${this.expressionToSql(data.whereCondition, expressionContext)}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.groupBys.length > 0) {\\r\\n\\t\\t\\tconst exprCt = { isColumnNameUnambigous: expressionContext.isColumnNameUnambigous, resolveNamedExpression: false, context: context };\\r\\n\\t\\t\\tconst statements = data.groupBys.map(e => this.expressionToSql(e, exprCt)).join(\\\", \\\");\\r\\n\\t\\t\\tsql += ` GROUP BY ${statements}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.havingCondition) {\\r\\n\\t\\t\\tconst havingCondition = this.expressionToSql(data.havingCondition,\\r\\n\\t\\t\\t\\t{ isColumnNameUnambigous: expressionContext.isColumnNameUnambigous, resolveNamedExpression: true, context: context });\\r\\n\\t\\t\\tsql += ` HAVING ${havingCondition}`;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.orderBys.length > 0) {\\r\\n\\t\\t\\tsql += \\\" ORDER BY \\\" + data.orderBys.map(d => isOrderingAsc(d) ? this.expressionToSql(d.asc, expressionContext) : (this.expressionToSql(d.desc, expressionContext) + \\\" DESC\\\"));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (data.limit) {\\r\\n\\t\\t\\tsql += \\\" LIMIT \\\" + this.expressionToSql(data.limit, expressionContext);\\r\\n\\t\\t}\\r\\n\\t\\tif (data.offset) {\\r\\n\\t\\t\\tsql += \\\" OFFSET \\\" + this.expressionToSql(data.offset, expressionContext);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn sql;\\r\\n\\t}\\r\\n\\r\\n\\tprotected toSelectStatementStr(selected: (Exprs.NamedExpression<string, AnyType> | Exprs.AllExpression<object>)[], context: ExpressionContext): string {\\r\\n\\t\\treturn selected.map(expr => {\\r\\n\\t\\t\\tif (expr instanceof Exprs.NamedExpressionWrapper) {\\r\\n\\t\\t\\t\\treturn `${this.expressionToSql(expr.expression, context)} AS ${this.quoteColumnName(expr.name)}`;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn this.expressionToSql(expr, context);\\r\\n\\t\\t}).join(\\\", \\\");\\r\\n\\t}\\r\\n\\r\\n\\tprotected quoteSchemaName(name: string): string {\\r\\n\\t\\treturn this.quoteSchemaOrTableOrColumnName(name);\\r\\n\\t}\\r\\n\\r\\n\\tprotected quoteTableName(name: string): string {\\r\\n\\t\\treturn this.quoteSchemaOrTableOrColumnName(name);\\r\\n\\t}\\r\\n\\r\\n\\tprotected quoteColumnName(name: string): string {\\r\\n\\t\\treturn this.quoteSchemaOrTableOrColumnName(name);\\r\\n\\t}\\r\\n\\r\\n\\tprotected abstract quoteSchemaOrTableOrColumnName(name: string): string;\\r\\n\\r\\n\\tprotected referToFromItem(fromItem: FromItem<any>, includeSchema: boolean = true): string {\\r\\n\\t\\tif (fromItem instanceof Table) {\\r\\n\\t\\t\\tlet result = \\\"\\\";\\r\\n\\t\\t\\tif (fromItem.$name.schema && includeSchema) result += this.quoteSchemaName(fromItem.$name.schema) + \\\".\\\";\\r\\n\\t\\t\\tresult += this.quoteTableName(fromItem.$name.name);\\r\\n\\t\\t\\treturn result;\\r\\n\\t\\t}\\r\\n\\t\\telse if (fromItem instanceof NamedFromItem || fromItem instanceof QueryFromItem) {\\r\\n\\t\\t\\treturn this.quoteTableName(fromItem.$name);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthrow \\\"Unsupported\\\";\\r\\n\\t}\\r\\n\\r\\n\\tprivate fromFactorDispatcherInitialized = false;\\r\\n\\tprivate fromFactorDispatcher = new DynamicDispatcher<FromFactor, ExpressionContext, string>();\\r\\n\\r\\n\\tprivate fromToSql(f: FromFactor, context: ExpressionContext): string {\\r\\n\\t\\tif (!this.fromFactorDispatcherInitialized) {\\r\\n\\t\\t\\tthis.fromFactorDispatcherInitialized = true;\\r\\n\\r\\n\\t\\t\\tthis.fromFactorDispatcher\\r\\n\\t\\t\\t\\t.register(Table, (f, context) => {\\r\\n\\t\\t\\t\\t\\treturn this.referToFromItem(f);\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(NamedFromItem, (f, context) => {\\r\\n\\t\\t\\t\\t\\tconst oldName = this.referToFromItem(f.fromItem);\\r\\n\\t\\t\\t\\t\\tconst newName = this.referToFromItem(f);\\r\\n\\r\\n\\t\\t\\t\\t\\tlet sql = `${oldName} AS ${newName}`;\\r\\n\\t\\t\\t\\t\\tif (isCastToColumns(f))\\r\\n\\t\\t\\t\\t\\t\\tsql += `(${Object.keys(f.$columns).join(\\\", \\\")})`;\\r\\n\\t\\t\\t\\t\\treturn sql;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(QueryFromItem, (f, context) => {\\r\\n\\t\\t\\t\\t\\tconst newName = this.referToFromItem(f);\\r\\n\\r\\n\\t\\t\\t\\t\\tlet sql = `(${this.transformToSql(f.query, context.context)}) AS ${newName}`;\\r\\n\\t\\t\\t\\t\\tif (isCastToColumns(f))\\r\\n\\t\\t\\t\\t\\t\\tsql += `(${Object.keys(f.$columns).join(\\\", \\\")})`;\\r\\n\\t\\t\\t\\t\\treturn sql;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(FromFactorAbstractJoin, (f, context) => {\\r\\n\\t\\t\\t\\t\\tconst left = this.fromToSql(f.leftArg, context);\\r\\n\\t\\t\\t\\t\\tconst right = this.fromToSql(f.rightArg, context);\\r\\n\\r\\n\\t\\t\\t\\t\\tlet sql: string;\\r\\n\\t\\t\\t\\t\\tif (f instanceof FromFactorAbstractConditionalJoin) {\\r\\n\\t\\t\\t\\t\\t\\tconst condition = this.expressionToSql(f.joinCondition, context);\\r\\n\\t\\t\\t\\t\\t\\tlet join: string;\\r\\n\\t\\t\\t\\t\\t\\tif (f instanceof FromFactorCrossJoin)\\r\\n\\t\\t\\t\\t\\t\\t\\tjoin = \\\"CROSS JOIN\\\";\\r\\n\\t\\t\\t\\t\\t\\telse if (f instanceof FromFactorFullJoin)\\r\\n\\t\\t\\t\\t\\t\\t\\tjoin = \\\"FULL JOIN\\\";\\r\\n\\t\\t\\t\\t\\t\\telse if (f instanceof FromFactorInnerJoin)\\r\\n\\t\\t\\t\\t\\t\\t\\tjoin = \\\"JOIN\\\";\\r\\n\\t\\t\\t\\t\\t\\telse if (f instanceof FromFactorLeftJoin)\\r\\n\\t\\t\\t\\t\\t\\t\\tjoin = \\\"LEFT JOIN\\\";\\r\\n\\t\\t\\t\\t\\t\\telse throw new Error(\\\"Unsupported join\\\");\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn `${left} ${join} ${right} ON ${condition}`;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\telse if (f instanceof FromFactorCrossJoin) {\\r\\n\\t\\t\\t\\t\\t\\treturn `${left} CROSS JOIN ${right}`;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\telse throw new Error(\\\"Unknown join.\\\");\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.fromFactorDispatcher.dispatch(f, context);\\r\\n\\t}\\r\\n\\r\\n\\tprotected escapeValue(expr: Exprs.ValueExpression<AnyType>, context: ExpressionContext): string {\\r\\n\\t\\tconst val = expr.value;\\r\\n\\t\\tconst serialized = expr.type.serialize(val);\\r\\n\\r\\n\\t\\tcontext.context.parameters.push(serialized);\\r\\n\\t\\treturn \\\"?\\\";\\r\\n\\t}\\r\\n\\r\\n\\tprivate expressionToSql(e: Exprs.Expression<AnyType>, context: ExpressionContext, parentPrecedenceLevel: number = 1000): string {\\r\\n\\t\\tconst result = this.expressionToSqlAutoParenthesis(e, context);\\r\\n\\t\\tif (e.precedenceLevel > parentPrecedenceLevel)\\r\\n\\t\\t\\treturn `(${result})`;\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n\\tprivate expressionDispatcherInitialized = false;\\r\\n\\tprivate expressionDispatcher = new DynamicDispatcher<Exprs.Expression<AnyType>, ExpressionContext, string>();\\r\\n\\r\\n\\tprivate expressionToSqlAutoParenthesis(e: Exprs.Expression<AnyType>, context: ExpressionContext): string {\\r\\n\\t\\tif (!this.expressionDispatcherInitialized) {\\r\\n\\t\\t\\tthis.expressionDispatcherInitialized = true;\\r\\n\\r\\n\\t\\t\\tthis.expressionDispatcher\\r\\n\\t\\t\\t\\t.register(Exprs.NamedExpressionWrapper, (e, context) => {\\r\\n\\t\\t\\t\\t\\tif (context.resolveNamedExpression)\\r\\n\\t\\t\\t\\t\\t\\treturn this.expressionToSql(e.expression, context);\\r\\n\\t\\t\\t\\t\\telse\\r\\n\\t\\t\\t\\t\\t\\treturn this.quoteColumnName(e.name);\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.ValueExpression, (e, context) => this.escapeValue(e, context))\\r\\n\\t\\t\\t\\t.register(Exprs.Column, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst columnName = this.quoteColumnName(e.name);\\r\\n\\t\\t\\t\\t\\tif (context.isColumnNameUnambigous(e.name))\\r\\n\\t\\t\\t\\t\\t\\treturn columnName;\\r\\n\\r\\n\\t\\t\\t\\t\\tconst tableName = this.referToFromItem(e.fromItem);\\r\\n\\t\\t\\t\\t\\treturn `${tableName}.${columnName}`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.FromItemExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst tableName = this.referToFromItem(e.fromItem, false);\\r\\n\\t\\t\\t\\t\\treturn tableName;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.AllExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst tableName = this.referToFromItem(e.fromItem);\\r\\n\\t\\t\\t\\t\\treturn `${tableName}.*`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.BinaryOperatorExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst operator = e.operator;\\r\\n\\r\\n\\t\\t\\t\\t\\tconst left = this.expressionToSql(e.left, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\tconst right = this.expressionToSql(e.right, context, e.precedenceLevel);\\r\\n\\r\\n\\t\\t\\t\\t\\treturn `${left} ${operator} ${right}`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.KnownFunctionInvocation, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst functionName = e.functionName.toUpperCase();\\r\\n\\t\\t\\t\\t\\tconst args = e.args.map(arg => this.expressionToSql(arg, context)).join(\\\", \\\");\\r\\n\\t\\t\\t\\t\\treturn `${functionName}(${args})`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.RetrievalQueryAsExpression, (e, context) => `(${this.transformToSql(e.query, context.context)})`)\\r\\n\\t\\t\\t\\t.register(Exprs.IsInValuesExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tif (e.values.length === 0)\\r\\n\\t\\t\\t\\t\\t\\treturn this.expressionToSql(Exprs.val(false, true), context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} IN (${e.values.map(v => this.expressionToSql(v, context)).join(\\\", \\\")})`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.IsInQueryExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} IN (${this.transformToSql(e.query, context.context)})`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.LikeExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} LIKE ${this.expressionToSql(e.like, context, e.precedenceLevel)}`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.NotExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `NOT ${arg}`\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.IsNullExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} IS NULL`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.IsNotNullExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.argument, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg} IS NOT NULL`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.JsonPropertyAccess, (e, context) => {\\r\\n\\t\\t\\t\\t\\tconst arg = this.expressionToSql(e.expression, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t\\treturn `${arg}->${this.escapeValue(Exprs.val(e.key, true), context)}`;\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t\\t.register(Exprs.CastExpression, (e, context) => {\\r\\n\\t\\t\\t\\t\\treturn this.expressionToSql(e.expression, context, e.precedenceLevel);\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.expressionDispatcher.dispatch(e, context);\\r\\n\\t}\\r\\n}\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/SqlGenerator.ts\n// module id = 247\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/SqlGenerator.ts?./~/raw-loader");

/***/ }),

/***/ 248:
/***/ (function(module, exports) {

eval("module.exports = \"export * from \\\"./AST/Expressions\\\";\\r\\nexport * from \\\"./AST/Ordering\\\";\\r\\nexport * from \\\"./AST/Table\\\";\\r\\nexport * from \\\"./AST/FromFactor\\\";\\r\\nexport * from \\\"./AST/Types\\\";\\r\\n\\r\\nexport * from \\\"./AST/Queries/Query\\\";\\r\\nexport * from \\\"./AST/Queries/RetrievalQuery\\\";\\r\\nexport * from \\\"./AST/Queries/SelectQuery\\\";\\r\\nexport * from \\\"./AST/Queries/ValuesQuery\\\";\\r\\nexport * from \\\"./AST/Queries/InsertQuery\\\";\\r\\nexport * from \\\"./AST/Queries/UpdateQuery\\\";\\r\\nexport * from \\\"./AST/Queries/DeleteQuery\\\";\\r\\n\\r\\nexport * from \\\"./DbConnection\\\";\\r\\nexport * from \\\"./SqlGenerator\\\";\\r\\n\\r\\nexport * from \\\"./Adapters/Postgre\\\";\\r\\nexport * from \\\"./Adapters/PostgreSqlGenerator\\\";\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/index.ts\n// module id = 248\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/index.ts?./~/raw-loader");

/***/ }),

/***/ 249:
/***/ (function(module, exports) {

eval("module.exports = \"\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!../src/main.d.ts\n// module id = 249\n// module chunks = 1\n\n//# sourceURL=webpack:///../src/main.d.ts?./~/raw-loader");

/***/ }),

/***/ 250:
/***/ (function(module, exports) {

eval("module.exports = \"import { select, from, val, table, tText, tInteger, tJson, jsonVal, concat, deleteFrom, insertInto, values, update } from \\\"hediet-typed-sql\\\";\\r\\n\\r\\n// table definitions.\\r\\nconst organizations = table(\\\"organizations\\\",\\r\\n\\t{ name: tText, parentOrganizationId: tInteger, },\\r\\n\\t{ id: tInteger }\\r\\n);\\r\\n\\r\\nconst customers = table({ name: \\\"customers\\\", schema: \\\"public\\\" },\\r\\n\\t{ firstname: tText, lastname: tText, country: tText, data: tJson<{ key: string }>() },\\r\\n\\t{ id: tInteger }\\r\\n);\\r\\n\\r\\nconst orders = table({ name: \\\"orders\\\", schema: \\\"public\\\" },\\r\\n\\t{ customerId: tInteger, orderDate: tText },\\r\\n\\t{ id: tInteger }\\r\\n);\\r\\n\\r\\n// Select all columns from customers.\\r\\nfrom(customers).select(customers.$all);\\r\\n\\r\\nfrom(customers).select(concat(customers.firstname, \\\" \\\", customers.lastname).as(\\\"fullname\\\"));\\r\\n\\r\\nfrom(customers).select(\\\"firstname\\\").where({ id: 1 });\\r\\n\\r\\nfrom(customers).select(\\\"id\\\").where(customers.firstname.toLower().isLike(\\\"h%\\\"));\\r\\n\\r\\nfrom(customers).select(customers.$all).where(customers.id.isIn([1, 2]));\\r\\n\\r\\nfrom(customers).select(customers.$all).where(customers.id.isInQuery(\\r\\n\\tfrom(orders).select(orders.customerId)\\r\\n));\\r\\n\\r\\nfrom(orders).leftJoin(customers).on({ id: orders.id })\\r\\n\\t.select(customers.$all)\\r\\n\\t.select(orders.asExpression().toJson().as(\\\"order\\\"))\\r\\n\\r\\n// Simple Join:\\r\\nfrom(orders)\\r\\n\\t.leftJoin(customers).on({ id: orders.customerId })\\r\\n\\t.select(orders.id, customers.lastname);\\r\\n\\r\\n// Self Join:\\r\\nconst parentOrg = organizations.as(\\\"parent\\\");\\r\\nfrom(organizations)\\r\\n\\t.leftJoin(parentOrg).on({ parentOrganizationId: organizations.id })\\r\\n\\t.select(organizations.name.as(\\\"name\\\"), parentOrg.name.as(\\\"parentName\\\"));\\r\\n\\r\\n// Join with group by:\\r\\nfrom(orders).leftJoin(customers).on({ id: orders.customerId }).groupBy(customers.country).select(customers.$all.count().as(\\\"count\\\"));\\r\\n\\r\\n\\r\\n// Update\\r\\nupdate(orders).set({ id: 0 }).where({ id: 10 });\\r\\n\\r\\n// Insert\\r\\ninsertInto(customers).value({ firstname: \\\"John\\\", lastname: \\\"Doe\\\", country: \\\"de\\\", data: { key: \\\"123\\\" } });\\r\\n\\r\\ninsertInto(customers).valuesFrom(from(customers).select(val(\\\"de\\\").as(\\\"country\\\"), jsonVal({ key: \\\"test\\\" }).as(\\\"data\\\")).select(\\\"firstname\\\", \\\"lastname\\\"));\\r\\n\\r\\n// Delete\\r\\ndeleteFrom(orders).where({ id: 0 });\\r\\n\"\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./src/content.ts\n// module id = 250\n// module chunks = 1\n\n//# sourceURL=webpack:///./src/content.ts?./~/raw-loader");

/***/ }),

/***/ 349:
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(170);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(348)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./style.scss\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/style.scss\n// module id = 349\n// module chunks = 1\n\n//# sourceURL=webpack:///./src/style.scss?");

/***/ }),

/***/ 355:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// crypto (ignored)\n// module id = 355\n// module chunks = 1\n\n//# sourceURL=webpack:///crypto_(ignored)?");

/***/ }),

/***/ 356:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// util (ignored)\n// module id = 356\n// module chunks = 1\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 357:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// fs (ignored)\n// module id = 357\n// module chunks = 1\n\n//# sourceURL=webpack:///fs_(ignored)?");

/***/ }),

/***/ 358:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// os (ignored)\n// module id = 358\n// module chunks = 1\n\n//# sourceURL=webpack:///os_(ignored)?");

/***/ }),

/***/ 359:
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// path (ignored)\n// module id = 359\n// module chunks = 1\n\n//# sourceURL=webpack:///path_(ignored)?");

/***/ }),

/***/ 360:
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(145);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi ./src/index.tsx\n// module id = 360\n// module chunks = 1\n\n//# sourceURL=webpack:///multi_./src/index.tsx?");

/***/ })

},[360]);